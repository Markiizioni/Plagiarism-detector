from fastapi import FastAPI, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import os
import logging
import httpx
from dotenv import load_dotenv

from app.similarity_threshold import SimilarityAnalyzer
from app.utils import normalize_code 

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(title="Threshold Based Plagiarism Detection Microservice")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

# Initialize similarity analyzer with default thresholds
similarity_analyzer = SimilarityAnalyzer(
    high_similarity_threshold=float(os.getenv("HIGH_SIMILARITY_THRESHOLD", "0.85")),
    medium_similarity_threshold=float(os.getenv("MEDIUM_SIMILARITY_THRESHOLD", "0.70")),
    low_similarity_threshold=float(os.getenv("LOW_SIMILARITY_THRESHOLD", "0.55"))
)

# Set the URL for the repository processing microservice (handles cloning, embedding, and storing)
PROCESSING_SERVICE_URL = os.getenv("PROCESSING_SERVICE_URL", "http://localhost:8000")

class RepositoryRequest(BaseModel):
    repo_urls: list[str] = []

class CodeSimilarityRequest(BaseModel):
    code: str
    top_k: int = 10
    analyze_plagiarism: bool = True  # Default to true for code similarity checks

@app.post("/clone-and-process")
async def clone_repos(request: RepositoryRequest):
    """
    Trigger repository cloning in the processing microservice.
    
    Args:
        request: Repository request containing repo URLs
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{PROCESSING_SERVICE_URL}/clone-and-process", 
                json={
                    "repo_urls": request.repo_urls,
                    "embed": True  # Always generate embeddings
                },
                timeout=300.0  # 5-minute timeout for cloning
            )
            
            # Raise an exception for bad responses
            response.raise_for_status()
            
            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error connecting to processing service: {e}")
        raise HTTPException(
            status_code=500, 
            detail=f"Failed to connect to processing service: {e}"
        )
    except httpx.HTTPStatusError as e:
        logger.error(f"Processing service returned an error: {e}")
        raise HTTPException(
            status_code=e.response.status_code, 
            detail=f"Processing service error: {e.response.text}"
        )

@app.post("/get-embedding")
async def generate_embedding(request: CodeSimilarityRequest):
    """Generate an embedding for the provided code."""
    try:
        # Send the code to the processing service for embedding
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{PROCESSING_SERVICE_URL}/get-embedding", 
                json={"code": request.code}
            )
            response.raise_for_status()
            return response.json()  # Return the embedding generated by the processing service
    except httpx.RequestError as e:
        logger.error(f"Error connecting to processing service: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to connect to processing service: {e}")
    except httpx.HTTPStatusError as e:
        logger.error(f"Processing service returned an error: {e}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Processing service error: {e.response.text}")

@app.post("/search-similar")
async def search_similar_code(request: CodeSimilarityRequest):
    """Search for similar code chunks for the provided code using vector store and thresholds."""
    try:
        # Normalize the code before embedding
        normalized_code = normalize_code(request.code)
        
        # Get embedding from processing service
        async with httpx.AsyncClient() as client:
            embedding_response = await client.post(
                f"{PROCESSING_SERVICE_URL}/get-embedding", 
                json={"code": normalized_code}
            )
            embedding_response.raise_for_status()
            code_embedding = embedding_response.json()['embedding']

            # Search for similar code chunks using the embedding
            search_response = await client.post(
                f"{PROCESSING_SERVICE_URL}/search-similar", 
                json={"embedding": code_embedding, "top_k": request.top_k}
            )
            search_response.raise_for_status()
            similar_chunks = search_response.json()['similar_chunks']
        
        # Apply plagiarism analysis if requested
        if request.analyze_plagiarism:
            plagiarism_analysis = similarity_analyzer.analyze_search_results(similar_chunks)
            return {
                "message": f"Found {len(similar_chunks)} similar code chunks",
                "query_code_length": len(request.code),
                "results": plagiarism_analysis["results"],
                "plagiarism_analysis": {
                    "summary": plagiarism_analysis["analysis"],
                    "plagiarism_detected": plagiarism_analysis["plagiarism_detected"],
                    "high_similarity_count": plagiarism_analysis["high_similarity_count"],
                    "medium_similarity_count": plagiarism_analysis["medium_similarity_count"],
                    "low_similarity_count": plagiarism_analysis["low_similarity_count"]
                }
            }
        else:
            return {
                "message": f"Found {len(similar_chunks)} similar code chunks",
                "query_code_length": len(request.code),
                "results": similar_chunks
            }
    except httpx.RequestError as e:
        logger.error(f"Error connecting to processing service: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to connect to processing service: {e}")
    except httpx.HTTPStatusError as e:
        logger.error(f"Processing service returned an error: {e}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Processing service error: {e.response.text}")
    except Exception as e:
        logger.error(f"Unexpected error in searching similar code: {e}")
        raise HTTPException(status_code=500, detail=f"Search failed: {e}")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
