["import java.util.scanner;\npublic class t2 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter the radius and length of a cylinder: \");\ndouble radius = input.nextdouble();\ndouble length = input.nextdouble();\ndouble area = radius * radius * 3.14159;\ndouble volume = area * length;\nsystem.out.println(\"the area is \" + area);\nsystem.out.println(\"the volume of the cylinder is \" + volume);\n}\n}", "import java.util.scanner;\npublic class t3 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter weight in pounds: \");\ndouble weight = input.nextdouble();\nsystem.out.print(\"enter feet: \");\ndouble feet = input.nextdouble();\nsystem.out.print(\"enter inches: \");\ndouble inches = input.nextdouble();\ndouble height = feet * 12 + inches;\ndouble bmi = weight * 0.45359237 / ((height * 0.0254) * (height * 0.0254));\nsystem.out.println(\"bmi is \" + bmi);\nif (bmi < 18.5)\nsystem.out.println(\"underweight\");\nelse if (bmi < 25)\nsystem.out.println(\"normal\");\nelse if (bmi < 30)\nsystem.out.println(\"overweight\");\nelse\nsystem.out.println(\"obese\");\n}\n}", "public class t4 {\npublic static void main(string[] args) {\nsystem.out.println(\"miles\\t\\tkilometers\");\nsystem.out.println(\"-------------------------------\");\nint miles = 1;\nwhile (miles <= 10) {\nsystem.out.println(miles + \"\\t\\t\" + miles * 1.609);\nmiles++;\n}\n}\n}", "public class t5 {\npublic static void main(string[] args) {\nsystem.out.print(\"enter an integer: \");\njava.util.scanner input = new java.util.scanner(system.in);\nint number = input.nextint();\nreverse(number);\n}\npublic static void reverse(int number) {\nwhile (number != 0) {\nint remainder = number % 10;\nsystem.out.print(remainder);\nnumber = number / 10;\n}\nsystem.out.println();\n}\n}", "public class t6 {\npublic static void main(string[] args) {\njava.util.scanner input = new java.util.scanner(system.in);\nint[] num = new int[10];\nfor (int i = 0; i < 10; i++) {\nsystem.out.print(\"read a number: \");\nnum[i] = input.nextint();\n}\nfor (int i = 9; i >= 0; i--) {\nsystem.out.println(num[i]);\n}\n}\n}", "import java.util.scanner;\npublic class t7 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter a 4 by 4 matrix row by row: \");\ndouble[][] m = new double[4][4];\nfor (int i = 0; i < 4; i++)\nfor (int j = 0; j < 4; j++)\nm[i][j] = input.nextdouble();\nsystem.out.print(\"sum of the elements in the major diagonal is \" + summajordiagonal(m));\n}\npublic static double summajordiagonal(double[][] m) {\ndouble sum = 0;\nfor (int i = 0; i < m.length; i++)\nsum += m[i][i];\nreturn sum;\n}\n}", "public class t1 {\npublic static void main(string[] args) {\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\n}\n}", "from __future__ import annotations\nimport os\nimport typing as t\nfrom collections import defaultdict\nfrom functools import update_wrapper\nfrom .. import typing as ft\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import scaffold\nfrom .scaffold import setupmethod\nif t.type_checking:\nfrom .app import app\ndeferredsetupfunction = t.callable[[\"blueprintsetupstate\"], none]\nt_after_request = t.typevar(\"t_after_request\", bound=ft.afterrequestcallable[t.any])\nt_before_request = t.typevar(\"t_before_request\", bound=ft.beforerequestcallable)\nt_error_handler = t.typevar(\"t_error_handler\", bound=ft.errorhandlercallable)\nt_teardown = t.typevar(\"t_teardown\", bound=ft.teardowncallable)\nt_template_context_processor = t.typevar(\n\"t_template_context_processor\", bound=ft.templatecontextprocessorcallable\n)\nt_template_filter = t.typevar(\"t_template_filter\", bound=ft.templatefiltercallable)\nt_template_global = t.typevar(\"t_template_global\", bound=ft.templateglobalcallable)\nt_template_test = t.typevar(\"t_template_test\", bound=ft.templatetestcallable)\nt_url_defaults = t.typevar(\"t_url_defaults\", bound=ft.urldefaultcallable)\nt_url_value_preprocessor = t.typevar(\n\"t_url_value_preprocessor\", bound=ft.urlvaluepreprocessorcallable\n)\nclass blueprintsetupstate:\ndef __init__(\nself,\nblueprint: blueprint,\napp: app,\noptions: t.any,\nfirst_registration: bool,\n) -> none:\nself.app = app\nself.blueprint = blueprint\nself.options = options\nself.first_registration = first_registration\nsubdomain = self.options.get(\"subdomain\")\nif subdomain is none:\nsubdomain = self.blueprint.subdomain\nself.subdomain = subdomain\nurl_prefix = self.options.get(\"url_prefix\")\nif url_prefix is none:\nurl_prefix = self.blueprint.url_prefix\nself.url_prefix = url_prefix\nself.name = self.options.get(\"name\", blueprint.name)\nself.name_prefix = self.options.get(\"name_prefix\", \"\")\nself.url_defaults = dict(self.blueprint.url_values_defaults)\nself.url_defaults.update(self.options.get(\"url_defaults\", ()))\ndef add_url_rule(\nself,\nrule: str,\nendpoint: str | none = none,", "url_prefix = self.options.get(\"url_prefix\")\nif url_prefix is none:\nurl_prefix = self.blueprint.url_prefix\nself.url_prefix = url_prefix\nself.name = self.options.get(\"name\", blueprint.name)\nself.name_prefix = self.options.get(\"name_prefix\", \"\")\nself.url_defaults = dict(self.blueprint.url_values_defaults)\nself.url_defaults.update(self.options.get(\"url_defaults\", ()))\ndef add_url_rule(\nself,\nrule: str,\nendpoint: str | none = none,\nview_func: ft.routecallable | none = none,\n**options: t.any,\n) -> none:\nif self.url_prefix is not none:\nif rule:\nrule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\nelse:\nrule = self.url_prefix\noptions.setdefault(\"subdomain\", self.subdomain)\nif endpoint is none:\nendpoint = _endpoint_from_view_func(view_func)\ndefaults = self.url_defaults\nif \"defaults\" in options:\ndefaults = dict(defaults, **options.pop(\"defaults\"))\nself.app.add_url_rule(\nrule,\nf\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\nview_func,\ndefaults=defaults,\n**options,\n)\nclass blueprint(scaffold):\n_got_registered_once = false\ndef __init__(\nself,\nname: str,\nimport_name: str,\nstatic_folder: str | os.pathlike[str] | none = none,\nstatic_url_path: str | none = none,\ntemplate_folder: str | os.pathlike[str] | none = none,\nurl_prefix: str | none = none,\nsubdomain: str | none = none,\nurl_defaults: dict[str, t.any] | none = none,\nroot_path: str | none = none,\ncli_group: str | none = _sentinel,\n):\nsuper().__init__(\nimport_name=import_name,\nstatic_folder=static_folder,\nstatic_url_path=static_url_path,\ntemplate_folder=template_folder,\nroot_path=root_path,\n)\nif not name:\nraise valueerror(\"'name' may not be empty.\")\nif \".\" in name:\nraise valueerror(\"'name' may not contain a dot '.' character.\")\nself.name = name\nself.url_prefix = url_prefix\nself.subdomain = subdomain\nself.deferred_functions: list[deferredsetupfunction] = []\nif url_defaults is none:\nurl_defaults = {}\nself.url_values_defaults = url_defaults\nself.cli_group = cli_group", "root_path=root_path,\n)\nif not name:\nraise valueerror(\"'name' may not be empty.\")\nif \".\" in name:\nraise valueerror(\"'name' may not contain a dot '.' character.\")\nself.name = name\nself.url_prefix = url_prefix\nself.subdomain = subdomain\nself.deferred_functions: list[deferredsetupfunction] = []\nif url_defaults is none:\nurl_defaults = {}\nself.url_values_defaults = url_defaults\nself.cli_group = cli_group\nself._blueprints: list[tuple[blueprint, dict[str, t.any]]] = []\ndef _check_setup_finished(self, f_name: str) -> none:\nif self._got_registered_once:\nraise assertionerror(\nf\"the setup method '{f_name}' can no longer be called on the blueprint\"\nf\" '{self.name}'. it has already been registered at least once, any\"\n\" changes will not be applied consistently.\\n\"\n\"make sure all imports, decorators, functions, etc. needed to set up\"\n\" the blueprint are done before registering it.\"\n)\n@setupmethod\ndef record(self, func: deferredsetupfunction) -> none:\nself.deferred_functions.append(func)\n@setupmethod\ndef record_once(self, func: deferredsetupfunction) -> none:\ndef wrapper(state: blueprintsetupstate) -> none:\nif state.first_registration:\nfunc(state)\nself.record(update_wrapper(wrapper, func))\ndef make_setup_state(\nself, app: app, options: dict[str, t.any], first_registration: bool = false\n) -> blueprintsetupstate:\nreturn blueprintsetupstate(self, app, options, first_registration)\n@setupmethod\ndef register_blueprint(self, blueprint: blueprint, **options: t.any) -> none:\nif blueprint is self:\nraise valueerror(\"cannot register a blueprint on itself\")\nself._blueprints.append((blueprint, options))\ndef register(self, app: app, options: dict[str, t.any]) -> none:\nname_prefix = options.get(\"name_prefix\", \"\")\nself_name = options.get(\"name\", self.name)\nname = f\"{name_prefix}.{self_name}\".lstrip(\".\")\nif name in app.blueprints:\nbp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\nexisting_at = f\" '{name}'\" if self_name != name else \"\"\nraise valueerror(\nf\"the name '{self_name}' is already registered for\"\nf\" {bp_desc} blueprint{existing_at}. use 'name=' to\"", "name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\nif name in app.blueprints:\nbp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\nexisting_at = f\" '{name}'\" if self_name != name else \"\"\nraise valueerror(\nf\"the name '{self_name}' is already registered for\"\nf\" {bp_desc} blueprint{existing_at}. use 'name=' to\"\nf\" provide a unique name.\"\n)\nfirst_bp_registration = not any(bp is self for bp in app.blueprints.values())\nfirst_name_registration = name not in app.blueprints\napp.blueprints[name] = self\nself._got_registered_once = true\nstate = self.make_setup_state(app, options, first_bp_registration)\nif self.has_static_folder:\nstate.add_url_rule(\nf\"{self.static_url_path}/<path:filename>\",\nview_func=self.send_static_file,\nendpoint=\"static\",\n)\nif first_bp_registration or first_name_registration:\nself._merge_blueprint_funcs(app, name)\nfor deferred in self.deferred_functions:\ndeferred(state)\ncli_resolved_group = options.get(\"cli_group\", self.cli_group)\nif self.cli.commands:\nif cli_resolved_group is none:\napp.cli.commands.update(self.cli.commands)\nelif cli_resolved_group is _sentinel:\nself.cli.name = name\napp.cli.add_command(self.cli)\nelse:\nself.cli.name = cli_resolved_group\napp.cli.add_command(self.cli)\nfor blueprint, bp_options in self._blueprints:\nbp_options = bp_options.copy()\nbp_url_prefix = bp_options.get(\"url_prefix\")\nbp_subdomain = bp_options.get(\"subdomain\")\nif bp_subdomain is none:\nbp_subdomain = blueprint.subdomain\nif state.subdomain is not none and bp_subdomain is not none:\nbp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\nelif bp_subdomain is not none:\nbp_options[\"subdomain\"] = bp_subdomain\nelif state.subdomain is not none:\nbp_options[\"subdomain\"] = state.subdomain\nif bp_url_prefix is none:\nbp_url_prefix = blueprint.url_prefix\nif state.url_prefix is not none and bp_url_prefix is not none:\nbp_options[\"url_prefix\"] = (\nstate.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n)\nelif bp_url_prefix is not none:\nbp_options[\"url_prefix\"] = bp_url_prefix\nelif state.url_prefix is not none:", "elif state.subdomain is not none:\nbp_options[\"subdomain\"] = state.subdomain\nif bp_url_prefix is none:\nbp_url_prefix = blueprint.url_prefix\nif state.url_prefix is not none and bp_url_prefix is not none:\nbp_options[\"url_prefix\"] = (\nstate.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n)\nelif bp_url_prefix is not none:\nbp_options[\"url_prefix\"] = bp_url_prefix\nelif state.url_prefix is not none:\nbp_options[\"url_prefix\"] = state.url_prefix\nbp_options[\"name_prefix\"] = name\nblueprint.register(app, bp_options)\ndef _merge_blueprint_funcs(self, app: app, name: str) -> none:\ndef extend(\nbp_dict: dict[ft.apporblueprintkey, list[t.any]],\nparent_dict: dict[ft.apporblueprintkey, list[t.any]],\n) -> none:\nfor key, values in bp_dict.items():\nkey = name if key is none else f\"{name}.{key}\"\nparent_dict[key].extend(values)\nfor key, value in self.error_handler_spec.items():\nkey = name if key is none else f\"{name}.{key}\"\nvalue = defaultdict(\ndict,\n{\ncode: {exc_class: func for exc_class, func in code_values.items()}\nfor code, code_values in value.items()\n},\n)\napp.error_handler_spec[key] = value\nfor endpoint, func in self.view_functions.items():\napp.view_functions[endpoint] = func\nextend(self.before_request_funcs, app.before_request_funcs)\nextend(self.after_request_funcs, app.after_request_funcs)\nextend(\nself.teardown_request_funcs,\napp.teardown_request_funcs,\n)\nextend(self.url_default_functions, app.url_default_functions)\nextend(self.url_value_preprocessors, app.url_value_preprocessors)\nextend(self.template_context_processors, app.template_context_processors)\n@setupmethod\ndef add_url_rule(\nself,\nrule: str,\nendpoint: str | none = none,\nview_func: ft.routecallable | none = none,\nprovide_automatic_options: bool | none = none,\n**options: t.any,\n) -> none:\nif endpoint and \".\" in endpoint:\nraise valueerror(\"'endpoint' may not contain a dot '.' character.\")\nif view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\nraise valueerror(\"'view_func' name may not contain a dot '.' character.\")\nself.record(\nlambda s: s.add_url_rule(\nrule,\nendpoint,\nview_func,", "provide_automatic_options: bool | none = none,\n**options: t.any,\n) -> none:\nif endpoint and \".\" in endpoint:\nraise valueerror(\"'endpoint' may not contain a dot '.' character.\")\nif view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\nraise valueerror(\"'view_func' name may not contain a dot '.' character.\")\nself.record(\nlambda s: s.add_url_rule(\nrule,\nendpoint,\nview_func,\nprovide_automatic_options=provide_automatic_options,\n**options,\n)\n)\n@setupmethod\ndef app_template_filter(\nself, name: str | none = none\n) -> t.callable[[t_template_filter], t_template_filter]:\ndef decorator(f: t_template_filter) -> t_template_filter:\nself.add_app_template_filter(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_app_template_filter(\nself, f: ft.templatefiltercallable, name: str | none = none\n) -> none:\ndef register_template(state: blueprintsetupstate) -> none:\nstate.app.jinja_env.filters[name or f.__name__] = f\nself.record_once(register_template)\n@setupmethod\ndef app_template_test(\nself, name: str | none = none\n) -> t.callable[[t_template_test], t_template_test]:\ndef decorator(f: t_template_test) -> t_template_test:\nself.add_app_template_test(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_app_template_test(\nself, f: ft.templatetestcallable, name: str | none = none\n) -> none:\ndef register_template(state: blueprintsetupstate) -> none:\nstate.app.jinja_env.tests[name or f.__name__] = f\nself.record_once(register_template)\n@setupmethod\ndef app_template_global(\nself, name: str | none = none\n) -> t.callable[[t_template_global], t_template_global]:\ndef decorator(f: t_template_global) -> t_template_global:\nself.add_app_template_global(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_app_template_global(\nself, f: ft.templateglobalcallable, name: str | none = none\n) -> none:\ndef register_template(state: blueprintsetupstate) -> none:\nstate.app.jinja_env.globals[name or f.__name__] = f\nself.record_once(register_template)\n@setupmethod", "self.add_app_template_global(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_app_template_global(\nself, f: ft.templateglobalcallable, name: str | none = none\n) -> none:\ndef register_template(state: blueprintsetupstate) -> none:\nstate.app.jinja_env.globals[name or f.__name__] = f\nself.record_once(register_template)\n@setupmethod\ndef before_app_request(self, f: t_before_request) -> t_before_request:\nself.record_once(\nlambda s: s.app.before_request_funcs.setdefault(none, []).append(f)\n)\nreturn f\n@setupmethod\ndef after_app_request(self, f: t_after_request) -> t_after_request:\nself.record_once(\nlambda s: s.app.after_request_funcs.setdefault(none, []).append(f)\n)\nreturn f\n@setupmethod\ndef teardown_app_request(self, f: t_teardown) -> t_teardown:\nself.record_once(\nlambda s: s.app.teardown_request_funcs.setdefault(none, []).append(f)\n)\nreturn f\n@setupmethod\ndef app_context_processor(\nself, f: t_template_context_processor\n) -> t_template_context_processor:\nself.record_once(\nlambda s: s.app.template_context_processors.setdefault(none, []).append(f)\n)\nreturn f\n@setupmethod\ndef app_errorhandler(\nself, code: type[exception] | int\n) -> t.callable[[t_error_handler], t_error_handler]:\ndef decorator(f: t_error_handler) -> t_error_handler:\ndef from_blueprint(state: blueprintsetupstate) -> none:\nstate.app.errorhandler(code)(f)\nself.record_once(from_blueprint)\nreturn f\nreturn decorator\n@setupmethod\ndef app_url_value_preprocessor(\nself, f: t_url_value_preprocessor\n) -> t_url_value_preprocessor:\nself.record_once(\nlambda s: s.app.url_value_preprocessors.setdefault(none, []).append(f)\n)\nreturn f\n@setupmethod\ndef app_url_defaults(self, f: t_url_defaults) -> t_url_defaults:\nself.record_once(\nlambda s: s.app.url_default_functions.setdefault(none, []).append(f)\n)\nreturn f", "import pytest\nfrom jinja2 import templatenotfound\nfrom werkzeug.http import parse_cache_control_header\nimport flask\ndef test_blueprint_specific_error_handling(app, client):\nfrontend = flask.blueprint(\"frontend\", __name__)\nbackend = flask.blueprint(\"backend\", __name__)\nsideend = flask.blueprint(\"sideend\", __name__)\n@frontend.errorhandler(403)\ndef frontend_forbidden(e):\nreturn \"frontend says no\", 403\n@frontend.route(\"/frontend-no\")\ndef frontend_no():\nflask.abort(403)\n@backend.errorhandler(403)\ndef backend_forbidden(e):\nreturn \"backend says no\", 403\n@backend.route(\"/backend-no\")\ndef backend_no():\nflask.abort(403)\n@sideend.route(\"/what-is-a-sideend\")\ndef sideend_no():\nflask.abort(403)\napp.register_blueprint(frontend)\napp.register_blueprint(backend)\napp.register_blueprint(sideend)\n@app.errorhandler(403)\ndef app_forbidden(e):\nreturn \"application itself says no\", 403\nassert client.get(\"/frontend-no\").data == b\"frontend says no\"\nassert client.get(\"/backend-no\").data == b\"backend says no\"\nassert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"\ndef test_blueprint_specific_user_error_handling(app, client):\nclass mydecoratorexception(exception):\npass\nclass myfunctionexception(exception):\npass\nblue = flask.blueprint(\"blue\", __name__)\n@blue.errorhandler(mydecoratorexception)\ndef my_decorator_exception_handler(e):\nassert isinstance(e, mydecoratorexception)\nreturn \"boom\"\ndef my_function_exception_handler(e):\nassert isinstance(e, myfunctionexception)\nreturn \"bam\"\nblue.register_error_handler(myfunctionexception, my_function_exception_handler)\n@blue.route(\"/decorator\")\ndef blue_deco_test():\nraise mydecoratorexception()\n@blue.route(\"/function\")\ndef blue_func_test():\nraise myfunctionexception()\napp.register_blueprint(blue)\nassert client.get(\"/decorator\").data == b\"boom\"\nassert client.get(\"/function\").data == b\"bam\"\ndef test_blueprint_app_error_handling(app, client):\nerrors = flask.blueprint(\"errors\", __name__)\n@errors.app_errorhandler(403)\ndef forbidden_handler(e):\nreturn \"you shall not pass\", 403\n@app.route(\"/forbidden\")\ndef app_forbidden():\nflask.abort(403)\nforbidden_bp = flask.blueprint(\"forbidden_bp\", __name__)", "assert client.get(\"/function\").data == b\"bam\"\ndef test_blueprint_app_error_handling(app, client):\nerrors = flask.blueprint(\"errors\", __name__)\n@errors.app_errorhandler(403)\ndef forbidden_handler(e):\nreturn \"you shall not pass\", 403\n@app.route(\"/forbidden\")\ndef app_forbidden():\nflask.abort(403)\nforbidden_bp = flask.blueprint(\"forbidden_bp\", __name__)\n@forbidden_bp.route(\"/nope\")\ndef bp_forbidden():\nflask.abort(403)\napp.register_blueprint(errors)\napp.register_blueprint(forbidden_bp)\nassert client.get(\"/forbidden\").data == b\"you shall not pass\"\nassert client.get(\"/nope\").data == b\"you shall not pass\"\n@pytest.mark.parametrize(\n(\"prefix\", \"rule\", \"url\"),\n(\n(\"\", \"/\", \"/\"),\n(\"/\", \"\", \"/\"),\n(\"/\", \"/\", \"/\"),\n(\"/foo\", \"\", \"/foo\"),\n(\"/foo/\", \"\", \"/foo/\"),\n(\"\", \"/bar\", \"/bar\"),\n(\"/foo/\", \"/bar\", \"/foo/bar\"),\n(\"/foo/\", \"bar\", \"/foo/bar\"),\n(\"/foo\", \"/bar\", \"/foo/bar\"),\n(\"/foo/\", \"\n(\"/foo\n),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\nbp = flask.blueprint(\"test\", __name__, url_prefix=prefix)\n@bp.route(rule)\ndef index():\nreturn \"\", 204\napp.register_blueprint(bp)\nassert client.get(url).status_code == 204\ndef test_blueprint_url_defaults(app, client):\nbp = flask.blueprint(\"test\", __name__)\n@bp.route(\"/foo\", defaults={\"baz\": 42})\ndef foo(bar, baz):\nreturn f\"{bar}/{baz:d}\"\n@bp.route(\"/bar\")\ndef bar(bar):\nreturn str(bar)\napp.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\napp.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\nassert client.get(\"/1/foo\").data == b\"23/42\"\nassert client.get(\"/2/foo\").data == b\"19/42\"\nassert client.get(\"/1/bar\").data == b\"23\"\nassert client.get(\"/2/bar\").data == b\"19\"\ndef test_blueprint_url_processors(app, client):\nbp = flask.blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n@bp.url_defaults\ndef add_language_code(endpoint, values):\nvalues.setdefault(\"lang_code\", flask.g.lang_code)", "assert client.get(\"/2/foo\").data == b\"19/42\"\nassert client.get(\"/1/bar\").data == b\"23\"\nassert client.get(\"/2/bar\").data == b\"19\"\ndef test_blueprint_url_processors(app, client):\nbp = flask.blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n@bp.url_defaults\ndef add_language_code(endpoint, values):\nvalues.setdefault(\"lang_code\", flask.g.lang_code)\n@bp.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\nflask.g.lang_code = values.pop(\"lang_code\")\n@bp.route(\"/\")\ndef index():\nreturn flask.url_for(\".about\")\n@bp.route(\"/about\")\ndef about():\nreturn flask.url_for(\".index\")\napp.register_blueprint(bp)\nassert client.get(\"/de/\").data == b\"/de/about\"\nassert client.get(\"/de/about\").data == b\"/de/\"\ndef test_templates_and_static(test_apps):\nfrom blueprintapp import app\nclient = app.test_client()\nrv = client.get(\"/\")\nassert rv.data == b\"hello from the frontend\"\nrv = client.get(\"/admin/\")\nassert rv.data == b\"hello from the admin\"\nrv = client.get(\"/admin/index2\")\nassert rv.data == b\"hello from the admin\"\nrv = client.get(\"/admin/static/test.txt\")\nassert rv.data.strip() == b\"admin file\"\nrv.close()\nrv = client.get(\"/admin/static/css/test.css\")\nassert rv.data.strip() == b\"\"\nrv.close()\nmax_age_default = app.config[\"send_file_max_age_default\"]\ntry:\nexpected_max_age = 3600\nif app.config[\"send_file_max_age_default\"] == expected_max_age:\nexpected_max_age = 7200\napp.config[\"send_file_max_age_default\"] = expected_max_age\nrv = client.get(\"/admin/static/css/test.css\")\ncc = parse_cache_control_header(rv.headers[\"cache-control\"])\nassert cc.max_age == expected_max_age\nrv.close()\nfinally:\napp.config[\"send_file_max_age_default\"] = max_age_default\nwith app.test_request_context():\nassert (\nflask.url_for(\"admin.static\", filename=\"test.txt\")\n== \"/admin/static/test.txt\"\n)\nwith app.test_request_context():\nwith pytest.raises(templatenotfound) as e:\nflask.render_template(\"missing.html\")\nassert e.value.name == \"missing.html\"\nwith flask.flask(__name__).test_request_context():\nassert flask.render_template(\"nested/nested.txt\") == \"i'm nested\"", "with app.test_request_context():\nassert (\nflask.url_for(\"admin.static\", filename=\"test.txt\")\n== \"/admin/static/test.txt\"\n)\nwith app.test_request_context():\nwith pytest.raises(templatenotfound) as e:\nflask.render_template(\"missing.html\")\nassert e.value.name == \"missing.html\"\nwith flask.flask(__name__).test_request_context():\nassert flask.render_template(\"nested/nested.txt\") == \"i'm nested\"\ndef test_default_static_max_age(app):\nclass myblueprint(flask.blueprint):\ndef get_send_file_max_age(self, filename):\nreturn 100\nblueprint = myblueprint(\"blueprint\", __name__, static_folder=\"static\")\napp.register_blueprint(blueprint)\nmax_age_default = app.config[\"send_file_max_age_default\"]\ntry:\nwith app.test_request_context():\nunexpected_max_age = 3600\nif app.config[\"send_file_max_age_default\"] == unexpected_max_age:\nunexpected_max_age = 7200\napp.config[\"send_file_max_age_default\"] = unexpected_max_age\nrv = blueprint.send_static_file(\"index.html\")\ncc = parse_cache_control_header(rv.headers[\"cache-control\"])\nassert cc.max_age == 100\nrv.close()\nfinally:\napp.config[\"send_file_max_age_default\"] = max_age_default\ndef test_templates_list(test_apps):\nfrom blueprintapp import app\ntemplates = sorted(app.jinja_env.list_templates())\nassert templates == [\"admin/index.html\", \"frontend/index.html\"]\ndef test_dotted_name_not_allowed(app, client):\nwith pytest.raises(valueerror):\nflask.blueprint(\"app.ui\", __name__)\ndef test_empty_name_not_allowed(app, client):\nwith pytest.raises(valueerror):\nflask.blueprint(\"\", __name__)\ndef test_dotted_names_from_app(app, client):\ntest = flask.blueprint(\"test\", __name__)\n@app.route(\"/\")\ndef app_index():\nreturn flask.url_for(\"test.index\")\n@test.route(\"/test/\")\ndef index():\nreturn flask.url_for(\"app_index\")\napp.register_blueprint(test)\nrv = client.get(\"/\")\nassert rv.data == b\"/test/\"\ndef test_empty_url_defaults(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.route(\"/\", defaults={\"page\": 1})\n@bp.route(\"/page/<int:page>\")\ndef something(page):\nreturn str(page)\napp.register_blueprint(bp)\nassert client.get(\"/\").data == b\"1\"\nassert client.get(\"/page/2\").data == b\"2\"\ndef test_route_decorator_custom_endpoint(app, client):", "assert rv.data == b\"/test/\"\ndef test_empty_url_defaults(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.route(\"/\", defaults={\"page\": 1})\n@bp.route(\"/page/<int:page>\")\ndef something(page):\nreturn str(page)\napp.register_blueprint(bp)\nassert client.get(\"/\").data == b\"1\"\nassert client.get(\"/page/2\").data == b\"2\"\ndef test_route_decorator_custom_endpoint(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.route(\"/foo\")\ndef foo():\nreturn flask.request.endpoint\n@bp.route(\"/bar\", endpoint=\"bar\")\ndef foo_bar():\nreturn flask.request.endpoint\n@bp.route(\"/bar/123\", endpoint=\"123\")\ndef foo_bar_foo():\nreturn flask.request.endpoint\n@bp.route(\"/bar/foo\")\ndef bar_foo():\nreturn flask.request.endpoint\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.request.endpoint\nassert client.get(\"/\").data == b\"index\"\nassert client.get(\"/py/foo\").data == b\"bp.foo\"\nassert client.get(\"/py/bar\").data == b\"bp.bar\"\nassert client.get(\"/py/bar/123\").data == b\"bp.123\"\nassert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\nbp = flask.blueprint(\"bp\", __name__)\nwith pytest.raises(valueerror):\nbp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\nwith pytest.raises(valueerror):\nbp.add_url_rule(\"/\", endpoint=\"a.b\")\ndef view():\nreturn \"\"\nview.__name__ = \"a.b\"\nwith pytest.raises(valueerror):\nbp.add_url_rule(\"/\", view_func=view)\ndef test_endpoint_decorator(app, client):\nfrom werkzeug.routing import rule\napp.url_map.add(rule(\"/foo\", endpoint=\"bar\"))\nbp = flask.blueprint(\"bp\", __name__)\n@bp.endpoint(\"bar\")\ndef foobar():\nreturn flask.request.endpoint\napp.register_blueprint(bp, url_prefix=\"/bp_prefix\")\nassert client.get(\"/foo\").data == b\"bar\"\nassert client.get(\"/bp_prefix/bar\").status_code == 404\ndef test_template_filter(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter()\ndef my_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"my_reverse\" in app.jinja_env.filters.keys()", "return flask.request.endpoint\napp.register_blueprint(bp, url_prefix=\"/bp_prefix\")\nassert client.get(\"/foo\").data == b\"bar\"\nassert client.get(\"/bp_prefix/bar\").status_code == 404\ndef test_template_filter(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter()\ndef my_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"my_reverse\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"my_reverse\"] == my_reverse\nassert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\ndef test_add_template_filter(app):\nbp = flask.blueprint(\"bp\", __name__)\ndef my_reverse(s):\nreturn s[::-1]\nbp.add_app_template_filter(my_reverse)\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"my_reverse\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"my_reverse\"] == my_reverse\nassert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\ndef test_template_filter_with_name(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter(\"strrev\")\ndef my_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"strrev\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"strrev\"] == my_reverse\nassert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\ndef test_add_template_filter_with_name(app):\nbp = flask.blueprint(\"bp\", __name__)\ndef my_reverse(s):\nreturn s[::-1]\nbp.add_app_template_filter(my_reverse, \"strrev\")\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"strrev\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"strrev\"] == my_reverse\nassert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\ndef test_template_filter_with_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter()\ndef super_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_filter_after_route_with_template(app, client):\n@app.route(\"/\")\ndef index():", "def test_template_filter_with_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter()\ndef super_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_filter_after_route_with_template(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter()\ndef super_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_add_template_filter_with_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\ndef super_reverse(s):\nreturn s[::-1]\nbp.add_app_template_filter(super_reverse)\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_filter_with_name_and_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_filter(\"super_reverse\")\ndef my_reverse(s):\nreturn s[::-1]\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_add_template_filter_with_name_and_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\ndef my_reverse(s):\nreturn s[::-1]\nbp.add_app_template_filter(my_reverse, \"super_reverse\")\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_test(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test()\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"is_boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"is_boolean\"] == is_boolean\nassert app.jinja_env.tests[\"is_boolean\"](false)\ndef test_add_template_test(app):", "assert rv.data == b\"dcba\"\ndef test_template_test(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test()\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"is_boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"is_boolean\"] == is_boolean\nassert app.jinja_env.tests[\"is_boolean\"](false)\ndef test_add_template_test(app):\nbp = flask.blueprint(\"bp\", __name__)\ndef is_boolean(value):\nreturn isinstance(value, bool)\nbp.add_app_template_test(is_boolean)\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"is_boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"is_boolean\"] == is_boolean\nassert app.jinja_env.tests[\"is_boolean\"](false)\ndef test_template_test_with_name(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test(\"boolean\")\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == is_boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_add_template_test_with_name(app):\nbp = flask.blueprint(\"bp\", __name__)\ndef is_boolean(value):\nreturn isinstance(value, bool)\nbp.add_app_template_test(is_boolean, \"boolean\")\napp.register_blueprint(bp, url_prefix=\"/py\")\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == is_boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_template_test_with_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test()\ndef boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_template_test_after_route_with_template(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test()\ndef boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data", "rv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_template_test_after_route_with_template(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test()\ndef boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_add_template_test_with_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\ndef boolean(value):\nreturn isinstance(value, bool)\nbp.add_app_template_test(boolean)\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_template_test_with_name_and_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_test(\"boolean\")\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_add_template_test_with_name_and_template(app, client):\nbp = flask.blueprint(\"bp\", __name__)\ndef is_boolean(value):\nreturn isinstance(value, bool)\nbp.add_app_template_test(is_boolean, \"boolean\")\napp.register_blueprint(bp, url_prefix=\"/py\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_context_processing(app, client):\nanswer_bp = flask.blueprint(\"answer_bp\", __name__)\ndef template_string():\nreturn flask.render_template_string(\n\"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n\"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n)\n@answer_bp.app_context_processor\ndef not_answer_context_processor():\nreturn {\"notanswer\": 43}\n@answer_bp.context_processor\ndef answer_context_processor():\nreturn {\"answer\": 42}\n@answer_bp.route(\"/bp\")\ndef bp_page():\nreturn template_string()\n@app.route(\"/\")\ndef app_page():\nreturn template_string()\napp.register_blueprint(answer_bp)\napp_page_bytes = client.get(\"/\").data\nanswer_page_bytes = client.get(\"/bp\").data", ")\n@answer_bp.app_context_processor\ndef not_answer_context_processor():\nreturn {\"notanswer\": 43}\n@answer_bp.context_processor\ndef answer_context_processor():\nreturn {\"answer\": 42}\n@answer_bp.route(\"/bp\")\ndef bp_page():\nreturn template_string()\n@app.route(\"/\")\ndef app_page():\nreturn template_string()\napp.register_blueprint(answer_bp)\napp_page_bytes = client.get(\"/\").data\nanswer_page_bytes = client.get(\"/bp\").data\nassert b\"43\" in app_page_bytes\nassert b\"42\" not in app_page_bytes\nassert b\"42\" in answer_page_bytes\nassert b\"43\" in answer_page_bytes\ndef test_template_global(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_template_global()\ndef get_answer():\nreturn 42\nassert \"get_answer\" not in app.jinja_env.globals.keys()\napp.register_blueprint(bp)\nassert \"get_answer\" in app.jinja_env.globals.keys()\nassert app.jinja_env.globals[\"get_answer\"] is get_answer\nassert app.jinja_env.globals[\"get_answer\"]() == 42\nwith app.app_context():\nrv = flask.render_template_string(\"{{ get_answer() }}\")\nassert rv == \"42\"\ndef test_request_processing(app, client):\nbp = flask.blueprint(\"bp\", __name__)\nevts = []\n@bp.before_request\ndef before_bp():\nevts.append(\"before\")\n@bp.after_request\ndef after_bp(response):\nresponse.data += b\"|after\"\nevts.append(\"after\")\nreturn response\n@bp.teardown_request\ndef teardown_bp(exc):\nevts.append(\"teardown\")\n@bp.route(\"/bp\")\ndef bp_endpoint():\nreturn \"request\"\napp.register_blueprint(bp)\nassert evts == []\nrv = client.get(\"/bp\")\nassert rv.data == b\"request|after\"\nassert evts == [\"before\", \"after\", \"teardown\"]\ndef test_app_request_processing(app, client):\nbp = flask.blueprint(\"bp\", __name__)\nevts = []\n@bp.before_app_request\ndef before_app():\nevts.append(\"before\")\n@bp.after_app_request\ndef after_app(response):\nresponse.data += b\"|after\"\nevts.append(\"after\")\nreturn response\n@bp.teardown_app_request\ndef teardown_app(exc):\nevts.append(\"teardown\")\napp.register_blueprint(bp)\n@app.route(\"/\")\ndef bp_endpoint():\nreturn \"request\"\nassert evts == []\nresp = client.get(\"/\").data", "evts = []\n@bp.before_app_request\ndef before_app():\nevts.append(\"before\")\n@bp.after_app_request\ndef after_app(response):\nresponse.data += b\"|after\"\nevts.append(\"after\")\nreturn response\n@bp.teardown_app_request\ndef teardown_app(exc):\nevts.append(\"teardown\")\napp.register_blueprint(bp)\n@app.route(\"/\")\ndef bp_endpoint():\nreturn \"request\"\nassert evts == []\nresp = client.get(\"/\").data\nassert resp == b\"request|after\"\nassert evts == [\"before\", \"after\", \"teardown\"]\nresp = client.get(\"/\").data\nassert resp == b\"request|after\"\nassert evts == [\"before\", \"after\", \"teardown\"] * 2\ndef test_app_url_processors(app, client):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.app_url_defaults\ndef add_language_code(endpoint, values):\nvalues.setdefault(\"lang_code\", flask.g.lang_code)\n@bp.app_url_value_preprocessor\ndef pull_lang_code(endpoint, values):\nflask.g.lang_code = values.pop(\"lang_code\")\n@app.route(\"/<lang_code>/\")\ndef index():\nreturn flask.url_for(\"about\")\n@app.route(\"/<lang_code>/about\")\ndef about():\nreturn flask.url_for(\"index\")\napp.register_blueprint(bp)\nassert client.get(\"/de/\").data == b\"/de/about\"\nassert client.get(\"/de/about\").data == b\"/de/\"\ndef test_nested_blueprint(app, client):\nparent = flask.blueprint(\"parent\", __name__)\nchild = flask.blueprint(\"child\", __name__)\ngrandchild = flask.blueprint(\"grandchild\", __name__)\n@parent.errorhandler(403)\ndef forbidden(e):\nreturn \"parent no\", 403\n@parent.route(\"/\")\ndef parent_index():\nreturn \"parent yes\"\n@parent.route(\"/no\")\ndef parent_no():\nflask.abort(403)\n@child.route(\"/\")\ndef child_index():\nreturn \"child yes\"\n@child.route(\"/no\")\ndef child_no():\nflask.abort(403)\n@grandchild.errorhandler(403)\ndef grandchild_forbidden(e):\nreturn \"grandchild no\", 403\n@grandchild.route(\"/\")\ndef grandchild_index():\nreturn \"grandchild yes\"\n@grandchild.route(\"/no\")\ndef grandchild_no():\nflask.abort(403)\nchild.register_blueprint(grandchild, url_prefix=\"/grandchild\")\nparent.register_blueprint(child, url_prefix=\"/child\")\napp.register_blueprint(parent, url_prefix=\"/parent\")", "flask.abort(403)\n@grandchild.errorhandler(403)\ndef grandchild_forbidden(e):\nreturn \"grandchild no\", 403\n@grandchild.route(\"/\")\ndef grandchild_index():\nreturn \"grandchild yes\"\n@grandchild.route(\"/no\")\ndef grandchild_no():\nflask.abort(403)\nchild.register_blueprint(grandchild, url_prefix=\"/grandchild\")\nparent.register_blueprint(child, url_prefix=\"/child\")\napp.register_blueprint(parent, url_prefix=\"/parent\")\nassert client.get(\"/parent/\").data == b\"parent yes\"\nassert client.get(\"/parent/child/\").data == b\"child yes\"\nassert client.get(\"/parent/child/grandchild/\").data == b\"grandchild yes\"\nassert client.get(\"/parent/no\").data == b\"parent no\"\nassert client.get(\"/parent/child/no\").data == b\"parent no\"\nassert client.get(\"/parent/child/grandchild/no\").data == b\"grandchild no\"\ndef test_nested_callback_order(app, client):\nparent = flask.blueprint(\"parent\", __name__)\nchild = flask.blueprint(\"child\", __name__)\n@app.before_request\ndef app_before1():\nflask.g.setdefault(\"seen\", []).append(\"app_1\")\n@app.teardown_request\ndef app_teardown1(e=none):\nassert flask.g.seen.pop() == \"app_1\"\n@app.before_request\ndef app_before2():\nflask.g.setdefault(\"seen\", []).append(\"app_2\")\n@app.teardown_request\ndef app_teardown2(e=none):\nassert flask.g.seen.pop() == \"app_2\"\n@app.context_processor\ndef app_ctx():\nreturn dict(key=\"app\")\n@parent.before_request\ndef parent_before1():\nflask.g.setdefault(\"seen\", []).append(\"parent_1\")\n@parent.teardown_request\ndef parent_teardown1(e=none):\nassert flask.g.seen.pop() == \"parent_1\"\n@parent.before_request\ndef parent_before2():\nflask.g.setdefault(\"seen\", []).append(\"parent_2\")\n@parent.teardown_request\ndef parent_teardown2(e=none):\nassert flask.g.seen.pop() == \"parent_2\"\n@parent.context_processor\ndef parent_ctx():\nreturn dict(key=\"parent\")\n@child.before_request\ndef child_before1():\nflask.g.setdefault(\"seen\", []).append(\"child_1\")\n@child.teardown_request\ndef child_teardown1(e=none):", "flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n@parent.teardown_request\ndef parent_teardown2(e=none):\nassert flask.g.seen.pop() == \"parent_2\"\n@parent.context_processor\ndef parent_ctx():\nreturn dict(key=\"parent\")\n@child.before_request\ndef child_before1():\nflask.g.setdefault(\"seen\", []).append(\"child_1\")\n@child.teardown_request\ndef child_teardown1(e=none):\nassert flask.g.seen.pop() == \"child_1\"\n@child.before_request\ndef child_before2():\nflask.g.setdefault(\"seen\", []).append(\"child_2\")\n@child.teardown_request\ndef child_teardown2(e=none):\nassert flask.g.seen.pop() == \"child_2\"\n@child.context_processor\ndef child_ctx():\nreturn dict(key=\"child\")\n@child.route(\"/a\")\ndef a():\nreturn \", \".join(flask.g.seen)\n@child.route(\"/b\")\ndef b():\nreturn flask.render_template_string(\"{{ key }}\")\nparent.register_blueprint(child)\napp.register_blueprint(parent)\nassert (\nclient.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n)\nassert client.get(\"/b\").data == b\"child\"\n@pytest.mark.parametrize(\n\"parent_init, child_init, parent_registration, child_registration\",\n[\n(\"/parent\", \"/child\", none, none),\n(\"/parent\", none, none, \"/child\"),\n(none, none, \"/parent\", \"/child\"),\n(\"/other\", \"/something\", \"/parent\", \"/child\"),\n],\n)\ndef test_nesting_url_prefixes(\nparent_init,\nchild_init,\nparent_registration,\nchild_registration,\napp,\nclient,\n) -> none:\nparent = flask.blueprint(\"parent\", __name__, url_prefix=parent_init)\nchild = flask.blueprint(\"child\", __name__, url_prefix=child_init)\n@child.route(\"/\")\ndef index():\nreturn \"index\"\nparent.register_blueprint(child, url_prefix=child_registration)\napp.register_blueprint(parent, url_prefix=parent_registration)\nresponse = client.get(\"/parent/child/\")\nassert response.status_code == 200\ndef test_nesting_subdomains(app, client) -> none:\napp.subdomain_matching = true\napp.config[\"server_name\"] = \"example.test\"\nclient.allow_subdomain_redirects = true\nparent = flask.blueprint(\"parent\", __name__)\nchild = flask.blueprint(\"child\", __name__)", "app.register_blueprint(parent, url_prefix=parent_registration)\nresponse = client.get(\"/parent/child/\")\nassert response.status_code == 200\ndef test_nesting_subdomains(app, client) -> none:\napp.subdomain_matching = true\napp.config[\"server_name\"] = \"example.test\"\nclient.allow_subdomain_redirects = true\nparent = flask.blueprint(\"parent\", __name__)\nchild = flask.blueprint(\"child\", __name__)\n@child.route(\"/child/\")\ndef index():\nreturn \"child\"\nparent.register_blueprint(child)\napp.register_blueprint(parent, subdomain=\"api\")\nresponse = client.get(\"/child/\", base_url=\"http:\nassert response.status_code == 200\ndef test_child_and_parent_subdomain(app, client) -> none:\napp.subdomain_matching = true\napp.config[\"server_name\"] = \"example.test\"\nclient.allow_subdomain_redirects = true\nparent = flask.blueprint(\"parent\", __name__)\nchild = flask.blueprint(\"child\", __name__, subdomain=\"api\")\n@child.route(\"/\")\ndef index():\nreturn \"child\"\nparent.register_blueprint(child)\napp.register_blueprint(parent, subdomain=\"parent\")\nresponse = client.get(\"/\", base_url=\"http:\nassert response.status_code == 200\nresponse = client.get(\"/\", base_url=\"http:\nassert response.status_code == 404\ndef test_unique_blueprint_names(app, client) -> none:\nbp = flask.blueprint(\"bp\", __name__)\nbp2 = flask.blueprint(\"bp\", __name__)\napp.register_blueprint(bp)\nwith pytest.raises(valueerror):\napp.register_blueprint(bp)\napp.register_blueprint(bp, name=\"again\")\nwith pytest.raises(valueerror):\napp.register_blueprint(bp2)\napp.register_blueprint(bp2, name=\"alt\")\ndef test_self_registration(app, client) -> none:\nbp = flask.blueprint(\"bp\", __name__)\nwith pytest.raises(valueerror):\nbp.register_blueprint(bp)\ndef test_blueprint_renaming(app, client) -> none:\nbp = flask.blueprint(\"bp\", __name__)\nbp2 = flask.blueprint(\"bp2\", __name__)\n@bp.get(\"/\")\ndef index():\nreturn flask.request.endpoint\n@bp.get(\"/error\")\ndef error():\nflask.abort(403)\n@bp.errorhandler(403)\ndef forbidden(_: exception):\nreturn \"error\", 403\n@bp2.get(\"/\")\ndef index2():\nreturn flask.request.endpoint\nbp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\napp.register_blueprint(bp, url_prefix=\"/a\")", "bp2 = flask.blueprint(\"bp2\", __name__)\n@bp.get(\"/\")\ndef index():\nreturn flask.request.endpoint\n@bp.get(\"/error\")\ndef error():\nflask.abort(403)\n@bp.errorhandler(403)\ndef forbidden(_: exception):\nreturn \"error\", 403\n@bp2.get(\"/\")\ndef index2():\nreturn flask.request.endpoint\nbp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\napp.register_blueprint(bp, url_prefix=\"/a\")\napp.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\nassert client.get(\"/a/\").data == b\"bp.index\"\nassert client.get(\"/b/\").data == b\"alt.index\"\nassert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\nassert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\nassert client.get(\"/a/error\").data == b\"error\"\nassert client.get(\"/b/error\").data == b\"error\"", "from __future__ import annotations\nfrom http import httpstatus\nfrom werkzeug.exceptions import badrequest\nfrom werkzeug.exceptions import notfound\nfrom flask import flask\napp = flask(__name__)\n@app.errorhandler(400)\n@app.errorhandler(httpstatus.bad_request)\n@app.errorhandler(badrequest)\ndef handle_400(e: badrequest) -> str:\nreturn \"\"\n@app.errorhandler(valueerror)\ndef handle_custom(e: valueerror) -> str:\nreturn \"\"\n@app.errorhandler(valueerror)\ndef handle_accept_base(e: exception) -> str:\nreturn \"\"\n@app.errorhandler(badrequest)\n@app.errorhandler(404)\ndef handle_multiple(e: badrequest | notfound) -> str:\nreturn \"\"", "import pytest\nfrom flaskr.db import get_db\ndef test_index(client, auth):\nresponse = client.get(\"/\")\nassert b\"log in\" in response.data\nassert b\"register\" in response.data\nauth.login()\nresponse = client.get(\"/\")\nassert b\"test title\" in response.data\nassert b\"by test on 2018-01-01\" in response.data\nassert b\"test\\nbody\" in response.data\nassert b'href=\"/1/update\"' in response.data\n@pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\", \"/1/delete\"))\ndef test_login_required(client, path):\nresponse = client.post(path)\nassert response.headers[\"location\"] == \"/auth/login\"\ndef test_author_required(app, client, auth):\nwith app.app_context():\ndb = get_db()\ndb.execute(\"update post set author_id = 2 where id = 1\")\ndb.commit()\nauth.login()\nassert client.post(\"/1/update\").status_code == 403\nassert client.post(\"/1/delete\").status_code == 403\nassert b'href=\"/1/update\"' not in client.get(\"/\").data\n@pytest.mark.parametrize(\"path\", (\"/2/update\", \"/2/delete\"))\ndef test_exists_required(client, auth, path):\nauth.login()\nassert client.post(path).status_code == 404\ndef test_create(client, auth, app):\nauth.login()\nassert client.get(\"/create\").status_code == 200\nclient.post(\"/create\", data={\"title\": \"created\", \"body\": \"\"})\nwith app.app_context():\ndb = get_db()\ncount = db.execute(\"select count(id) from post\").fetchone()[0]\nassert count == 2\ndef test_update(client, auth, app):\nauth.login()\nassert client.get(\"/1/update\").status_code == 200\nclient.post(\"/1/update\", data={\"title\": \"updated\", \"body\": \"\"})\nwith app.app_context():\ndb = get_db()\npost = db.execute(\"select * from post where id = 1\").fetchone()\nassert post[\"title\"] == \"updated\"\n@pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\"))\ndef test_create_update_validate(client, auth, path):\nauth.login()\nresponse = client.post(path, data={\"title\": \"\", \"body\": \"\"})\nassert b\"title is required.\" in response.data\ndef test_delete(client, auth, app):\nauth.login()\nresponse = client.post(\"/1/delete\")\nassert response.headers[\"location\"] == \"/\"\nwith app.app_context():\ndb = get_db()", "assert post[\"title\"] == \"updated\"\n@pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\"))\ndef test_create_update_validate(client, auth, path):\nauth.login()\nresponse = client.post(path, data={\"title\": \"\", \"body\": \"\"})\nassert b\"title is required.\" in response.data\ndef test_delete(client, auth, app):\nauth.login()\nresponse = client.post(\"/1/delete\")\nassert response.headers[\"location\"] == \"/\"\nwith app.app_context():\ndb = get_db()\npost = db.execute(\"select * from post where id = 1\").fetchone()\nassert post is none", "from __future__ import annotations\nimport importlib.util\nimport os\nimport pathlib\nimport sys\nimport typing as t\nfrom collections import defaultdict\nfrom functools import update_wrapper\nfrom jinja2 import baseloader\nfrom jinja2 import filesystemloader\nfrom werkzeug.exceptions import default_exceptions\nfrom werkzeug.exceptions import httpexception\nfrom werkzeug.utils import cached_property\nfrom .. import typing as ft\nfrom ..helpers import get_root_path\nfrom ..templating import _default_template_ctx_processor\nif t.type_checking:\nfrom click import group\n_sentinel = object()\nf = t.typevar(\"f\", bound=t.callable[..., t.any])\nt_after_request = t.typevar(\"t_after_request\", bound=ft.afterrequestcallable[t.any])\nt_before_request = t.typevar(\"t_before_request\", bound=ft.beforerequestcallable)\nt_error_handler = t.typevar(\"t_error_handler\", bound=ft.errorhandlercallable)\nt_teardown = t.typevar(\"t_teardown\", bound=ft.teardowncallable)\nt_template_context_processor = t.typevar(\n\"t_template_context_processor\", bound=ft.templatecontextprocessorcallable\n)\nt_url_defaults = t.typevar(\"t_url_defaults\", bound=ft.urldefaultcallable)\nt_url_value_preprocessor = t.typevar(\n\"t_url_value_preprocessor\", bound=ft.urlvaluepreprocessorcallable\n)\nt_route = t.typevar(\"t_route\", bound=ft.routecallable)\ndef setupmethod(f: f) -> f:\nf_name = f.__name__\ndef wrapper_func(self: scaffold, *args: t.any, **kwargs: t.any) -> t.any:\nself._check_setup_finished(f_name)\nreturn f(self, *args, **kwargs)\nreturn t.cast(f, update_wrapper(wrapper_func, f))\nclass scaffold:\ncli: group\nname: str\n_static_folder: str | none = none\n_static_url_path: str | none = none\ndef __init__(\nself,\nimport_name: str,\nstatic_folder: str | os.pathlike[str] | none = none,\nstatic_url_path: str | none = none,\ntemplate_folder: str | os.pathlike[str] | none = none,\nroot_path: str | none = none,\n):\nself.import_name = import_name\nself.static_folder = static_folder\nself.static_url_path = static_url_path\nself.template_folder = template_folder\nif root_path is none:", "def __init__(\nself,\nimport_name: str,\nstatic_folder: str | os.pathlike[str] | none = none,\nstatic_url_path: str | none = none,\ntemplate_folder: str | os.pathlike[str] | none = none,\nroot_path: str | none = none,\n):\nself.import_name = import_name\nself.static_folder = static_folder\nself.static_url_path = static_url_path\nself.template_folder = template_folder\nif root_path is none:\nroot_path = get_root_path(self.import_name)\nself.root_path = root_path\nself.view_functions: dict[str, ft.routecallable] = {}\nself.error_handler_spec: dict[\nft.apporblueprintkey,\ndict[int | none, dict[type[exception], ft.errorhandlercallable]],\n] = defaultdict(lambda: defaultdict(dict))\nself.before_request_funcs: dict[\nft.apporblueprintkey, list[ft.beforerequestcallable]\n] = defaultdict(list)\nself.after_request_funcs: dict[\nft.apporblueprintkey, list[ft.afterrequestcallable[t.any]]\n] = defaultdict(list)\nself.teardown_request_funcs: dict[\nft.apporblueprintkey, list[ft.teardowncallable]\n] = defaultdict(list)\nself.template_context_processors: dict[\nft.apporblueprintkey, list[ft.templatecontextprocessorcallable]\n] = defaultdict(list, {none: [_default_template_ctx_processor]})\nself.url_value_preprocessors: dict[\nft.apporblueprintkey,\nlist[ft.urlvaluepreprocessorcallable],\n] = defaultdict(list)\nself.url_default_functions: dict[\nft.apporblueprintkey, list[ft.urldefaultcallable]\n] = defaultdict(list)\ndef __repr__(self) -> str:\nreturn f\"<{type(self).__name__} {self.name!r}>\"\ndef _check_setup_finished(self, f_name: str) -> none:\nraise notimplementederror\n@property\ndef static_folder(self) -> str | none:\nif self._static_folder is not none:\nreturn os.path.join(self.root_path, self._static_folder)\nelse:\nreturn none\n@static_folder.setter\ndef static_folder(self, value: str | os.pathlike[str] | none) -> none:\nif value is not none:\nvalue = os.fspath(value).rstrip(r\"\\/\")\nself._static_folder = value\n@property\ndef has_static_folder(self) -> bool:\nreturn self.static_folder is not none\n@property\ndef static_url_path(self) -> str | none:", "return os.path.join(self.root_path, self._static_folder)\nelse:\nreturn none\n@static_folder.setter\ndef static_folder(self, value: str | os.pathlike[str] | none) -> none:\nif value is not none:\nvalue = os.fspath(value).rstrip(r\"\\/\")\nself._static_folder = value\n@property\ndef has_static_folder(self) -> bool:\nreturn self.static_folder is not none\n@property\ndef static_url_path(self) -> str | none:\nif self._static_url_path is not none:\nreturn self._static_url_path\nif self.static_folder is not none:\nbasename = os.path.basename(self.static_folder)\nreturn f\"/{basename}\".rstrip(\"/\")\nreturn none\n@static_url_path.setter\ndef static_url_path(self, value: str | none) -> none:\nif value is not none:\nvalue = value.rstrip(\"/\")\nself._static_url_path = value\n@cached_property\ndef jinja_loader(self) -> baseloader | none:\nif self.template_folder is not none:\nreturn filesystemloader(os.path.join(self.root_path, self.template_folder))\nelse:\nreturn none\ndef _method_route(\nself,\nmethod: str,\nrule: str,\noptions: dict[str, t.any],\n) -> t.callable[[t_route], t_route]:\nif \"methods\" in options:\nraise typeerror(\"use the 'route' decorator to use the 'methods' argument.\")\nreturn self.route(rule, methods=[method], **options)\n@setupmethod\ndef get(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"get\", rule, options)\n@setupmethod\ndef post(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"post\", rule, options)\n@setupmethod\ndef put(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"put\", rule, options)\n@setupmethod\ndef delete(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"delete\", rule, options)\n@setupmethod\ndef patch(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"patch\", rule, options)\n@setupmethod", "return self._method_route(\"put\", rule, options)\n@setupmethod\ndef delete(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"delete\", rule, options)\n@setupmethod\ndef patch(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\nreturn self._method_route(\"patch\", rule, options)\n@setupmethod\ndef route(self, rule: str, **options: t.any) -> t.callable[[t_route], t_route]:\ndef decorator(f: t_route) -> t_route:\nendpoint = options.pop(\"endpoint\", none)\nself.add_url_rule(rule, endpoint, f, **options)\nreturn f\nreturn decorator\n@setupmethod\ndef add_url_rule(\nself,\nrule: str,\nendpoint: str | none = none,\nview_func: ft.routecallable | none = none,\nprovide_automatic_options: bool | none = none,\n**options: t.any,\n) -> none:\nraise notimplementederror\n@setupmethod\ndef endpoint(self, endpoint: str) -> t.callable[[f], f]:\ndef decorator(f: f) -> f:\nself.view_functions[endpoint] = f\nreturn f\nreturn decorator\n@setupmethod\ndef before_request(self, f: t_before_request) -> t_before_request:\nself.before_request_funcs.setdefault(none, []).append(f)\nreturn f\n@setupmethod\ndef after_request(self, f: t_after_request) -> t_after_request:\nself.after_request_funcs.setdefault(none, []).append(f)\nreturn f\n@setupmethod\ndef teardown_request(self, f: t_teardown) -> t_teardown:\nself.teardown_request_funcs.setdefault(none, []).append(f)\nreturn f\n@setupmethod\ndef context_processor(\nself,\nf: t_template_context_processor,\n) -> t_template_context_processor:\nself.template_context_processors[none].append(f)\nreturn f\n@setupmethod\ndef url_value_preprocessor(\nself,\nf: t_url_value_preprocessor,\n) -> t_url_value_preprocessor:\nself.url_value_preprocessors[none].append(f)\nreturn f\n@setupmethod\ndef url_defaults(self, f: t_url_defaults) -> t_url_defaults:\nself.url_default_functions[none].append(f)\nreturn f\n@setupmethod\ndef errorhandler(\nself, code_or_exception: type[exception] | int", "return f\n@setupmethod\ndef url_value_preprocessor(\nself,\nf: t_url_value_preprocessor,\n) -> t_url_value_preprocessor:\nself.url_value_preprocessors[none].append(f)\nreturn f\n@setupmethod\ndef url_defaults(self, f: t_url_defaults) -> t_url_defaults:\nself.url_default_functions[none].append(f)\nreturn f\n@setupmethod\ndef errorhandler(\nself, code_or_exception: type[exception] | int\n) -> t.callable[[t_error_handler], t_error_handler]:\ndef decorator(f: t_error_handler) -> t_error_handler:\nself.register_error_handler(code_or_exception, f)\nreturn f\nreturn decorator\n@setupmethod\ndef register_error_handler(\nself,\ncode_or_exception: type[exception] | int,\nf: ft.errorhandlercallable,\n) -> none:\nexc_class, code = self._get_exc_class_and_code(code_or_exception)\nself.error_handler_spec[none][code][exc_class] = f\n@staticmethod\ndef _get_exc_class_and_code(\nexc_class_or_code: type[exception] | int,\n) -> tuple[type[exception], int | none]:\nexc_class: type[exception]\nif isinstance(exc_class_or_code, int):\ntry:\nexc_class = default_exceptions[exc_class_or_code]\nexcept keyerror:\nraise valueerror(\nf\"'{exc_class_or_code}' is not a recognized http\"\n\" error code. use a subclass of httpexception with\"\n\" that code instead.\"\n) from none\nelse:\nexc_class = exc_class_or_code\nif isinstance(exc_class, exception):\nraise typeerror(\nf\"{exc_class!r} is an instance, not a class. handlers\"\n\" can only be registered for exception classes or http\"\n\" error codes.\"\n)\nif not issubclass(exc_class, exception):\nraise valueerror(\nf\"'{exc_class.__name__}' is not a subclass of exception.\"\n\" handlers can only be registered for exception classes\"\n\" or http error codes.\"\n)\nif issubclass(exc_class, httpexception):\nreturn exc_class, exc_class.code\nelse:\nreturn exc_class, none\ndef _endpoint_from_view_func(view_func: ft.routecallable) -> str:\nassert view_func is not none, \"expected view func if endpoint is not provided.\"\nreturn view_func.__name__\ndef _find_package_path(import_name: str) -> str:\nroot_mod_name, _, _ = import_name.partition(\".\")\ntry:", ")\nif issubclass(exc_class, httpexception):\nreturn exc_class, exc_class.code\nelse:\nreturn exc_class, none\ndef _endpoint_from_view_func(view_func: ft.routecallable) -> str:\nassert view_func is not none, \"expected view func if endpoint is not provided.\"\nreturn view_func.__name__\ndef _find_package_path(import_name: str) -> str:\nroot_mod_name, _, _ = import_name.partition(\".\")\ntry:\nroot_spec = importlib.util.find_spec(root_mod_name)\nif root_spec is none:\nraise valueerror(\"not found\")\nexcept (importerror, valueerror):\nreturn os.getcwd()\nif root_spec.submodule_search_locations:\nif root_spec.origin is none or root_spec.origin == \"namespace\":\npackage_spec = importlib.util.find_spec(import_name)\nif package_spec is not none and package_spec.submodule_search_locations:\npackage_path = pathlib.path(\nos.path.commonpath(package_spec.submodule_search_locations)\n)\nsearch_location = next(\nlocation\nfor location in root_spec.submodule_search_locations\nif package_path.is_relative_to(location)\n)\nelse:\nsearch_location = root_spec.submodule_search_locations[0]\nreturn os.path.dirname(search_location)\nelse:\nreturn os.path.dirname(os.path.dirname(root_spec.origin))\nelse:\nreturn os.path.dirname(root_spec.origin)\ndef find_package(import_name: str) -> tuple[str | none, str]:\npackage_path = _find_package_path(import_name)\npy_prefix = os.path.abspath(sys.prefix)\nif pathlib.purepath(package_path).is_relative_to(py_prefix):\nreturn py_prefix, package_path\nsite_parent, site_folder = os.path.split(package_path)\nif site_folder.lower() == \"site-packages\":\nparent, folder = os.path.split(site_parent)\nif folder.lower() == \"lib\":\nreturn parent, package_path\nif os.path.basename(parent).lower() == \"lib\":\nreturn os.path.dirname(parent), package_path\nreturn site_parent, package_path\nreturn none, package_path", "import os\nimport pytest\nimport flask\ndef test_explicit_instance_paths(modules_tmp_path):\nwith pytest.raises(valueerror, match=\".*must be absolute\"):\nflask.flask(__name__, instance_path=\"instance\")\napp = flask.flask(__name__, instance_path=os.fspath(modules_tmp_path))\nassert app.instance_path == os.fspath(modules_tmp_path)\ndef test_uninstalled_module_paths(modules_tmp_path, purge_module):\n(modules_tmp_path / \"config_module_app.py\").write_text(\n\"import os\\n\"\n\"import flask\\n\"\n\"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n\"app = flask.flask(__name__)\\n\"\n)\npurge_module(\"config_module_app\")\nfrom config_module_app import app\nassert app.instance_path == os.fspath(modules_tmp_path / \"instance\")\ndef test_uninstalled_package_paths(modules_tmp_path, purge_module):\napp = modules_tmp_path / \"config_package_app\"\napp.mkdir()\n(app / \"__init__.py\").write_text(\n\"import os\\n\"\n\"import flask\\n\"\n\"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n\"app = flask.flask(__name__)\\n\"\n)\npurge_module(\"config_package_app\")\nfrom config_package_app import app\nassert app.instance_path == os.fspath(modules_tmp_path / \"instance\")\ndef test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\ndef create_namespace(package):\nproject = tmp_path / f\"project-{package}\"\nmonkeypatch.syspath_prepend(os.fspath(project))\nns = project / \"namespace\" / package\nns.mkdir(parents=true)\n(ns / \"__init__.py\").write_text(\"import flask\\napp = flask.flask(__name__)\\n\")\nreturn project\n_ = create_namespace(\"package1\")\nproject2 = create_namespace(\"package2\")\npurge_module(\"namespace.package2\")\npurge_module(\"namespace\")\nfrom namespace.package2 import app\nassert app.instance_path == os.fspath(project2 / \"instance\")\ndef test_installed_module_paths(\nmodules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n(site_packages / \"site_app.py\").write_text(\n\"import flask\\napp = flask.flask(__name__)\\n\"\n)\npurge_module(\"site_app\")\nfrom site_app import app\nassert app.instance_path == os.fspath(\nmodules_tmp_path / \"var\" / \"site_app-instance\"\n)\ndef test_installed_package_paths(", "def test_installed_module_paths(\nmodules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n(site_packages / \"site_app.py\").write_text(\n\"import flask\\napp = flask.flask(__name__)\\n\"\n)\npurge_module(\"site_app\")\nfrom site_app import app\nassert app.instance_path == os.fspath(\nmodules_tmp_path / \"var\" / \"site_app-instance\"\n)\ndef test_installed_package_paths(\nmodules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\ninstalled_path = modules_tmp_path / \"path\"\ninstalled_path.mkdir()\nmonkeypatch.syspath_prepend(installed_path)\napp = installed_path / \"installed_package\"\napp.mkdir()\n(app / \"__init__.py\").write_text(\"import flask\\napp = flask.flask(__name__)\\n\")\npurge_module(\"installed_package\")\nfrom installed_package import app\nassert app.instance_path == os.fspath(\nmodules_tmp_path / \"var\" / \"installed_package-instance\"\n)\ndef test_prefix_package_paths(\nmodules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\napp = site_packages / \"site_package\"\napp.mkdir()\n(app / \"__init__.py\").write_text(\"import flask\\napp = flask.flask(__name__)\\n\")\npurge_module(\"site_package\")\nimport site_package\nassert site_package.app.instance_path == os.fspath(\nmodules_tmp_path / \"var\" / \"site_package-instance\"\n)", "from flask import flask\ntestapp = flask(\"testapp\")", "from . import json as json\nfrom .app import flask as flask\nfrom .blueprints import blueprint as blueprint\nfrom .config import config as config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import request as request\nfrom .wrappers import response as response", "import pytest\nfrom js_example import app\n@pytest.fixture(name=\"app\")\ndef fixture_app():\napp.testing = true\nyield app\napp.testing = false\n@pytest.fixture\ndef client(app):\nreturn app.test_client()", "from flask import flask\ndef create_app():\nreturn flask(\"app\")\ndef create_app2(foo, bar):\nreturn flask(\"_\".join([\"app2\", foo, bar]))\ndef no_app():\npass", "from __future__ import annotations\nimport typing as t\nfrom jinja2.loaders import baseloader\nfrom werkzeug.routing import requestredirect\nfrom .blueprints import blueprint\nfrom .globals import request_ctx\nfrom .sansio.app import app\nif t.type_checking:\nfrom .sansio.scaffold import scaffold\nfrom .wrappers import request\nclass unexpectedunicodeerror(assertionerror, unicodeerror):\nclass debugfileskeyerror(keyerror, assertionerror):\ndef __init__(self, request: request, key: str) -> none:\nform_matches = request.form.getlist(key)\nbuf = [\nf\"you tried to access the file {key!r} in the request.files\"\n\" dictionary but it does not exist. the mimetype for the\"\nf\" request is {request.mimetype!r} instead of\"\n\" 'multipart/form-data' which means that no file contents\"\n\" were transmitted. to fix this error you should provide\"\n' enctype=\"multipart/form-data\" in your form.'\n]\nif form_matches:\nnames = \", \".join(repr(x) for x in form_matches)\nbuf.append(\n\"\\n\\nthe browser instead transmitted some file names. \"\nf\"this was submitted: {names}\"\n)\nself.msg = \"\".join(buf)\ndef __str__(self) -> str:\nreturn self.msg\nclass formdataroutingredirect(assertionerror):\ndef __init__(self, request: request) -> none:\nexc = request.routing_exception\nassert isinstance(exc, requestredirect)\nbuf = [\nf\"a request was sent to '{request.url}', but routing issued\"\nf\" a redirect to the canonical url '{exc.new_url}'.\"\n]\nif f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\nbuf.append(\n\" the url was defined with a trailing slash. flask\"\n\" will redirect to the url with a trailing slash if it\"\n\" was accessed without one.\"\n)\nbuf.append(\n\" send requests to the canonical url, or use 307 or 308 for\"\n\" routing redirects. otherwise, browsers will drop form\"\n\" data.\\n\\n\"\n\"this exception is only raised in debug mode.\"\n)\nsuper().__init__(\"\".join(buf))\ndef attach_enctype_error_multidict(request: request) -> none:\noldcls = request.files.__class__\nclass newcls(oldcls):\ndef __getitem__(self, key: str) -> t.any:\ntry:\nreturn super().__getitem__(key)\nexcept keyerror as e:", "\" routing redirects. otherwise, browsers will drop form\"\n\" data.\\n\\n\"\n\"this exception is only raised in debug mode.\"\n)\nsuper().__init__(\"\".join(buf))\ndef attach_enctype_error_multidict(request: request) -> none:\noldcls = request.files.__class__\nclass newcls(oldcls):\ndef __getitem__(self, key: str) -> t.any:\ntry:\nreturn super().__getitem__(key)\nexcept keyerror as e:\nif key not in request.form:\nraise\nraise debugfileskeyerror(request, key).with_traceback(\ne.__traceback__\n) from none\nnewcls.__name__ = oldcls.__name__\nnewcls.__module__ = oldcls.__module__\nrequest.files.__class__ = newcls\ndef _dump_loader_info(loader: baseloader) -> t.iterator[str]:\nyield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\nfor key, value in sorted(loader.__dict__.items()):\nif key.startswith(\"_\"):\ncontinue\nif isinstance(value, (tuple, list)):\nif not all(isinstance(x, str) for x in value):\ncontinue\nyield f\"{key}:\"\nfor item in value:\nyield f\"  - {item}\"\ncontinue\nelif not isinstance(value, (str, int, float, bool)):\ncontinue\nyield f\"{key}: {value!r}\"\ndef explain_template_loading_attempts(\napp: app,\ntemplate: str,\nattempts: list[\ntuple[\nbaseloader,\nscaffold,\ntuple[str, str | none, t.callable[[], bool] | none] | none,\n]\n],\n) -> none:\ninfo = [f\"locating template {template!r}:\"]\ntotal_found = 0\nblueprint = none\nif request_ctx and request_ctx.request.blueprint is not none:\nblueprint = request_ctx.request.blueprint\nfor idx, (loader, srcobj, triple) in enumerate(attempts):\nif isinstance(srcobj, app):\nsrc_info = f\"application {srcobj.import_name!r}\"\nelif isinstance(srcobj, blueprint):\nsrc_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\nelse:\nsrc_info = repr(srcobj)\ninfo.append(f\"{idx + 1:5}: trying loader of {src_info}\")\nfor line in _dump_loader_info(loader):\ninfo.append(f\"       {line}\")\nif triple is none:\ndetail = \"no match\"\nelse:", "src_info = f\"application {srcobj.import_name!r}\"\nelif isinstance(srcobj, blueprint):\nsrc_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\nelse:\nsrc_info = repr(srcobj)\ninfo.append(f\"{idx + 1:5}: trying loader of {src_info}\")\nfor line in _dump_loader_info(loader):\ninfo.append(f\"       {line}\")\nif triple is none:\ndetail = \"no match\"\nelse:\ndetail = f\"found ({triple[1] or '<string>'!r})\"\ntotal_found += 1\ninfo.append(f\"       -> {detail}\")\nseems_fishy = false\nif total_found == 0:\ninfo.append(\"error: the template could not be found.\")\nseems_fishy = true\nelif total_found > 1:\ninfo.append(\"warning: multiple loaders returned a match for the template.\")\nseems_fishy = true\nif blueprint is not none and seems_fishy:\ninfo.append(\n\"  the template was looked up from an endpoint that belongs\"\nf\" to the blueprint {blueprint!r}.\"\n)\ninfo.append(\"  maybe you did not place a template in the right folder?\")\ninfo.append(\"  see https:\napp.logger.info(\"\\n\".join(info))", "from celery import celery\nfrom celery import task\nfrom flask import flask\nfrom flask import render_template\ndef create_app() -> flask:\napp = flask(__name__)\napp.config.from_mapping(\ncelery=dict(\nbroker_url=\"redis:\nresult_backend=\"redis:\ntask_ignore_result=true,\n),\n)\napp.config.from_prefixed_env()\ncelery_init_app(app)\n@app.route(\"/\")\ndef index() -> str:\nreturn render_template(\"index.html\")\nfrom . import views\napp.register_blueprint(views.bp)\nreturn app\ndef celery_init_app(app: flask) -> celery:\nclass flasktask(task):\ndef __call__(self, *args: object, **kwargs: object) -> object:\nwith app.app_context():\nreturn self.run(*args, **kwargs)\ncelery_app = celery(app.name, task_cls=flasktask)\ncelery_app.config_from_object(app.config[\"celery\"])\ncelery_app.set_default()\napp.extensions[\"celery\"] = celery_app\nreturn celery_app", "from task_app import create_app\nflask_app = create_app()\ncelery_app = flask_app.extensions[\"celery\"]", "from flask import module\nmod = module(__name__, \"foo\", subdomain=\"foo\")", "import flask\nfrom flask.globals import request_ctx\nfrom flask.sessions import sessioninterface\ndef test_open_session_with_endpoint():\nclass mysessioninterface(sessioninterface):\ndef save_session(self, app, session, response):\npass\ndef open_session(self, app, request):\nrequest_ctx.match_request()\nassert request.endpoint is not none\napp = flask.flask(__name__)\napp.session_interface = mysessioninterface()\n@app.get(\"/\")\ndef index():\nreturn \"hello, world!\"\nresponse = app.test_client().get(\"/\")\nassert response.status_code == 200", "from __future__ import annotations\nfrom flask import flask\nfrom flask import request\nfrom flask import request\nfrom flask.testing import flaskclient\ndef test_max_content_length(app: flask, client: flaskclient) -> none:\napp.config[\"max_content_length\"] = 50\n@app.post(\"/\")\ndef index():\nrequest.form[\"myfile\"]\nassertionerror()\n@app.errorhandler(413)\ndef catcher(error):\nreturn \"42\"\nrv = client.post(\"/\", data={\"myfile\": \"foo\" * 50})\nassert rv.data == b\"42\"\ndef test_limit_config(app: flask):\napp.config[\"max_content_length\"] = 100\napp.config[\"max_form_memory_size\"] = 50\napp.config[\"max_form_parts\"] = 3\nr = request({})\nassert r.max_content_length is none\nassert r.max_form_memory_size == 500_000\nassert r.max_form_parts == 1_000\nwith app.app_context():\nassert r.max_content_length == 100\nassert r.max_form_memory_size == 50\nassert r.max_form_parts == 3\nr.max_content_length = 90\nr.max_form_memory_size = 30\nr.max_form_parts = 4\nassert r.max_content_length == 90\nassert r.max_form_memory_size == 30\nassert r.max_form_parts == 4\nwith app.app_context():\nassert r.max_content_length == 90\nassert r.max_form_memory_size == 30\nassert r.max_form_parts == 4\ndef test_trusted_hosts_config(app: flask) -> none:\napp.config[\"trusted_hosts\"] = [\"example.test\", \".other.test\"]\n@app.get(\"/\")\ndef index() -> str:\nreturn \"\"\nclient = app.test_client()\nr = client.get(base_url=\"http:\nassert r.status_code == 200\nr = client.get(base_url=\"http:\nassert r.status_code == 200\nr = client.get(base_url=\"http:\nassert r.status_code == 400", "import pytest\nfrom werkzeug.exceptions import forbidden\nfrom werkzeug.exceptions import httpexception\nfrom werkzeug.exceptions import internalservererror\nfrom werkzeug.exceptions import notfound\nimport flask\ndef test_error_handler_no_match(app, client):\nclass customexception(exception):\npass\n@app.errorhandler(customexception)\ndef custom_exception_handler(e):\nassert isinstance(e, customexception)\nreturn \"custom\"\nwith pytest.raises(typeerror) as exc_info:\napp.register_error_handler(customexception(), none)\nassert \"customexception() is an instance, not a class.\" in str(exc_info.value)\nwith pytest.raises(valueerror) as exc_info:\napp.register_error_handler(list, none)\nassert \"'list' is not a subclass of exception.\" in str(exc_info.value)\n@app.errorhandler(500)\ndef handle_500(e):\nassert isinstance(e, internalservererror)\nif e.original_exception is not none:\nreturn f\"wrapped {type(e.original_exception).__name__}\"\nreturn \"direct\"\nwith pytest.raises(valueerror) as exc_info:\napp.register_error_handler(999, none)\nassert \"use a subclass of httpexception\" in str(exc_info.value)\n@app.route(\"/custom\")\ndef custom_test():\nraise customexception()\n@app.route(\"/keyerror\")\ndef key_error():\nraise keyerror()\n@app.route(\"/abort\")\ndef do_abort():\nflask.abort(500)\napp.testing = false\nassert client.get(\"/custom\").data == b\"custom\"\nassert client.get(\"/keyerror\").data == b\"wrapped keyerror\"\nassert client.get(\"/abort\").data == b\"direct\"\ndef test_error_handler_subclass(app):\nclass parentexception(exception):\npass\nclass childexceptionunregistered(parentexception):\npass\nclass childexceptionregistered(parentexception):\npass\n@app.errorhandler(parentexception)\ndef parent_exception_handler(e):\nassert isinstance(e, parentexception)\nreturn \"parent\"\n@app.errorhandler(childexceptionregistered)\ndef child_exception_handler(e):\nassert isinstance(e, childexceptionregistered)\nreturn \"child-registered\"\n@app.route(\"/parent\")\ndef parent_test():\nraise parentexception()\n@app.route(\"/child-unregistered\")\ndef unregistered_test():\nraise childexceptionunregistered()\n@app.route(\"/child-registered\")\ndef registered_test():\nraise childexceptionregistered()\nc = app.test_client()\nassert c.get(\"/parent\").data == b\"parent\"\nassert c.get(\"/child-unregistered\").data == b\"parent\"\nassert c.get(\"/child-registered\").data == b\"child-registered\"\ndef test_error_handler_http_subclass(app):", "def parent_test():\nraise parentexception()\n@app.route(\"/child-unregistered\")\ndef unregistered_test():\nraise childexceptionunregistered()\n@app.route(\"/child-registered\")\ndef registered_test():\nraise childexceptionregistered()\nc = app.test_client()\nassert c.get(\"/parent\").data == b\"parent\"\nassert c.get(\"/child-unregistered\").data == b\"parent\"\nassert c.get(\"/child-registered\").data == b\"child-registered\"\ndef test_error_handler_http_subclass(app):\nclass forbiddensubclassregistered(forbidden):\npass\nclass forbiddensubclassunregistered(forbidden):\npass\n@app.errorhandler(403)\ndef code_exception_handler(e):\nassert isinstance(e, forbidden)\nreturn \"forbidden\"\n@app.errorhandler(forbiddensubclassregistered)\ndef subclass_exception_handler(e):\nassert isinstance(e, forbiddensubclassregistered)\nreturn \"forbidden-registered\"\n@app.route(\"/forbidden\")\ndef forbidden_test():\nraise forbidden()\n@app.route(\"/forbidden-registered\")\ndef registered_test():\nraise forbiddensubclassregistered()\n@app.route(\"/forbidden-unregistered\")\ndef unregistered_test():\nraise forbiddensubclassunregistered()\nc = app.test_client()\nassert c.get(\"/forbidden\").data == b\"forbidden\"\nassert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\nassert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"\ndef test_error_handler_blueprint(app):\nbp = flask.blueprint(\"bp\", __name__)\n@bp.errorhandler(500)\ndef bp_exception_handler(e):\nreturn \"bp-error\"\n@bp.route(\"/error\")\ndef bp_test():\nraise internalservererror()\n@app.errorhandler(500)\ndef app_exception_handler(e):\nreturn \"app-error\"\n@app.route(\"/error\")\ndef app_test():\nraise internalservererror()\napp.register_blueprint(bp, url_prefix=\"/bp\")\nc = app.test_client()\nassert c.get(\"/error\").data == b\"app-error\"\nassert c.get(\"/bp/error\").data == b\"bp-error\"\ndef test_default_error_handler():\nbp = flask.blueprint(\"bp\", __name__)\n@bp.errorhandler(httpexception)\ndef bp_exception_handler(e):\nassert isinstance(e, httpexception)\nassert isinstance(e, notfound)\nreturn \"bp-default\"\n@bp.errorhandler(forbidden)\ndef bp_forbidden_handler(e):\nassert isinstance(e, forbidden)\nreturn \"bp-forbidden\"\n@bp.route(\"/undefined\")\ndef bp_registered_test():\nraise notfound()", "def test_default_error_handler():\nbp = flask.blueprint(\"bp\", __name__)\n@bp.errorhandler(httpexception)\ndef bp_exception_handler(e):\nassert isinstance(e, httpexception)\nassert isinstance(e, notfound)\nreturn \"bp-default\"\n@bp.errorhandler(forbidden)\ndef bp_forbidden_handler(e):\nassert isinstance(e, forbidden)\nreturn \"bp-forbidden\"\n@bp.route(\"/undefined\")\ndef bp_registered_test():\nraise notfound()\n@bp.route(\"/forbidden\")\ndef bp_forbidden_test():\nraise forbidden()\napp = flask.flask(__name__)\n@app.errorhandler(httpexception)\ndef catchall_exception_handler(e):\nassert isinstance(e, httpexception)\nassert isinstance(e, notfound)\nreturn \"default\"\n@app.errorhandler(forbidden)\ndef catchall_forbidden_handler(e):\nassert isinstance(e, forbidden)\nreturn \"forbidden\"\n@app.route(\"/forbidden\")\ndef forbidden():\nraise forbidden()\n@app.route(\"/slash/\")\ndef slash():\nreturn \"slash\"\napp.register_blueprint(bp, url_prefix=\"/bp\")\nc = app.test_client()\nassert c.get(\"/bp/undefined\").data == b\"bp-default\"\nassert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\nassert c.get(\"/undefined\").data == b\"default\"\nassert c.get(\"/forbidden\").data == b\"forbidden\"\nassert c.get(\"/slash\", follow_redirects=true).data == b\"slash\"\nclass testgenerichandlers:\nclass custom(exception):\npass\n@pytest.fixture()\ndef app(self, app):\n@app.route(\"/custom\")\ndef do_custom():\nraise self.custom()\n@app.route(\"/error\")\ndef do_error():\nraise keyerror()\n@app.route(\"/abort\")\ndef do_abort():\nflask.abort(500)\n@app.route(\"/raise\")\ndef do_raise():\nraise internalservererror()\napp.config[\"propagate_exceptions\"] = false\nreturn app\ndef report_error(self, e):\noriginal = getattr(e, \"original_exception\", none)\nif original is not none:\nreturn f\"wrapped {type(original).__name__}\"\nreturn f\"direct {type(e).__name__}\"\n@pytest.mark.parametrize(\"to_handle\", (internalservererror, 500))\ndef test_handle_class_or_code(self, app, client, to_handle):\n@app.errorhandler(to_handle)\ndef handle_500(e):\nassert isinstance(e, internalservererror)\nreturn self.report_error(e)\nassert client.get(\"/custom\").data == b\"wrapped custom\"\nassert client.get(\"/error\").data == b\"wrapped keyerror\"", "return f\"direct {type(e).__name__}\"\n@pytest.mark.parametrize(\"to_handle\", (internalservererror, 500))\ndef test_handle_class_or_code(self, app, client, to_handle):\n@app.errorhandler(to_handle)\ndef handle_500(e):\nassert isinstance(e, internalservererror)\nreturn self.report_error(e)\nassert client.get(\"/custom\").data == b\"wrapped custom\"\nassert client.get(\"/error\").data == b\"wrapped keyerror\"\nassert client.get(\"/abort\").data == b\"direct internalservererror\"\nassert client.get(\"/raise\").data == b\"direct internalservererror\"\ndef test_handle_generic_http(self, app, client):\n@app.errorhandler(httpexception)\ndef handle_http(e):\nassert isinstance(e, httpexception)\nreturn str(e.code)\nassert client.get(\"/error\").data == b\"500\"\nassert client.get(\"/abort\").data == b\"500\"\nassert client.get(\"/not-found\").data == b\"404\"\ndef test_handle_generic(self, app, client):\n@app.errorhandler(exception)\ndef handle_exception(e):\nreturn self.report_error(e)\nassert client.get(\"/custom\").data == b\"direct custom\"\nassert client.get(\"/error\").data == b\"direct keyerror\"\nassert client.get(\"/abort\").data == b\"direct internalservererror\"\nassert client.get(\"/not-found\").data == b\"direct notfound\"", "import importlib.metadata\nimport os\nimport platform\nimport ssl\nimport sys\nimport types\nfrom functools import partial\nfrom pathlib import path\nimport click\nimport pytest\nfrom _pytest.monkeypatch import notset\nfrom click.testing import clirunner\nfrom flask import blueprint\nfrom flask import current_app\nfrom flask import flask\nfrom flask.cli import appgroup\nfrom flask.cli import find_best_app\nfrom flask.cli import flaskgroup\nfrom flask.cli import get_version\nfrom flask.cli import load_dotenv\nfrom flask.cli import locate_app\nfrom flask.cli import noappexception\nfrom flask.cli import prepare_import\nfrom flask.cli import run_command\nfrom flask.cli import scriptinfo\nfrom flask.cli import with_appcontext\ncwd = path.cwd()\ntest_path = (path(__file__) / \"..\" / \"test_apps\").resolve()\n@pytest.fixture\ndef runner():\nreturn clirunner()\ndef test_cli_name(test_apps):\nfrom cliapp.app import testapp\nassert testapp.cli.name == testapp.name\ndef test_find_best_app(test_apps):\nclass module:\napp = flask(\"appname\")\nassert find_best_app(module) == module.app\nclass module:\napplication = flask(\"appname\")\nassert find_best_app(module) == module.application\nclass module:\nmyapp = flask(\"appname\")\nassert find_best_app(module) == module.myapp\nclass module:\n@staticmethod\ndef create_app():\nreturn flask(\"appname\")\napp = find_best_app(module)\nassert isinstance(app, flask)\nassert app.name == \"appname\"\nclass module:\n@staticmethod\ndef create_app(**kwargs):\nreturn flask(\"appname\")\napp = find_best_app(module)\nassert isinstance(app, flask)\nassert app.name == \"appname\"\nclass module:\n@staticmethod\ndef make_app():\nreturn flask(\"appname\")\napp = find_best_app(module)\nassert isinstance(app, flask)\nassert app.name == \"appname\"\nclass module:\nmyapp = flask(\"appname1\")\n@staticmethod\ndef create_app():\nreturn flask(\"appname2\")\nassert find_best_app(module) == module.myapp\nclass module:\nmyapp = flask(\"appname1\")\n@staticmethod\ndef create_app():\nreturn flask(\"appname2\")\nassert find_best_app(module) == module.myapp\nclass module:\npass\npytest.raises(noappexception, find_best_app, module)\nclass module:\nmyapp1 = flask(\"appname1\")\nmyapp2 = flask(\"appname2\")", "def create_app():\nreturn flask(\"appname2\")\nassert find_best_app(module) == module.myapp\nclass module:\nmyapp = flask(\"appname1\")\n@staticmethod\ndef create_app():\nreturn flask(\"appname2\")\nassert find_best_app(module) == module.myapp\nclass module:\npass\npytest.raises(noappexception, find_best_app, module)\nclass module:\nmyapp1 = flask(\"appname1\")\nmyapp2 = flask(\"appname2\")\npytest.raises(noappexception, find_best_app, module)\nclass module:\n@staticmethod\ndef create_app(foo, bar):\nreturn flask(\"appname2\")\npytest.raises(noappexception, find_best_app, module)\nclass module:\n@staticmethod\ndef create_app():\nraise typeerror(\"bad bad factory!\")\npytest.raises(typeerror, find_best_app, module)\n@pytest.mark.parametrize(\n\"value,path,result\",\n(\n(\"test\", cwd, \"test\"),\n(\"test.py\", cwd, \"test\"),\n(\"a/test\", cwd / \"a\", \"test\"),\n(\"test/__init__.py\", cwd, \"test\"),\n(\"test/__init__\", cwd, \"test\"),\n(\ntest_path / \"cliapp\" / \"inner1\" / \"__init__\",\ntest_path,\n\"cliapp.inner1\",\n),\n(\ntest_path / \"cliapp\" / \"inner1\" / \"inner2\",\ntest_path,\n\"cliapp.inner1.inner2\",\n),\n(\"test.a.b\", cwd, \"test.a.b\"),\n(test_path / \"cliapp.app\", test_path, \"cliapp.app\"),\n(test_path / \"cliapp\" / \"message.txt\", test_path, \"cliapp.message.txt\"),\n),\n)\ndef test_prepare_import(request, value, path, result):\noriginal_path = sys.path[:]\ndef reset_path():\nsys.path[:] = original_path\nrequest.addfinalizer(reset_path)\nassert prepare_import(value) == result\nassert sys.path[0] == str(path)\n@pytest.mark.parametrize(\n\"iname,aname,result\",\n(\n(\"cliapp.app\", none, \"testapp\"),\n(\"cliapp.app\", \"testapp\", \"testapp\"),\n(\"cliapp.factory\", none, \"app\"),\n(\"cliapp.factory\", \"create_app\", \"app\"),\n(\"cliapp.factory\", \"create_app()\", \"app\"),\n(\"cliapp.factory\", 'create_app2(\"foo\", \"bar\")', \"app2_foo_bar\"),", "@pytest.mark.parametrize(\n\"iname,aname,result\",\n(\n(\"cliapp.app\", none, \"testapp\"),\n(\"cliapp.app\", \"testapp\", \"testapp\"),\n(\"cliapp.factory\", none, \"app\"),\n(\"cliapp.factory\", \"create_app\", \"app\"),\n(\"cliapp.factory\", \"create_app()\", \"app\"),\n(\"cliapp.factory\", 'create_app2(\"foo\", \"bar\")', \"app2_foo_bar\"),\n(\"cliapp.factory\", 'create_app2(\"foo\", \"bar\", )', \"app2_foo_bar\"),\n(\"cliapp.factory\", \" create_app () \", \"app\"),\n),\n)\ndef test_locate_app(test_apps, iname, aname, result):\nassert locate_app(iname, aname).name == result\n@pytest.mark.parametrize(\n\"iname,aname\",\n(\n(\"notanapp.py\", none),\n(\"cliapp/app\", none),\n(\"cliapp.app\", \"notanapp\"),\n(\"cliapp.factory\", 'create_app2(\"foo\")'),\n(\"cliapp.factory\", \"create_app(\"),\n(\"cliapp.factory\", \"no_app\"),\n(\"cliapp.importerrorapp\", none),\n(\"cliapp.message.txt\", none),\n),\n)\ndef test_locate_app_raises(test_apps, iname, aname):\nwith pytest.raises(noappexception):\nlocate_app(iname, aname)\ndef test_locate_app_suppress_raise(test_apps):\napp = locate_app(\"notanapp.py\", none, raise_if_not_found=false)\nassert app is none\nwith pytest.raises(noappexception):\nlocate_app(\"cliapp.importerrorapp\", none, raise_if_not_found=false)\ndef test_get_version(test_apps, capsys):\nclass mockctx:\nresilient_parsing = false\ncolor = none\ndef exit(self):\nreturn\nctx = mockctx()\nget_version(ctx, none, \"test\")\nout, err = capsys.readouterr()\nassert f\"python {platform.python_version()}\" in out\nassert f\"flask {importlib.metadata.version('flask')}\" in out\nassert f\"werkzeug {importlib.metadata.version('werkzeug')}\" in out\ndef test_scriptinfo(test_apps, monkeypatch):\nobj = scriptinfo(app_import_path=\"cliapp.app:testapp\")\napp = obj.load_app()\nassert app.name == \"testapp\"\nassert obj.load_app() is app\ncli_app_path = str(test_path / \"cliapp\" / \"app.py\")", "assert f\"flask {importlib.metadata.version('flask')}\" in out\nassert f\"werkzeug {importlib.metadata.version('werkzeug')}\" in out\ndef test_scriptinfo(test_apps, monkeypatch):\nobj = scriptinfo(app_import_path=\"cliapp.app:testapp\")\napp = obj.load_app()\nassert app.name == \"testapp\"\nassert obj.load_app() is app\ncli_app_path = str(test_path / \"cliapp\" / \"app.py\")\nobj = scriptinfo(app_import_path=cli_app_path)\napp = obj.load_app()\nassert app.name == \"testapp\"\nassert obj.load_app() is app\nobj = scriptinfo(app_import_path=f\"{cli_app_path}:testapp\")\napp = obj.load_app()\nassert app.name == \"testapp\"\nassert obj.load_app() is app\ndef create_app():\nreturn flask(\"createapp\")\nobj = scriptinfo(create_app=create_app)\napp = obj.load_app()\nassert app.name == \"createapp\"\nassert obj.load_app() is app\nobj = scriptinfo()\npytest.raises(noappexception, obj.load_app)\nmonkeypatch.chdir(test_path / \"helloworld\")\nobj = scriptinfo()\napp = obj.load_app()\nassert app.name == \"hello\"\nmonkeypatch.chdir(test_path / \"cliapp\")\nobj = scriptinfo()\napp = obj.load_app()\nassert app.name == \"testapp\"\ndef test_app_cli_has_app_context(app, runner):\ndef _param_cb(ctx, param, value):\nreturn bool(current_app)\n@app.cli.command()\n@click.argument(\"value\", callback=_param_cb)\ndef check(value):\napp = click.get_current_context().obj.load_app()\nsame_app = current_app._get_current_object() is app\nreturn same_app, value\ncli = flaskgroup(create_app=lambda: app)\nresult = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=false)\nassert result.return_value == (true, true)\ndef test_with_appcontext(runner):\n@click.command()\n@with_appcontext\ndef testcmd():\nclick.echo(current_app.name)\nobj = scriptinfo(create_app=lambda: flask(\"testapp\"))\nresult = runner.invoke(testcmd, obj=obj)\nassert result.exit_code == 0\nassert result.output == \"testapp\\n\"\ndef test_appgroup_app_context(runner):\n@click.group(cls=appgroup)\ndef cli():\npass\n@cli.command()\ndef test():\nclick.echo(current_app.name)\n@cli.group()\ndef subgroup():\npass\n@subgroup.command()", "def testcmd():\nclick.echo(current_app.name)\nobj = scriptinfo(create_app=lambda: flask(\"testapp\"))\nresult = runner.invoke(testcmd, obj=obj)\nassert result.exit_code == 0\nassert result.output == \"testapp\\n\"\ndef test_appgroup_app_context(runner):\n@click.group(cls=appgroup)\ndef cli():\npass\n@cli.command()\ndef test():\nclick.echo(current_app.name)\n@cli.group()\ndef subgroup():\npass\n@subgroup.command()\ndef test2():\nclick.echo(current_app.name)\nobj = scriptinfo(create_app=lambda: flask(\"testappgroup\"))\nresult = runner.invoke(cli, [\"test\"], obj=obj)\nassert result.exit_code == 0\nassert result.output == \"testappgroup\\n\"\nresult = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\nassert result.exit_code == 0\nassert result.output == \"testappgroup\\n\"\ndef test_flaskgroup_app_context(runner):\ndef create_app():\nreturn flask(\"flaskgroup\")\n@click.group(cls=flaskgroup, create_app=create_app)\ndef cli(**params):\npass\n@cli.command()\ndef test():\nclick.echo(current_app.name)\nresult = runner.invoke(cli, [\"test\"])\nassert result.exit_code == 0\nassert result.output == \"flaskgroup\\n\"\n@pytest.mark.parametrize(\"set_debug_flag\", (true, false))\ndef test_flaskgroup_debug(runner, set_debug_flag):\ndef create_app():\napp = flask(\"flaskgroup\")\napp.debug = true\nreturn app\n@click.group(cls=flaskgroup, create_app=create_app, set_debug_flag=set_debug_flag)\ndef cli(**params):\npass\n@cli.command()\ndef test():\nclick.echo(str(current_app.debug))\nresult = runner.invoke(cli, [\"test\"])\nassert result.exit_code == 0\nassert result.output == f\"{not set_debug_flag}\\n\"\ndef test_flaskgroup_nested(app, runner):\ncli = click.group(\"cli\")\nflask_group = flaskgroup(name=\"flask\", create_app=lambda: app)\ncli.add_command(flask_group)\n@flask_group.command()\ndef show():\nclick.echo(current_app.name)\nresult = runner.invoke(cli, [\"flask\", \"show\"])\nassert result.output == \"flask_test\\n\"\ndef test_no_command_echo_loading_error():\nfrom flask.cli import cli\ntry:\nrunner = clirunner(mix_stderr=false)\nexcept (deprecationwarning, typeerror):\nrunner = clirunner()", "cli.add_command(flask_group)\n@flask_group.command()\ndef show():\nclick.echo(current_app.name)\nresult = runner.invoke(cli, [\"flask\", \"show\"])\nassert result.output == \"flask_test\\n\"\ndef test_no_command_echo_loading_error():\nfrom flask.cli import cli\ntry:\nrunner = clirunner(mix_stderr=false)\nexcept (deprecationwarning, typeerror):\nrunner = clirunner()\nresult = runner.invoke(cli, [\"missing\"])\nassert result.exit_code == 2\nassert \"flask_app\" in result.stderr\nassert \"usage:\" in result.stderr\ndef test_help_echo_loading_error():\nfrom flask.cli import cli\ntry:\nrunner = clirunner(mix_stderr=false)\nexcept (deprecationwarning, typeerror):\nrunner = clirunner()\nresult = runner.invoke(cli, [\"--help\"])\nassert result.exit_code == 0\nassert \"flask_app\" in result.stderr\nassert \"usage:\" in result.stdout\ndef test_help_echo_exception():\ndef create_app():\nraise exception(\"oh no\")\ncli = flaskgroup(create_app=create_app)\ntry:\nrunner = clirunner(mix_stderr=false)\nexcept (deprecationwarning, typeerror):\nrunner = clirunner()\nresult = runner.invoke(cli, [\"--help\"])\nassert result.exit_code == 0\nassert \"exception: oh no\" in result.stderr\nassert \"usage:\" in result.stdout\nclass testroutes:\n@pytest.fixture\ndef app(self):\napp = flask(__name__)\napp.add_url_rule(\n\"/get_post/<int:x>/<int:y>\",\nmethods=[\"get\", \"post\"],\nendpoint=\"yyy_get_post\",\n)\napp.add_url_rule(\"/zzz_post\", methods=[\"post\"], endpoint=\"aaa_post\")\nreturn app\n@pytest.fixture\ndef invoke(self, app, runner):\ncli = flaskgroup(create_app=lambda: app)\nreturn partial(runner.invoke, cli)\ndef expect_order(self, order, output):\nfor expect, line in zip(order, output.splitlines()[2:]):\nassert line[: len(expect)] == expect\ndef test_simple(self, invoke):\nresult = invoke([\"routes\"])\nassert result.exit_code == 0\nself.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\ndef test_sort(self, app, invoke):\ndefault_output = invoke([\"routes\"]).output\nendpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\nassert default_output == endpoint_output\nself.expect_order(\n[\"static\", \"yyy_get_post\", \"aaa_post\"],", "def test_simple(self, invoke):\nresult = invoke([\"routes\"])\nassert result.exit_code == 0\nself.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\ndef test_sort(self, app, invoke):\ndefault_output = invoke([\"routes\"]).output\nendpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\nassert default_output == endpoint_output\nself.expect_order(\n[\"static\", \"yyy_get_post\", \"aaa_post\"],\ninvoke([\"routes\", \"-s\", \"methods\"]).output,\n)\nself.expect_order(\n[\"yyy_get_post\", \"static\", \"aaa_post\"],\ninvoke([\"routes\", \"-s\", \"rule\"]).output,\n)\nmatch_order = [r.endpoint for r in app.url_map.iter_rules()]\nself.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)\ndef test_all_methods(self, invoke):\noutput = invoke([\"routes\"]).output\nassert \"get, head, options, post\" not in output\noutput = invoke([\"routes\", \"--all-methods\"]).output\nassert \"get, head, options, post\" in output\ndef test_no_routes(self, runner):\napp = flask(__name__, static_folder=none)\ncli = flaskgroup(create_app=lambda: app)\nresult = runner.invoke(cli, [\"routes\"])\nassert result.exit_code == 0\nassert \"no routes were registered.\" in result.output\ndef test_subdomain(self, runner):\napp = flask(__name__, static_folder=none)\napp.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\napp.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\ncli = flaskgroup(create_app=lambda: app)\nresult = runner.invoke(cli, [\"routes\"])\nassert result.exit_code == 0\nassert \"subdomain\" in result.output\ndef test_host(self, runner):\napp = flask(__name__, static_folder=none, host_matching=true)\napp.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\napp.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\ncli = flaskgroup(create_app=lambda: app)\nresult = runner.invoke(cli, [\"routes\"])\nassert result.exit_code == 0\nassert \"host\" in result.output\ndef dotenv_not_available():\ntry:\nimport dotenv\nexcept importerror:\nreturn true\nreturn false\nneed_dotenv = pytest.mark.skipif(\ndotenv_not_available(), reason=\"dotenv is not installed\"\n)\n@need_dotenv", "app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\ncli = flaskgroup(create_app=lambda: app)\nresult = runner.invoke(cli, [\"routes\"])\nassert result.exit_code == 0\nassert \"host\" in result.output\ndef dotenv_not_available():\ntry:\nimport dotenv\nexcept importerror:\nreturn true\nreturn false\nneed_dotenv = pytest.mark.skipif(\ndotenv_not_available(), reason=\"dotenv is not installed\"\n)\n@need_dotenv\ndef test_load_dotenv(monkeypatch):\nfor item in (\"foo\", \"bar\", \"spam\", \"ham\"):\nmonkeypatch._setitem.append((os.environ, item, notset))\nmonkeypatch.setenv(\"eggs\", \"3\")\nmonkeypatch.chdir(test_path)\nassert load_dotenv()\nassert path.cwd() == test_path\nassert os.environ[\"foo\"] == \"env\"\nassert os.environ[\"bar\"] == \"bar\"\nassert os.environ[\"spam\"] == \"1\"\nassert os.environ[\"eggs\"] == \"3\"\nassert os.environ[\"ham\"] == \"\u706b\u817f\"\nassert not load_dotenv(\"non-existent-file\", load_defaults=false)\n@need_dotenv\ndef test_dotenv_path(monkeypatch):\nfor item in (\"foo\", \"bar\", \"eggs\"):\nmonkeypatch._setitem.append((os.environ, item, notset))\nload_dotenv(test_path / \".flaskenv\")\nassert path.cwd() == cwd\nassert \"foo\" in os.environ\ndef test_dotenv_optional(monkeypatch):\nmonkeypatch.setitem(sys.modules, \"dotenv\", none)\nmonkeypatch.chdir(test_path)\nload_dotenv()\nassert \"foo\" not in os.environ\n@need_dotenv\ndef test_disable_dotenv_from_env(monkeypatch, runner):\nmonkeypatch.chdir(test_path)\nmonkeypatch.setitem(os.environ, \"flask_skip_dotenv\", \"1\")\nrunner.invoke(flaskgroup())\nassert \"foo\" not in os.environ\ndef test_run_cert_path():\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", __file__])\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--key\", __file__])\nctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\nassert ctx.params[\"cert\"] == (__file__, __file__)\nctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])", "run_command.make_context(\"run\", [\"--cert\", __file__])\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--key\", __file__])\nctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\nassert ctx.params[\"cert\"] == (__file__, __file__)\nctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\nassert ctx.params[\"cert\"] == (__file__, __file__)\ndef test_run_cert_adhoc(monkeypatch):\nmonkeypatch.setitem(sys.modules, \"cryptography\", none)\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\nmonkeypatch.setitem(sys.modules, \"cryptography\", types.moduletype(\"cryptography\"))\nctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\nassert ctx.params[\"cert\"] == \"adhoc\"\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\ndef test_run_cert_import(monkeypatch):\nmonkeypatch.setitem(sys.modules, \"not_here\", none)\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"not_here\"])\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"flask\"])\nssl_context = ssl.sslcontext(ssl.protocol_tls_server)\nmonkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\nctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\nassert ctx.params[\"cert\"] is ssl_context\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])\ndef test_run_cert_no_ssl(monkeypatch):\nmonkeypatch.setitem(sys.modules, \"ssl\", none)\nwith pytest.raises(click.badparameter):\nrun_command.make_context(\"run\", [\"--cert\", \"not_here\"])\ndef test_cli_blueprints(app):\ncustom = blueprint(\"custom\", __name__, cli_group=\"customized\")\nnested = blueprint(\"nested\", __name__)\nmerged = blueprint(\"merged\", __name__, cli_group=none)\nlate = blueprint(\"late\", __name__)\n@custom.cli.command(\"custom\")\ndef custom_command():\nclick.echo(\"custom_result\")\n@nested.cli.command(\"nested\")\ndef nested_command():\nclick.echo(\"nested_result\")", "def test_cli_blueprints(app):\ncustom = blueprint(\"custom\", __name__, cli_group=\"customized\")\nnested = blueprint(\"nested\", __name__)\nmerged = blueprint(\"merged\", __name__, cli_group=none)\nlate = blueprint(\"late\", __name__)\n@custom.cli.command(\"custom\")\ndef custom_command():\nclick.echo(\"custom_result\")\n@nested.cli.command(\"nested\")\ndef nested_command():\nclick.echo(\"nested_result\")\n@merged.cli.command(\"merged\")\ndef merged_command():\nclick.echo(\"merged_result\")\n@late.cli.command(\"late\")\ndef late_command():\nclick.echo(\"late_result\")\napp.register_blueprint(custom)\napp.register_blueprint(nested)\napp.register_blueprint(merged)\napp.register_blueprint(late, cli_group=\"late_registration\")\napp_runner = app.test_cli_runner()\nresult = app_runner.invoke(args=[\"customized\", \"custom\"])\nassert \"custom_result\" in result.output\nresult = app_runner.invoke(args=[\"nested\", \"nested\"])\nassert \"nested_result\" in result.output\nresult = app_runner.invoke(args=[\"merged\"])\nassert \"merged_result\" in result.output\nresult = app_runner.invoke(args=[\"late_registration\", \"late\"])\nassert \"late_result\" in result.output\ndef test_cli_empty(app):\nbp = blueprint(\"blue\", __name__, cli_group=\"blue\")\napp.register_blueprint(bp)\nresult = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\nassert result.exit_code == 2, f\"unexpected success:\\n\\n{result.output}\"\ndef test_run_exclude_patterns():\nctx = run_command.make_context(\"run\", [\"--exclude-patterns\", __file__])\nassert ctx.params[\"exclude_patterns\"] == [__file__]", "import pytest\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\ndef test_basic_url_generation(app):\napp.config[\"server_name\"] = \"localhost\"\napp.config[\"preferred_url_scheme\"] = \"https\"\n@app.route(\"/\")\ndef index():\npass\nwith app.app_context():\nrv = flask.url_for(\"index\")\nassert rv == \"https:\ndef test_url_generation_requires_server_name(app):\nwith app.app_context():\nwith pytest.raises(runtimeerror):\nflask.url_for(\"index\")\ndef test_url_generation_without_context_fails():\nwith pytest.raises(runtimeerror):\nflask.url_for(\"index\")\ndef test_request_context_means_app_context(app):\nwith app.test_request_context():\nassert flask.current_app._get_current_object() is app\nassert not flask.current_app\ndef test_app_context_provides_current_app(app):\nwith app.app_context():\nassert flask.current_app._get_current_object() is app\nassert not flask.current_app\ndef test_app_tearing_down(app):\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\nwith app.app_context():\npass\nassert cleanup_stuff == [none]\ndef test_app_tearing_down_with_previous_exception(app):\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\ntry:\nraise exception(\"dummy\")\nexcept exception:\npass\nwith app.app_context():\npass\nassert cleanup_stuff == [none]\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\nwith app.app_context():\ntry:\nraise exception(\"dummy\")\nexcept exception:\npass\nassert cleanup_stuff == [none]\ndef test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\napp.config[\"propagate_exceptions\"] = true\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\n@app.route(\"/\")\ndef index():\nraise exception(\"dummy\")\n@app.errorhandler(exception)\ndef handler(f):\nreturn flask.jsonify(str(f))\nwith app.app_context():\nclient.get(\"/\")\nassert cleanup_stuff == [none]\ndef test_app_tearing_down_with_unhandled_exception(app, client):\napp.config[\"propagate_exceptions\"] = true\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\n@app.route(\"/\")\ndef index():\nraise valueerror(\"dummy\")\nwith pytest.raises(valueerror, match=\"dummy\"):\nwith app.app_context():\nclient.get(\"/\")", "def handler(f):\nreturn flask.jsonify(str(f))\nwith app.app_context():\nclient.get(\"/\")\nassert cleanup_stuff == [none]\ndef test_app_tearing_down_with_unhandled_exception(app, client):\napp.config[\"propagate_exceptions\"] = true\ncleanup_stuff = []\n@app.teardown_appcontext\ndef cleanup(exception):\ncleanup_stuff.append(exception)\n@app.route(\"/\")\ndef index():\nraise valueerror(\"dummy\")\nwith pytest.raises(valueerror, match=\"dummy\"):\nwith app.app_context():\nclient.get(\"/\")\nassert len(cleanup_stuff) == 1\nassert isinstance(cleanup_stuff[0], valueerror)\nassert str(cleanup_stuff[0]) == \"dummy\"\ndef test_app_ctx_globals_methods(app, app_ctx):\nassert flask.g.get(\"foo\") is none\nassert flask.g.get(\"foo\", \"bar\") == \"bar\"\nassert \"foo\" not in flask.g\nflask.g.foo = \"bar\"\nassert \"foo\" in flask.g\nflask.g.setdefault(\"bar\", \"the cake is a lie\")\nflask.g.setdefault(\"bar\", \"hello world\")\nassert flask.g.bar == \"the cake is a lie\"\nassert flask.g.pop(\"bar\") == \"the cake is a lie\"\nwith pytest.raises(keyerror):\nflask.g.pop(\"bar\")\nassert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\nassert list(flask.g) == [\"foo\"]\nassert repr(flask.g) == \"<flask.g of 'flask_test'>\"\ndef test_custom_app_ctx_globals_class(app):\nclass customrequestglobals:\ndef __init__(self):\nself.spam = \"eggs\"\napp.app_ctx_globals_class = customrequestglobals\nwith app.app_context():\nassert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\ndef test_context_refcounts(app, client):\ncalled = []\n@app.teardown_request\ndef teardown_req(error=none):\ncalled.append(\"request\")\n@app.teardown_appcontext\ndef teardown_app(error=none):\ncalled.append(\"app\")\n@app.route(\"/\")\ndef index():\nwith app_ctx:\nwith request_ctx:\npass\nassert flask.request.environ[\"werkzeug.request\"] is not none\nreturn \"\"\nres = client.get(\"/\")\nassert res.status_code == 200\nassert res.data == b\"\"\nassert called == [\"request\", \"app\"]\ndef test_clean_pop(app):\napp.testing = false\ncalled = []\n@app.teardown_request\ndef teardown_req(error=none):\nraise zerodivisionerror\n@app.teardown_appcontext", "@app.route(\"/\")\ndef index():\nwith app_ctx:\nwith request_ctx:\npass\nassert flask.request.environ[\"werkzeug.request\"] is not none\nreturn \"\"\nres = client.get(\"/\")\nassert res.status_code == 200\nassert res.data == b\"\"\nassert called == [\"request\", \"app\"]\ndef test_clean_pop(app):\napp.testing = false\ncalled = []\n@app.teardown_request\ndef teardown_req(error=none):\nraise zerodivisionerror\n@app.teardown_appcontext\ndef teardown_app(error=none):\ncalled.append(\"teardown\")\nwith app.app_context():\ncalled.append(flask.current_app.name)\nassert called == [\"flask_test\", \"teardown\"]\nassert not flask.current_app", "from __future__ import annotations\nimport collections.abc as cabc\nimport typing as t\nif t.type_checking:\nfrom _typeshed.wsgi import wsgiapplication\nfrom werkzeug.datastructures import headers\nfrom werkzeug.sansio.response import response\nresponsevalue = t.union[\n\"response\",\nstr,\nbytes,\nlist[t.any],\nt.mapping[str, t.any],\nt.iterator[str],\nt.iterator[bytes],\ncabc.asynciterable[str],\ncabc.asynciterable[bytes],\n]\nheadervalue = t.union[str, list[str], tuple[str, ...]]\nheadersvalue = t.union[\n\"headers\",\nt.mapping[str, headervalue],\nt.sequence[tuple[str, headervalue]],\n]\nresponsereturnvalue = t.union[\nresponsevalue,\ntuple[responsevalue, headersvalue],\ntuple[responsevalue, int],\ntuple[responsevalue, int, headersvalue],\n\"wsgiapplication\",\n]\nresponseclass = t.typevar(\"responseclass\", bound=\"response\")\napporblueprintkey = t.optional[str]\nafterrequestcallable = t.union[\nt.callable[[responseclass], responseclass],\nt.callable[[responseclass], t.awaitable[responseclass]],\n]\nbeforefirstrequestcallable = t.union[\nt.callable[[], none], t.callable[[], t.awaitable[none]]\n]\nbeforerequestcallable = t.union[\nt.callable[[], t.optional[responsereturnvalue]],\nt.callable[[], t.awaitable[t.optional[responsereturnvalue]]],\n]\nshellcontextprocessorcallable = t.callable[[], dict[str, t.any]]\nteardowncallable = t.union[\nt.callable[[t.optional[baseexception]], none],\nt.callable[[t.optional[baseexception]], t.awaitable[none]],\n]\ntemplatecontextprocessorcallable = t.union[\nt.callable[[], dict[str, t.any]],\nt.callable[[], t.awaitable[dict[str, t.any]]],\n]\ntemplatefiltercallable = t.callable[..., t.any]\ntemplateglobalcallable = t.callable[..., t.any]\ntemplatetestcallable = t.callable[..., bool]\nurldefaultcallable = t.callable[[str, dict[str, t.any]], none]\nurlvaluepreprocessorcallable = t.callable[\n[t.optional[str], t.optional[dict[str, t.any]]], none\n]\nerrorhandlercallable = t.union[\nt.callable[[t.any], responsereturnvalue],", "]\ntemplatefiltercallable = t.callable[..., t.any]\ntemplateglobalcallable = t.callable[..., t.any]\ntemplatetestcallable = t.callable[..., bool]\nurldefaultcallable = t.callable[[str, dict[str, t.any]], none]\nurlvaluepreprocessorcallable = t.callable[\n[t.optional[str], t.optional[dict[str, t.any]]], none\n]\nerrorhandlercallable = t.union[\nt.callable[[t.any], responsereturnvalue],\nt.callable[[t.any], t.awaitable[responsereturnvalue]],\n]\nroutecallable = t.union[\nt.callable[..., responsereturnvalue],\nt.callable[..., t.awaitable[responsereturnvalue]],\n]", "from flask import flask\nraise importerror()\ntestapp = flask(\"testapp\")", "import logging\nimport sys\nfrom io import stringio\nimport pytest\nfrom flask.logging import default_handler\nfrom flask.logging import has_level_handler\nfrom flask.logging import wsgi_errors_stream\n@pytest.fixture(autouse=true)\ndef reset_logging(pytestconfig):\nroot_handlers = logging.root.handlers[:]\nlogging.root.handlers = []\nroot_level = logging.root.level\nlogger = logging.getlogger(\"flask_test\")\nlogger.handlers = []\nlogger.setlevel(logging.notset)\nlogging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\nyield\nlogging.root.handlers[:] = root_handlers\nlogging.root.setlevel(root_level)\nlogger.handlers = []\nlogger.setlevel(logging.notset)\nif logging_plugin:\npytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\ndef test_logger(app):\nassert app.logger.name == \"flask_test\"\nassert app.logger.level == logging.notset\nassert app.logger.handlers == [default_handler]\ndef test_logger_debug(app):\napp.debug = true\nassert app.logger.level == logging.debug\nassert app.logger.handlers == [default_handler]\ndef test_existing_handler(app):\nlogging.root.addhandler(logging.streamhandler())\nassert app.logger.level == logging.notset\nassert not app.logger.handlers\ndef test_wsgi_errors_stream(app, client):\n@app.route(\"/\")\ndef index():\napp.logger.error(\"test\")\nreturn \"\"\nstream = stringio()\nclient.get(\"/\", errors_stream=stream)\nassert \"error in test_logging: test\" in stream.getvalue()\nassert wsgi_errors_stream._get_current_object() is sys.stderr\nwith app.test_request_context(errors_stream=stream):\nassert wsgi_errors_stream._get_current_object() is stream\ndef test_has_level_handler():\nlogger = logging.getlogger(\"flask.app\")\nassert not has_level_handler(logger)\nhandler = logging.streamhandler()\nlogging.root.addhandler(handler)\nassert has_level_handler(logger)\nlogger.propagate = false\nassert not has_level_handler(logger)\nlogger.propagate = true\nhandler.setlevel(logging.error)\nassert not has_level_handler(logger)\ndef test_log_view_exception(app, client):\n@app.route(\"/\")\ndef index():\nraise exception(\"test\")\napp.testing = false\nstream = stringio()\nrv = client.get(\"/\", errors_stream=stream)\nassert rv.status_code == 500\nassert rv.data\nerr = stream.getvalue()\nassert \"exception on / [get]\" in err\nassert \"exception: test\" in err", "from flask import flask\napp = flask(__name__)\n@app.route(\"/\")\ndef hello():\nreturn \"hello world!\"", "from __future__ import annotations\nimport typing as t\nfrom . import typing as ft\nfrom .globals import current_app\nfrom .globals import request\nf = t.typevar(\"f\", bound=t.callable[..., t.any])\nhttp_method_funcs = frozenset(\n[\"get\", \"post\", \"head\", \"options\", \"delete\", \"put\", \"trace\", \"patch\"]\n)\nclass view:\nmethods: t.classvar[t.collection[str] | none] = none\nprovide_automatic_options: t.classvar[bool | none] = none\ndecorators: t.classvar[list[t.callable[..., t.any]]] = []\ninit_every_request: t.classvar[bool] = true\ndef dispatch_request(self) -> ft.responsereturnvalue:\nraise notimplementederror()\n@classmethod\ndef as_view(\ncls, name: str, *class_args: t.any, **class_kwargs: t.any\n) -> ft.routecallable:\nif cls.init_every_request:\ndef view(**kwargs: t.any) -> ft.responsereturnvalue:\nself = view.view_class(\n*class_args, **class_kwargs\n)\nreturn current_app.ensure_sync(self.dispatch_request)(**kwargs)\nelse:\nself = cls(*class_args, **class_kwargs)\ndef view(**kwargs: t.any) -> ft.responsereturnvalue:\nreturn current_app.ensure_sync(self.dispatch_request)(**kwargs)\nif cls.decorators:\nview.__name__ = name\nview.__module__ = cls.__module__\nfor decorator in cls.decorators:\nview = decorator(view)\nview.view_class = cls\nview.__name__ = name\nview.__doc__ = cls.__doc__\nview.__module__ = cls.__module__\nview.methods = cls.methods\nview.provide_automatic_options = cls.provide_automatic_options\nreturn view\nclass methodview(view):\ndef __init_subclass__(cls, **kwargs: t.any) -> none:\nsuper().__init_subclass__(**kwargs)\nif \"methods\" not in cls.__dict__:\nmethods = set()\nfor base in cls.__bases__:\nif getattr(base, \"methods\", none):\nmethods.update(base.methods)\nfor key in http_method_funcs:\nif hasattr(cls, key):\nmethods.add(key.upper())\nif methods:\ncls.methods = methods\ndef dispatch_request(self, **kwargs: t.any) -> ft.responsereturnvalue:\nmeth = getattr(self, request.method.lower(), none)\nif meth is none and request.method == \"head\":", "methods = set()\nfor base in cls.__bases__:\nif getattr(base, \"methods\", none):\nmethods.update(base.methods)\nfor key in http_method_funcs:\nif hasattr(cls, key):\nmethods.add(key.upper())\nif methods:\ncls.methods = methods\ndef dispatch_request(self, **kwargs: t.any) -> ft.responsereturnvalue:\nmeth = getattr(self, request.method.lower(), none)\nif meth is none and request.method == \"head\":\nmeth = getattr(self, \"get\", none)\nassert meth is not none, f\"unimplemented method {request.method!r}\"\nreturn current_app.ensure_sync(meth)(**kwargs)", "import logging\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import templatenotfound\nfrom markupsafe import markup\nimport flask\ndef test_context_processing(app, client):\n@app.context_processor\ndef context_processor():\nreturn {\"injected_value\": 42}\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"context_template.html\", value=23)\nrv = client.get(\"/\")\nassert rv.data == b\"<p>23|42\"\ndef test_original_win(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.render_template_string(\"{{ config }}\", config=42)\nrv = client.get(\"/\")\nassert rv.data == b\"42\"\ndef test_simple_stream(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.stream_template_string(\"{{ config }}\", config=42)\nrv = client.get(\"/\")\nassert rv.data == b\"42\"\ndef test_request_less_rendering(app, app_ctx):\napp.config[\"world_name\"] = \"special world\"\n@app.context_processor\ndef context_processor():\nreturn dict(foo=42)\nrv = flask.render_template_string(\"hello {{ config.world_name }} {{ foo }}\")\nassert rv == \"hello special world 42\"\ndef test_standard_context(app, client):\n@app.route(\"/\")\ndef index():\nflask.g.foo = 23\nflask.session[\"test\"] = \"aha\"\nreturn flask.render_template_string(\n)\nrv = client.get(\"/?foo=42\")\nassert rv.data.split() == [b\"42\", b\"23\", b\"false\", b\"aha\"]\ndef test_escaping(app, client):\ntext = \"<p>hello world!\"\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\n\"escaping_template.html\", text=text, html=markup(text)\n)\nlines = client.get(\"/\").data.splitlines()\nassert lines == [\nb\"&lt;p&gt;hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"&lt;p&gt;hello world!\",\nb\"<p>hello world!\",\n]\ndef test_no_escaping(app, client):\ntext = \"<p>hello world!\"\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\n\"non_escaping_template.txt\", text=text, html=markup(text)\n)\nlines = client.get(\"/\").data.splitlines()\nassert lines == [\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"&lt;p&gt;hello world!\",", "]\ndef test_no_escaping(app, client):\ntext = \"<p>hello world!\"\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\n\"non_escaping_template.txt\", text=text, html=markup(text)\n)\nlines = client.get(\"/\").data.splitlines()\nassert lines == [\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"&lt;p&gt;hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\nb\"<p>hello world!\",\n]\ndef test_escaping_without_template_filename(app, client, req_ctx):\nassert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\nassert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> mail\"\ndef test_macros(app, req_ctx):\nmacro = flask.get_template_attribute(\"_macro.html\", \"hello\")\nassert macro(\"world\") == \"hello world!\"\ndef test_template_filter(app):\n@app.template_filter()\ndef my_reverse(s):\nreturn s[::-1]\nassert \"my_reverse\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"my_reverse\"] == my_reverse\nassert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\ndef test_add_template_filter(app):\ndef my_reverse(s):\nreturn s[::-1]\napp.add_template_filter(my_reverse)\nassert \"my_reverse\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"my_reverse\"] == my_reverse\nassert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\ndef test_template_filter_with_name(app):\n@app.template_filter(\"strrev\")\ndef my_reverse(s):\nreturn s[::-1]\nassert \"strrev\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"strrev\"] == my_reverse\nassert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\ndef test_add_template_filter_with_name(app):\ndef my_reverse(s):\nreturn s[::-1]\napp.add_template_filter(my_reverse, \"strrev\")\nassert \"strrev\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"strrev\"] == my_reverse\nassert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\ndef test_template_filter_with_template(app, client):\n@app.template_filter()\ndef super_reverse(s):\nreturn s[::-1]\n@app.route(\"/\")", "def my_reverse(s):\nreturn s[::-1]\napp.add_template_filter(my_reverse, \"strrev\")\nassert \"strrev\" in app.jinja_env.filters.keys()\nassert app.jinja_env.filters[\"strrev\"] == my_reverse\nassert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\ndef test_template_filter_with_template(app, client):\n@app.template_filter()\ndef super_reverse(s):\nreturn s[::-1]\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_add_template_filter_with_template(app, client):\ndef super_reverse(s):\nreturn s[::-1]\napp.add_template_filter(super_reverse)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_filter_with_name_and_template(app, client):\n@app.template_filter(\"super_reverse\")\ndef my_reverse(s):\nreturn s[::-1]\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_add_template_filter_with_name_and_template(app, client):\ndef my_reverse(s):\nreturn s[::-1]\napp.add_template_filter(my_reverse, \"super_reverse\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_filter.html\", value=\"abcd\")\nrv = client.get(\"/\")\nassert rv.data == b\"dcba\"\ndef test_template_test(app):\n@app.template_test()\ndef boolean(value):\nreturn isinstance(value, bool)\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_add_template_test(app):\ndef boolean(value):\nreturn isinstance(value, bool)\napp.add_template_test(boolean)\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_template_test_with_name(app):\n@app.template_test(\"boolean\")\ndef is_boolean(value):\nreturn isinstance(value, bool)\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == is_boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_add_template_test_with_name(app):\ndef is_boolean(value):\nreturn isinstance(value, bool)", "assert app.jinja_env.tests[\"boolean\"](false)\ndef test_template_test_with_name(app):\n@app.template_test(\"boolean\")\ndef is_boolean(value):\nreturn isinstance(value, bool)\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == is_boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_add_template_test_with_name(app):\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.add_template_test(is_boolean, \"boolean\")\nassert \"boolean\" in app.jinja_env.tests.keys()\nassert app.jinja_env.tests[\"boolean\"] == is_boolean\nassert app.jinja_env.tests[\"boolean\"](false)\ndef test_template_test_with_template(app, client):\n@app.template_test()\ndef boolean(value):\nreturn isinstance(value, bool)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_add_template_test_with_template(app, client):\ndef boolean(value):\nreturn isinstance(value, bool)\napp.add_template_test(boolean)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_template_test_with_name_and_template(app, client):\n@app.template_test(\"boolean\")\ndef is_boolean(value):\nreturn isinstance(value, bool)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_add_template_test_with_name_and_template(app, client):\ndef is_boolean(value):\nreturn isinstance(value, bool)\napp.add_template_test(is_boolean, \"boolean\")\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"template_test.html\", value=false)\nrv = client.get(\"/\")\nassert b\"success!\" in rv.data\ndef test_add_template_global(app, app_ctx):\n@app.template_global()\ndef get_stuff():\nreturn 42\nassert \"get_stuff\" in app.jinja_env.globals.keys()\nassert app.jinja_env.globals[\"get_stuff\"] == get_stuff\nassert app.jinja_env.globals[\"get_stuff\"](), 42\nrv = flask.render_template_string(\"{{ get_stuff() }}\")\nassert rv == \"42\"\ndef test_custom_template_loader(client):\nclass myflask(flask.flask):\ndef create_global_jinja_loader(self):\nfrom jinja2 import dictloader\nreturn dictloader({\"index.html\": \"hello custom world!\"})", "assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\nassert app.jinja_env.globals[\"get_stuff\"](), 42\nrv = flask.render_template_string(\"{{ get_stuff() }}\")\nassert rv == \"42\"\ndef test_custom_template_loader(client):\nclass myflask(flask.flask):\ndef create_global_jinja_loader(self):\nfrom jinja2 import dictloader\nreturn dictloader({\"index.html\": \"hello custom world!\"})\napp = myflask(__name__)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"index.html\")\nc = app.test_client()\nrv = c.get(\"/\")\nassert rv.data == b\"hello custom world!\"\ndef test_iterable_loader(app, client):\n@app.context_processor\ndef context_processor():\nreturn {\"whiskey\": \"jameson\"}\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\n[\n\"no_template.xml\",\n\"simple_template.html\",\n\"context_template.html\",\n],\nvalue=23,\n)\nrv = client.get(\"/\")\nassert rv.data == b\"<h1>jameson</h1>\"\ndef test_templates_auto_reload(app):\nassert app.debug is false\nassert app.config[\"templates_auto_reload\"] is none\nassert app.jinja_env.auto_reload is false\napp = flask.flask(__name__)\napp.config[\"templates_auto_reload\"] = false\nassert app.debug is false\nassert app.jinja_env.auto_reload is false\napp = flask.flask(__name__)\napp.config[\"templates_auto_reload\"] = true\nassert app.debug is false\nassert app.jinja_env.auto_reload is true\napp = flask.flask(__name__)\napp.config[\"debug\"] = true\nassert app.config[\"templates_auto_reload\"] is none\nassert app.jinja_env.auto_reload is true\napp = flask.flask(__name__)\napp.config[\"debug\"] = true\napp.config[\"templates_auto_reload\"] = false\nassert app.jinja_env.auto_reload is false\napp = flask.flask(__name__)\napp.config[\"debug\"] = true\napp.config[\"templates_auto_reload\"] = true\nassert app.jinja_env.auto_reload is true\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\ndef run_simple_mock(*args, **kwargs):\npass\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.run()\nassert not app.jinja_env.auto_reload\napp.run(debug=true)\nassert app.jinja_env.auto_reload\ndef test_template_loader_debugging(test_apps, monkeypatch):", "app.config[\"templates_auto_reload\"] = true\nassert app.jinja_env.auto_reload is true\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\ndef run_simple_mock(*args, **kwargs):\npass\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.run()\nassert not app.jinja_env.auto_reload\napp.run(debug=true)\nassert app.jinja_env.auto_reload\ndef test_template_loader_debugging(test_apps, monkeypatch):\nfrom blueprintapp import app\ncalled = []\nclass _testhandler(logging.handler):\ndef handle(self, record):\ncalled.append(true)\ntext = str(record.msg)\nassert \"1: trying loader of application 'blueprintapp'\" in text\nassert (\n\"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n) in text\nassert (\n\"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n) in text\nassert \"error: the template could not be found\" in text\nassert (\n\"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n) in text\nassert \"see https:\nwith app.test_client() as c:\nmonkeypatch.setitem(app.config, \"explain_template_loading\", true)\nmonkeypatch.setattr(\nlogging.getlogger(\"blueprintapp\"), \"handlers\", [_testhandler()]\n)\nwith pytest.raises(templatenotfound) as excinfo:\nc.get(\"/missing\")\nassert \"missing_template.html\" in str(excinfo.value)\nassert len(called) == 1\ndef test_custom_jinja_env():\nclass customenvironment(flask.templating.environment):\npass\nclass customflask(flask.flask):\njinja_environment = customenvironment\napp = customflask(__name__)\nassert isinstance(app.jinja_env, customenvironment)", "from __future__ import annotations\nimport typing as t\nfrom base64 import b64decode\nfrom base64 import b64encode\nfrom datetime import datetime\nfrom uuid import uuid\nfrom markupsafe import markup\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_date\nfrom ..json import dumps\nfrom ..json import loads\nclass jsontag:\n__slots__ = (\"serializer\",)\nkey: str = \"\"\ndef __init__(self, serializer: taggedjsonserializer) -> none:\nself.serializer = serializer\ndef check(self, value: t.any) -> bool:\nraise notimplementederror\ndef to_json(self, value: t.any) -> t.any:\nraise notimplementederror\ndef to_python(self, value: t.any) -> t.any:\nraise notimplementederror\ndef tag(self, value: t.any) -> dict[str, t.any]:\nreturn {self.key: self.to_json(value)}\nclass tagdict(jsontag):\n__slots__ = ()\nkey = \" di\"\ndef check(self, value: t.any) -> bool:\nreturn (\nisinstance(value, dict)\nand len(value) == 1\nand next(iter(value)) in self.serializer.tags\n)\ndef to_json(self, value: t.any) -> t.any:\nkey = next(iter(value))\nreturn {f\"{key}__\": self.serializer.tag(value[key])}\ndef to_python(self, value: t.any) -> t.any:\nkey = next(iter(value))\nreturn {key[:-2]: value[key]}\nclass passdict(jsontag):\n__slots__ = ()\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, dict)\ndef to_json(self, value: t.any) -> t.any:\nreturn {k: self.serializer.tag(v) for k, v in value.items()}\ntag = to_json\nclass tagtuple(jsontag):\n__slots__ = ()\nkey = \" t\"\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, tuple)\ndef to_json(self, value: t.any) -> t.any:\nreturn [self.serializer.tag(item) for item in value]\ndef to_python(self, value: t.any) -> t.any:\nreturn tuple(value)\nclass passlist(jsontag):\n__slots__ = ()\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, list)\ndef to_json(self, value: t.any) -> t.any:", "return isinstance(value, tuple)\ndef to_json(self, value: t.any) -> t.any:\nreturn [self.serializer.tag(item) for item in value]\ndef to_python(self, value: t.any) -> t.any:\nreturn tuple(value)\nclass passlist(jsontag):\n__slots__ = ()\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, list)\ndef to_json(self, value: t.any) -> t.any:\nreturn [self.serializer.tag(item) for item in value]\ntag = to_json\nclass tagbytes(jsontag):\n__slots__ = ()\nkey = \" b\"\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, bytes)\ndef to_json(self, value: t.any) -> t.any:\nreturn b64encode(value).decode(\"ascii\")\ndef to_python(self, value: t.any) -> t.any:\nreturn b64decode(value)\nclass tagmarkup(jsontag):\n__slots__ = ()\nkey = \" m\"\ndef check(self, value: t.any) -> bool:\nreturn callable(getattr(value, \"__html__\", none))\ndef to_json(self, value: t.any) -> t.any:\nreturn str(value.__html__())\ndef to_python(self, value: t.any) -> t.any:\nreturn markup(value)\nclass taguuid(jsontag):\n__slots__ = ()\nkey = \" u\"\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, uuid)\ndef to_json(self, value: t.any) -> t.any:\nreturn value.hex\ndef to_python(self, value: t.any) -> t.any:\nreturn uuid(value)\nclass tagdatetime(jsontag):\n__slots__ = ()\nkey = \" d\"\ndef check(self, value: t.any) -> bool:\nreturn isinstance(value, datetime)\ndef to_json(self, value: t.any) -> t.any:\nreturn http_date(value)\ndef to_python(self, value: t.any) -> t.any:\nreturn parse_date(value)\nclass taggedjsonserializer:\n__slots__ = (\"tags\", \"order\")\ndefault_tags = [\ntagdict,\npassdict,\ntagtuple,\npasslist,\ntagbytes,\ntagmarkup,\ntaguuid,\ntagdatetime,\n]\ndef __init__(self) -> none:\nself.tags: dict[str, jsontag] = {}\nself.order: list[jsontag] = []\nfor cls in self.default_tags:\nself.register(cls)\ndef register(\nself,", "return parse_date(value)\nclass taggedjsonserializer:\n__slots__ = (\"tags\", \"order\")\ndefault_tags = [\ntagdict,\npassdict,\ntagtuple,\npasslist,\ntagbytes,\ntagmarkup,\ntaguuid,\ntagdatetime,\n]\ndef __init__(self) -> none:\nself.tags: dict[str, jsontag] = {}\nself.order: list[jsontag] = []\nfor cls in self.default_tags:\nself.register(cls)\ndef register(\nself,\ntag_class: type[jsontag],\nforce: bool = false,\nindex: int | none = none,\n) -> none:\ntag = tag_class(self)\nkey = tag.key\nif key:\nif not force and key in self.tags:\nraise keyerror(f\"tag '{key}' is already registered.\")\nself.tags[key] = tag\nif index is none:\nself.order.append(tag)\nelse:\nself.order.insert(index, tag)\ndef tag(self, value: t.any) -> t.any:\nfor tag in self.order:\nif tag.check(value):\nreturn tag.tag(value)\nreturn value\ndef untag(self, value: dict[str, t.any]) -> t.any:\nif len(value) != 1:\nreturn value\nkey = next(iter(value))\nif key not in self.tags:\nreturn value\nreturn self.tags[key].to_python(value[key])\ndef _untag_scan(self, value: t.any) -> t.any:\nif isinstance(value, dict):\nvalue = {k: self._untag_scan(v) for k, v in value.items()}\nvalue = self.untag(value)\nelif isinstance(value, list):\nvalue = [self._untag_scan(item) for item in value]\nreturn value\ndef dumps(self, value: t.any) -> str:\nreturn dumps(self.tag(value), separators=(\",\", \":\"))\ndef loads(self, value: str) -> t.any:\nreturn self._untag_scan(loads(value))", "import flask\ndef test_aborting(app):\nclass foo(exception):\nwhatever = 42\n@app.errorhandler(foo)\ndef handle_foo(e):\nreturn str(e.whatever)\n@app.route(\"/\")\ndef index():\nraise flask.abort(flask.redirect(flask.url_for(\"test\")))\n@app.route(\"/test\")\ndef test():\nraise foo()\nwith app.test_client() as c:\nrv = c.get(\"/\")\nlocation_parts = rv.headers[\"location\"].rpartition(\"/\")\nif location_parts[0]:\nassert location_parts[0] == \"http:\nassert location_parts[2] == \"test\"\nrv = c.get(\"/test\")\nassert rv.data == b\"42\"", "import flask\ndef test_template_rendered(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"simple_template.html\", whiskey=42)\nrecorded = []\ndef record(sender, template, context):\nrecorded.append((template, context))\nflask.template_rendered.connect(record, app)\ntry:\nclient.get(\"/\")\nassert len(recorded) == 1\ntemplate, context = recorded[0]\nassert template.name == \"simple_template.html\"\nassert context[\"whiskey\"] == 42\nfinally:\nflask.template_rendered.disconnect(record, app)\ndef test_before_render_template():\napp = flask.flask(__name__)\n@app.route(\"/\")\ndef index():\nreturn flask.render_template(\"simple_template.html\", whiskey=42)\nrecorded = []\ndef record(sender, template, context):\ncontext[\"whiskey\"] = 43\nrecorded.append((template, context))\nflask.before_render_template.connect(record, app)\ntry:\nrv = app.test_client().get(\"/\")\nassert len(recorded) == 1\ntemplate, context = recorded[0]\nassert template.name == \"simple_template.html\"\nassert context[\"whiskey\"] == 43\nassert rv.data == b\"<h1>43</h1>\"\nfinally:\nflask.before_render_template.disconnect(record, app)\ndef test_request_signals():\napp = flask.flask(__name__)\ncalls = []\ndef before_request_signal(sender):\ncalls.append(\"before-signal\")\ndef after_request_signal(sender, response):\nassert response.data == b\"stuff\"\ncalls.append(\"after-signal\")\n@app.before_request\ndef before_request_handler():\ncalls.append(\"before-handler\")\n@app.after_request\ndef after_request_handler(response):\ncalls.append(\"after-handler\")\nresponse.data = \"stuff\"\nreturn response\n@app.route(\"/\")\ndef index():\ncalls.append(\"handler\")\nreturn \"ignored anyway\"\nflask.request_started.connect(before_request_signal, app)\nflask.request_finished.connect(after_request_signal, app)\ntry:\nrv = app.test_client().get(\"/\")\nassert rv.data == b\"stuff\"\nassert calls == [\n\"before-signal\",\n\"before-handler\",\n\"handler\",\n\"after-handler\",\n\"after-signal\",\n]\nfinally:\nflask.request_started.disconnect(before_request_signal, app)\nflask.request_finished.disconnect(after_request_signal, app)\ndef test_request_exception_signal():\napp = flask.flask(__name__)\nrecorded = []\n@app.route(\"/\")\ndef index():\nraise zerodivisionerror\ndef record(sender, exception):\nrecorded.append(exception)\nflask.got_request_exception.connect(record, app)", "\"before-signal\",\n\"before-handler\",\n\"handler\",\n\"after-handler\",\n\"after-signal\",\n]\nfinally:\nflask.request_started.disconnect(before_request_signal, app)\nflask.request_finished.disconnect(after_request_signal, app)\ndef test_request_exception_signal():\napp = flask.flask(__name__)\nrecorded = []\n@app.route(\"/\")\ndef index():\nraise zerodivisionerror\ndef record(sender, exception):\nrecorded.append(exception)\nflask.got_request_exception.connect(record, app)\ntry:\nassert app.test_client().get(\"/\").status_code == 500\nassert len(recorded) == 1\nassert isinstance(recorded[0], zerodivisionerror)\nfinally:\nflask.got_request_exception.disconnect(record, app)\ndef test_appcontext_signals(app, client):\nrecorded = []\ndef record_push(sender, **kwargs):\nrecorded.append(\"push\")\ndef record_pop(sender, **kwargs):\nrecorded.append(\"pop\")\n@app.route(\"/\")\ndef index():\nreturn \"hello\"\nflask.appcontext_pushed.connect(record_push, app)\nflask.appcontext_popped.connect(record_pop, app)\ntry:\nrv = client.get(\"/\")\nassert rv.data == b\"hello\"\nassert recorded == [\"push\", \"pop\"]\nfinally:\nflask.appcontext_pushed.disconnect(record_push, app)\nflask.appcontext_popped.disconnect(record_pop, app)\ndef test_flash_signal(app):\n@app.route(\"/\")\ndef index():\nflask.flash(\"this is a flash message\", category=\"notice\")\nreturn flask.redirect(\"/other\")\nrecorded = []\ndef record(sender, message, category):\nrecorded.append((message, category))\nflask.message_flashed.connect(record, app)\ntry:\nclient = app.test_client()\nwith client.session_transaction():\nclient.get(\"/\")\nassert len(recorded) == 1\nmessage, category = recorded[0]\nassert message == \"this is a flash message\"\nassert category == \"notice\"\nfinally:\nflask.message_flashed.disconnect(record, app)\ndef test_appcontext_tearing_down_signal(app, client):\napp.testing = false\nrecorded = []\ndef record_teardown(sender, exc):\nrecorded.append(exc)\n@app.route(\"/\")\ndef index():\nraise zerodivisionerror\nflask.appcontext_tearing_down.connect(record_teardown, app)\ntry:\nrv = client.get(\"/\")\nassert rv.status_code == 500\nassert len(recorded) == 1\nassert isinstance(recorded[0], zerodivisionerror)\nfinally:", "def test_appcontext_tearing_down_signal(app, client):\napp.testing = false\nrecorded = []\ndef record_teardown(sender, exc):\nrecorded.append(exc)\n@app.route(\"/\")\ndef index():\nraise zerodivisionerror\nflask.appcontext_tearing_down.connect(record_teardown, app)\ntry:\nrv = client.get(\"/\")\nassert rv.status_code == 500\nassert len(recorded) == 1\nassert isinstance(recorded[0], zerodivisionerror)\nfinally:\nflask.appcontext_tearing_down.disconnect(record_teardown, app)", "import warnings\nimport pytest\nimport flask\nfrom flask.globals import request_ctx\nfrom flask.sessions import securecookiesessioninterface\nfrom flask.sessions import sessioninterface\ntry:\nfrom greenlet import greenlet\nexcept importerror:\ngreenlet = none\ndef test_teardown_on_pop(app):\nbuffer = []\n@app.teardown_request\ndef end_of_request(exception):\nbuffer.append(exception)\nctx = app.test_request_context()\nctx.push()\nassert buffer == []\nctx.pop()\nassert buffer == [none]\ndef test_teardown_with_previous_exception(app):\nbuffer = []\n@app.teardown_request\ndef end_of_request(exception):\nbuffer.append(exception)\ntry:\nraise exception(\"dummy\")\nexcept exception:\npass\nwith app.test_request_context():\nassert buffer == []\nassert buffer == [none]\ndef test_teardown_with_handled_exception(app):\nbuffer = []\n@app.teardown_request\ndef end_of_request(exception):\nbuffer.append(exception)\nwith app.test_request_context():\nassert buffer == []\ntry:\nraise exception(\"dummy\")\nexcept exception:\npass\nassert buffer == [none]\ndef test_proper_test_request_context(app):\napp.config.update(server_name=\"localhost.localdomain:5000\")\n@app.route(\"/\")\ndef index():\nreturn none\n@app.route(\"/\", subdomain=\"foo\")\ndef sub():\nreturn none\nwith app.test_request_context(\"/\"):\nassert (\nflask.url_for(\"index\", _external=true)\n== \"http:\n)\nwith app.test_request_context(\"/\"):\nassert (\nflask.url_for(\"sub\", _external=true)\n== \"http:\n)\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\n\"ignore\", \"current server name\", userwarning, \"flask.app\"\n)\nwith app.test_request_context(\n\"/\", environ_overrides={\"http_host\": \"localhost\"}\n):\npass\napp.config.update(server_name=\"localhost\")\nwith app.test_request_context(\"/\", environ_overrides={\"server_name\": \"localhost\"}):\npass\napp.config.update(server_name=\"localhost:80\")\nwith app.test_request_context(\n\"/\", environ_overrides={\"server_name\": \"localhost:80\"}\n):\npass\ndef test_context_binding(app):\n@app.route(\"/\")\ndef index():\nreturn f\"hello {flask.request.args['name']}!\"\n@app.route(\"/meh\")\ndef meh():\nreturn flask.request.url\nwith app.test_request_context(\"/?name=world\"):\nassert index() == \"hello world!\"\nwith app.test_request_context(\"/meh\"):\nassert meh() == \"http:\nassert not flask.request\ndef test_context_test(app):\nassert not flask.request", "):\npass\ndef test_context_binding(app):\n@app.route(\"/\")\ndef index():\nreturn f\"hello {flask.request.args['name']}!\"\n@app.route(\"/meh\")\ndef meh():\nreturn flask.request.url\nwith app.test_request_context(\"/?name=world\"):\nassert index() == \"hello world!\"\nwith app.test_request_context(\"/meh\"):\nassert meh() == \"http:\nassert not flask.request\ndef test_context_test(app):\nassert not flask.request\nassert not flask.has_request_context()\nctx = app.test_request_context()\nctx.push()\ntry:\nassert flask.request\nassert flask.has_request_context()\nfinally:\nctx.pop()\ndef test_manual_context_binding(app):\n@app.route(\"/\")\ndef index():\nreturn f\"hello {flask.request.args['name']}!\"\nctx = app.test_request_context(\"/?name=world\")\nctx.push()\nassert index() == \"hello world!\"\nctx.pop()\nwith pytest.raises(runtimeerror):\nindex()\n@pytest.mark.skipif(greenlet is none, reason=\"greenlet not installed\")\nclass testgreenletcontextcopying:\ndef test_greenlet_context_copying(self, app, client):\ngreenlets = []\n@app.route(\"/\")\ndef index():\nflask.session[\"fizz\"] = \"buzz\"\nreqctx = request_ctx.copy()\ndef g():\nassert not flask.request\nassert not flask.current_app\nwith reqctx:\nassert flask.request\nassert flask.current_app == app\nassert flask.request.path == \"/\"\nassert flask.request.args[\"foo\"] == \"bar\"\nassert flask.session.get(\"fizz\") == \"buzz\"\nassert not flask.request\nreturn 42\ngreenlets.append(greenlet(g))\nreturn \"hello world!\"\nrv = client.get(\"/?foo=bar\")\nassert rv.data == b\"hello world!\"\nresult = greenlets[0].run()\nassert result == 42\ndef test_greenlet_context_copying_api(self, app, client):\ngreenlets = []\n@app.route(\"/\")\ndef index():\nflask.session[\"fizz\"] = \"buzz\"\n@flask.copy_current_request_context\ndef g():\nassert flask.request\nassert flask.current_app == app\nassert flask.request.path == \"/\"\nassert flask.request.args[\"foo\"] == \"bar\"\nassert flask.session.get(\"fizz\") == \"buzz\"\nreturn 42\ngreenlets.append(greenlet(g))\nreturn \"hello world!\"\nrv = client.get(\"/?foo=bar\")\nassert rv.data == b\"hello world!\"\nresult = greenlets[0].run()\nassert result == 42", "def g():\nassert flask.request\nassert flask.current_app == app\nassert flask.request.path == \"/\"\nassert flask.request.args[\"foo\"] == \"bar\"\nassert flask.session.get(\"fizz\") == \"buzz\"\nreturn 42\ngreenlets.append(greenlet(g))\nreturn \"hello world!\"\nrv = client.get(\"/?foo=bar\")\nassert rv.data == b\"hello world!\"\nresult = greenlets[0].run()\nassert result == 42\ndef test_session_error_pops_context():\nclass sessionerror(exception):\npass\nclass failingsessioninterface(sessioninterface):\ndef open_session(self, app, request):\nraise sessionerror()\nclass customflask(flask.flask):\nsession_interface = failingsessioninterface()\napp = customflask(__name__)\n@app.route(\"/\")\ndef index():\nassertionerror()\nresponse = app.test_client().get(\"/\")\nassert response.status_code == 500\nassert not flask.request\nassert not flask.current_app\ndef test_session_dynamic_cookie_name():\nclass pathawaresessioninterface(securecookiesessioninterface):\ndef get_cookie_name(self, app):\nif flask.request.url.endswith(\"dynamic_cookie\"):\nreturn \"dynamic_cookie_name\"\nelse:\nreturn super().get_cookie_name(app)\nclass customflask(flask.flask):\nsession_interface = pathawaresessioninterface()\napp = customflask(__name__)\napp.secret_key = \"secret_key\"\n@app.route(\"/set\", methods=[\"post\"])\ndef set():\nflask.session[\"value\"] = flask.request.form[\"value\"]\nreturn \"value set\"\n@app.route(\"/get\")\ndef get():\nv = flask.session.get(\"value\", \"none\")\nreturn v\n@app.route(\"/set_dynamic_cookie\", methods=[\"post\"])\ndef set_dynamic_cookie():\nflask.session[\"value\"] = flask.request.form[\"value\"]\nreturn \"value set\"\n@app.route(\"/get_dynamic_cookie\")\ndef get_dynamic_cookie():\nv = flask.session.get(\"value\", \"none\")\nreturn v\ntest_client = app.test_client()\nassert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\nassert (\ntest_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n== b\"value set\"\n)\nassert test_client.get(\"/get\").data == b\"42\"\nassert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"\ndef test_bad_environ_raises_bad_request():\napp = flask.flask(__name__)\nfrom flask.testing import environbuilder\nbuilder = environbuilder(app)\nenviron = builder.get_environ()", "assert (\ntest_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n== b\"value set\"\n)\nassert test_client.get(\"/get\").data == b\"42\"\nassert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"\ndef test_bad_environ_raises_bad_request():\napp = flask.flask(__name__)\nfrom flask.testing import environbuilder\nbuilder = environbuilder(app)\nenviron = builder.get_environ()\nenviron[\"http_host\"] = \"\\x8a\"\nwith app.request_context(environ):\nresponse = app.full_dispatch_request()\nassert response.status_code == 400\ndef test_environ_for_valid_idna_completes():\napp = flask.flask(__name__)\n@app.route(\"/\")\ndef index():\nreturn \"hello world!\"\nfrom flask.testing import environbuilder\nbuilder = environbuilder(app)\nenviron = builder.get_environ()\nenviron[\"http_host\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0161\u00df\u044f.com\"\nwith app.request_context(environ):\nresponse = app.full_dispatch_request()\nassert response.status_code == 200\ndef test_normal_environ_completes():\napp = flask.flask(__name__)\n@app.route(\"/\")\ndef index():\nreturn \"hello world!\"\nresponse = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\nassert response.status_code == 200", "from __future__ import annotations\nimport importlib.metadata\nimport typing as t\nfrom contextlib import contextmanager\nfrom contextlib import exitstack\nfrom copy import copy\nfrom types import tracebacktype\nfrom urllib.parse import urlsplit\nimport werkzeug.test\nfrom click.testing import clirunner\nfrom click.testing import result\nfrom werkzeug.test import client\nfrom werkzeug.wrappers import request as baserequest\nfrom .cli import scriptinfo\nfrom .sessions import sessionmixin\nif t.type_checking:\nfrom _typeshed.wsgi import wsgienvironment\nfrom werkzeug.test import testresponse\nfrom .app import flask\nclass environbuilder(werkzeug.test.environbuilder):\ndef __init__(\nself,\napp: flask,\npath: str = \"/\",\nbase_url: str | none = none,\nsubdomain: str | none = none,\nurl_scheme: str | none = none,\n*args: t.any,\n**kwargs: t.any,\n) -> none:\nassert not (base_url or subdomain or url_scheme) or (\nbase_url is not none\n) != bool(subdomain or url_scheme), (\n'cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n)\nif base_url is none:\nhttp_host = app.config.get(\"server_name\") or \"localhost\"\napp_root = app.config[\"application_root\"]\nif subdomain:\nhttp_host = f\"{subdomain}.{http_host}\"\nif url_scheme is none:\nurl_scheme = app.config[\"preferred_url_scheme\"]\nurl = urlsplit(path)\nbase_url = (\nf\"{url.scheme or url_scheme}:\nf\"/{app_root.lstrip('/')}\"\n)\npath = url.path\nif url.query:\npath = f\"{path}?{url.query}\"\nself.app = app\nsuper().__init__(path, base_url, *args, **kwargs)\ndef json_dumps(self, obj: t.any, **kwargs: t.any) -> str:\nreturn self.app.json.dumps(obj, **kwargs)\n_werkzeug_version = \"\"\ndef _get_werkzeug_version() -> str:\nglobal _werkzeug_version\nif not _werkzeug_version:\n_werkzeug_version = importlib.metadata.version(\"werkzeug\")\nreturn _werkzeug_version\nclass flaskclient(client):\napplication: flask\ndef __init__(self, *args: t.any, **kwargs: t.any) -> none:\nsuper().__init__(*args, **kwargs)\nself.preserve_context = false", "_werkzeug_version = \"\"\ndef _get_werkzeug_version() -> str:\nglobal _werkzeug_version\nif not _werkzeug_version:\n_werkzeug_version = importlib.metadata.version(\"werkzeug\")\nreturn _werkzeug_version\nclass flaskclient(client):\napplication: flask\ndef __init__(self, *args: t.any, **kwargs: t.any) -> none:\nsuper().__init__(*args, **kwargs)\nself.preserve_context = false\nself._new_contexts: list[t.contextmanager[t.any]] = []\nself._context_stack = exitstack()\nself.environ_base = {\n\"remote_addr\": \"127.0.0.1\",\n\"http_user_agent\": f\"werkzeug/{_get_werkzeug_version()}\",\n}\n@contextmanager\ndef session_transaction(\nself, *args: t.any, **kwargs: t.any\n) -> t.iterator[sessionmixin]:\nif self._cookies is none:\nraise typeerror(\n\"cookies are disabled. create a client with 'use_cookies=true'.\"\n)\napp = self.application\nctx = app.test_request_context(*args, **kwargs)\nself._add_cookies_to_wsgi(ctx.request.environ)\nwith ctx:\nsess = app.session_interface.open_session(app, ctx.request)\nif sess is none:\nraise runtimeerror(\"session backend did not open a session.\")\nyield sess\nresp = app.response_class()\nif app.session_interface.is_null_session(sess):\nreturn\nwith ctx:\napp.session_interface.save_session(app, sess, resp)\nself._update_cookies_from_response(\nctx.request.host.partition(\":\")[0],\nctx.request.path,\nresp.headers.getlist(\"set-cookie\"),\n)\ndef _copy_environ(self, other: wsgienvironment) -> wsgienvironment:\nout = {**self.environ_base, **other}\nif self.preserve_context:\nout[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\nreturn out\ndef _request_from_builder_args(\nself, args: tuple[t.any, ...], kwargs: dict[str, t.any]\n) -> baserequest:\nkwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\nbuilder = environbuilder(self.application, *args, **kwargs)\ntry:\nreturn builder.get_request()\nfinally:\nbuilder.close()\ndef open(\nself,\n*args: t.any,\nbuffered: bool = false,\nfollow_redirects: bool = false,\n**kwargs: t.any,\n) -> testresponse:\nif args and isinstance(", ") -> baserequest:\nkwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\nbuilder = environbuilder(self.application, *args, **kwargs)\ntry:\nreturn builder.get_request()\nfinally:\nbuilder.close()\ndef open(\nself,\n*args: t.any,\nbuffered: bool = false,\nfollow_redirects: bool = false,\n**kwargs: t.any,\n) -> testresponse:\nif args and isinstance(\nargs[0], (werkzeug.test.environbuilder, dict, baserequest)\n):\nif isinstance(args[0], werkzeug.test.environbuilder):\nbuilder = copy(args[0])\nbuilder.environ_base = self._copy_environ(builder.environ_base or {})\nrequest = builder.get_request()\nelif isinstance(args[0], dict):\nrequest = environbuilder.from_environ(\nargs[0], app=self.application, environ_base=self._copy_environ({})\n).get_request()\nelse:\nrequest = copy(args[0])\nrequest.environ = self._copy_environ(request.environ)\nelse:\nrequest = self._request_from_builder_args(args, kwargs)\nself._context_stack.close()\nresponse = super().open(\nrequest,\nbuffered=buffered,\nfollow_redirects=follow_redirects,\n)\nresponse.json_module = self.application.json\nwhile self._new_contexts:\ncm = self._new_contexts.pop()\nself._context_stack.enter_context(cm)\nreturn response\ndef __enter__(self) -> flaskclient:\nif self.preserve_context:\nraise runtimeerror(\"cannot nest client invocations\")\nself.preserve_context = true\nreturn self\ndef __exit__(\nself,\nexc_type: type | none,\nexc_value: baseexception | none,\ntb: tracebacktype | none,\n) -> none:\nself.preserve_context = false\nself._context_stack.close()\nclass flaskclirunner(clirunner):\ndef __init__(self, app: flask, **kwargs: t.any) -> none:\nself.app = app\nsuper().__init__(**kwargs)\ndef invoke(\nself, cli: t.any = none, args: t.any = none, **kwargs: t.any\n) -> result:\nif cli is none:\ncli = self.app.cli\nif \"obj\" not in kwargs:\nkwargs[\"obj\"] = scriptinfo(create_app=lambda: self.app)\nreturn super().invoke(cli, args, **kwargs)", "from flask import flask\napplication = flask(__name__)", "import datetime\nimport decimal\nimport io\nimport uuid\nimport pytest\nfrom werkzeug.http import http_date\nimport flask\nfrom flask import json\nfrom flask.json.provider import defaultjsonprovider\n@pytest.mark.parametrize(\"debug\", (true, false))\ndef test_bad_request_debug_message(app, client, debug):\napp.config[\"debug\"] = debug\napp.config[\"trap_bad_request_errors\"] = false\n@app.route(\"/json\", methods=[\"post\"])\ndef post_json():\nflask.request.get_json()\nreturn none\nrv = client.post(\"/json\", data=none, content_type=\"application/json\")\nassert rv.status_code == 400\ncontains = b\"failed to decode json object\" in rv.data\nassert contains == debug\ndef test_json_bad_requests(app, client):\n@app.route(\"/json\", methods=[\"post\"])\ndef return_json():\nreturn flask.jsonify(foo=str(flask.request.get_json()))\nrv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\nassert rv.status_code == 400\ndef test_json_custom_mimetypes(app, client):\n@app.route(\"/json\", methods=[\"post\"])\ndef return_json():\nreturn flask.request.get_json()\nrv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\nassert rv.data == b\"foo\"\n@pytest.mark.parametrize(\n\"test_value,expected\", [(true, '\"\\\\u2603\"'), (false, '\"\\u2603\"')]\n)\ndef test_json_as_unicode(test_value, expected, app, app_ctx):\napp.json.ensure_ascii = test_value\nrv = app.json.dumps(\"\\n{snowman}\")\nassert rv == expected\ndef test_json_dump_to_file(app, app_ctx):\ntest_data = {\"name\": \"flask\"}\nout = io.stringio()\nflask.json.dump(test_data, out)\nout.seek(0)\nrv = flask.json.load(out)\nassert rv == test_data\n@pytest.mark.parametrize(\n\"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", true, false, none]\n)\ndef test_jsonify_basic_types(test_value, app, client):\nurl = \"/jsonify_basic_types\"\napp.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\nrv = client.get(url)\nassert rv.mimetype == \"application/json\"\nassert flask.json.loads(rv.data) == test_value\ndef test_jsonify_dicts(app, client):\nd = {", ")\ndef test_jsonify_basic_types(test_value, app, client):\nurl = \"/jsonify_basic_types\"\napp.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\nrv = client.get(url)\nassert rv.mimetype == \"application/json\"\nassert flask.json.loads(rv.data) == test_value\ndef test_jsonify_dicts(app, client):\nd = {\n\"a\": 0,\n\"b\": 23,\n\"c\": 3.14,\n\"d\": \"t\",\n\"e\": \"hi\",\n\"f\": true,\n\"g\": false,\n\"h\": [\"test list\", 10, false],\n\"i\": {\"test\": \"dict\"},\n}\n@app.route(\"/kw\")\ndef return_kwargs():\nreturn flask.jsonify(**d)\n@app.route(\"/dict\")\ndef return_dict():\nreturn flask.jsonify(d)\nfor url in \"/kw\", \"/dict\":\nrv = client.get(url)\nassert rv.mimetype == \"application/json\"\nassert flask.json.loads(rv.data) == d\ndef test_jsonify_arrays(app, client):\na_list = [\n0,\n42,\n3.14,\n\"t\",\n\"hello\",\ntrue,\nfalse,\n[\"test list\", 2, false],\n{\"test\": \"dict\"},\n]\n@app.route(\"/args_unpack\")\ndef return_args_unpack():\nreturn flask.jsonify(*a_list)\n@app.route(\"/array\")\ndef return_array():\nreturn flask.jsonify(a_list)\nfor url in \"/args_unpack\", \"/array\":\nrv = client.get(url)\nassert rv.mimetype == \"application/json\"\nassert flask.json.loads(rv.data) == a_list\n@pytest.mark.parametrize(\n\"value\", [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)]\n)\ndef test_jsonify_datetime(app, client, value):\n@app.route(\"/\")\ndef index():\nreturn flask.jsonify(value=value)\nr = client.get()\nassert r.json[\"value\"] == http_date(value)\nclass fixedoffset(datetime.tzinfo):\ndef __init__(self, hours, name):\nself.__offset = datetime.timedelta(hours=hours)\nself.__name = name\ndef utcoffset(self, dt):\nreturn self.__offset\ndef tzname(self, dt):\nreturn self.__name\ndef dst(self, dt):\nreturn datetime.timedelta()\n@pytest.mark.parametrize(\"tz\", ((\"utc\", 0), (\"pst\", -8), (\"kst\", 9)))\ndef test_jsonify_aware_datetimes(tz):", "def __init__(self, hours, name):\nself.__offset = datetime.timedelta(hours=hours)\nself.__name = name\ndef utcoffset(self, dt):\nreturn self.__offset\ndef tzname(self, dt):\nreturn self.__name\ndef dst(self, dt):\nreturn datetime.timedelta()\n@pytest.mark.parametrize(\"tz\", ((\"utc\", 0), (\"pst\", -8), (\"kst\", 9)))\ndef test_jsonify_aware_datetimes(tz):\ntzinfo = fixedoffset(hours=tz[1], name=tz[0])\ndt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\ngmt = fixedoffset(hours=0, name=\"gmt\")\nexpected = dt.astimezone(gmt).strftime('\"%a, %d %b %y %h:%m:%s %z\"')\nassert flask.json.dumps(dt) == expected\ndef test_jsonify_uuid_types(app, client):\ntest_uuid = uuid.uuid(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\nurl = \"/uuid_test\"\napp.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\nrv = client.get(url)\nrv_x = flask.json.loads(rv.data)[\"x\"]\nassert rv_x == str(test_uuid)\nrv_uuid = uuid.uuid(rv_x)\nassert rv_uuid == test_uuid\ndef test_json_decimal():\nrv = flask.json.dumps(decimal.decimal(\"0.003\"))\nassert rv == '\"0.003\"'\ndef test_json_attr(app, client):\n@app.route(\"/add\", methods=[\"post\"])\ndef add():\njson = flask.request.get_json()\nreturn str(json[\"a\"] + json[\"b\"])\nrv = client.post(\n\"/add\",\ndata=flask.json.dumps({\"a\": 1, \"b\": 2}),\ncontent_type=\"application/json\",\n)\nassert rv.data == b\"3\"\ndef test_tojson_filter(app, req_ctx):\nrv = flask.render_template_string(\n\"const data = {{ data|tojson }};\",\ndata={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n)\nassert rv == (\n'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n' \"time\": \"mon, 01 feb 2021 07:15:00 gmt\"};'\n)\ndef test_json_customization(app, client):\nclass x:", "\"const data = {{ data|tojson }};\",\ndata={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n)\nassert rv == (\n'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n' \"time\": \"mon, 01 feb 2021 07:15:00 gmt\"};'\n)\ndef test_json_customization(app, client):\nclass x:\ndef __init__(self, val):\nself.val = val\ndef default(o):\nif isinstance(o, x):\nreturn f\"<{o.val}>\"\nreturn defaultjsonprovider.default(o)\nclass customprovider(defaultjsonprovider):\ndef object_hook(self, obj):\nif len(obj) == 1 and \"_foo\" in obj:\nreturn x(obj[\"_foo\"])\nreturn obj\ndef loads(self, s, **kwargs):\nkwargs.setdefault(\"object_hook\", self.object_hook)\nreturn super().loads(s, **kwargs)\napp.json = customprovider(app)\napp.json.default = default\n@app.route(\"/\", methods=[\"post\"])\ndef index():\nreturn flask.json.dumps(flask.request.get_json()[\"x\"])\nrv = client.post(\n\"/\",\ndata=flask.json.dumps({\"x\": {\"_foo\": 42}}),\ncontent_type=\"application/json\",\n)\nassert rv.data == b'\"<42>\"'\ndef _has_encoding(name):\ntry:\nimport codecs\ncodecs.lookup(name)\nreturn true\nexcept lookuperror:\nreturn false\ndef test_json_key_sorting(app, client):\napp.debug = true\nassert app.json.sort_keys\nd = dict.fromkeys(range(20), \"foo\")\n@app.route(\"/\")\ndef index():\nreturn flask.jsonify(values=d)\nrv = client.get(\"/\")\nlines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\nsorted_by_str = [\n\"{\",\n'\"values\": {',\n'\"0\": \"foo\",',\n'\"1\": \"foo\",',\n'\"10\": \"foo\",',\n'\"11\": \"foo\",',\n'\"12\": \"foo\",',\n'\"13\": \"foo\",',\n'\"14\": \"foo\",',\n'\"15\": \"foo\",',\n'\"16\": \"foo\",',\n'\"17\": \"foo\",',\n'\"18\": \"foo\",',\n'\"19\": \"foo\",',\n'\"2\": \"foo\",',\n'\"3\": \"foo\",',\n'\"4\": \"foo\",',\n'\"5\": \"foo\",',\n'\"6\": \"foo\",',", "'\"11\": \"foo\",',\n'\"12\": \"foo\",',\n'\"13\": \"foo\",',\n'\"14\": \"foo\",',\n'\"15\": \"foo\",',\n'\"16\": \"foo\",',\n'\"17\": \"foo\",',\n'\"18\": \"foo\",',\n'\"19\": \"foo\",',\n'\"2\": \"foo\",',\n'\"3\": \"foo\",',\n'\"4\": \"foo\",',\n'\"5\": \"foo\",',\n'\"6\": \"foo\",',\n'\"7\": \"foo\",',\n'\"8\": \"foo\",',\n'\"9\": \"foo\"',\n\"}\",\n\"}\",\n]\nsorted_by_int = [\n\"{\",\n'\"values\": {',\n'\"0\": \"foo\",',\n'\"1\": \"foo\",',\n'\"2\": \"foo\",',\n'\"3\": \"foo\",',\n'\"4\": \"foo\",',\n'\"5\": \"foo\",',\n'\"6\": \"foo\",',\n'\"7\": \"foo\",',\n'\"8\": \"foo\",',\n'\"9\": \"foo\",',\n'\"10\": \"foo\",',\n'\"11\": \"foo\",',\n'\"12\": \"foo\",',\n'\"13\": \"foo\",',\n'\"14\": \"foo\",',\n'\"15\": \"foo\",',\n'\"16\": \"foo\",',\n'\"17\": \"foo\",',\n'\"18\": \"foo\",',\n'\"19\": \"foo\"',\n\"}\",\n\"}\",\n]\ntry:\nassert lines == sorted_by_int\nexcept assertionerror:\nassert lines == sorted_by_str\ndef test_html_method():\nclass objectwithhtml:\ndef __html__(self):\nreturn \"<p>test</p>\"\nresult = json.dumps(objectwithhtml())\nassert result == '\"<p>test</p>\"'", "from __future__ import annotations\nimport importlib.util\nimport os\nimport sys\nimport typing as t\nfrom datetime import datetime\nfrom functools import cache\nfrom functools import update_wrapper\nimport werkzeug.utils\nfrom werkzeug.exceptions import abort as _wz_abort\nfrom werkzeug.utils import redirect as _wz_redirect\nfrom werkzeug.wrappers import response as baseresponse\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .signals import message_flashed\nif t.type_checking:\nfrom .wrappers import response\ndef get_debug_flag() -> bool:\nval = os.environ.get(\"flask_debug\")\nreturn bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\ndef get_load_dotenv(default: bool = true) -> bool:\nval = os.environ.get(\"flask_skip_dotenv\")\nif not val:\nreturn default\nreturn val.lower() in (\"0\", \"false\", \"no\")\n@t.overload\ndef stream_with_context(\ngenerator_or_function: t.iterator[t.anystr],\n) -> t.iterator[t.anystr]: ...\n@t.overload\ndef stream_with_context(\ngenerator_or_function: t.callable[..., t.iterator[t.anystr]],\n) -> t.callable[[t.iterator[t.anystr]], t.iterator[t.anystr]]: ...\ndef stream_with_context(\ngenerator_or_function: t.iterator[t.anystr] | t.callable[..., t.iterator[t.anystr]],\n) -> t.iterator[t.anystr] | t.callable[[t.iterator[t.anystr]], t.iterator[t.anystr]]:\ntry:\ngen = iter(generator_or_function)\nexcept typeerror:\ndef decorator(*args: t.any, **kwargs: t.any) -> t.any:\ngen = generator_or_function(*args, **kwargs)\nreturn stream_with_context(gen)\nreturn update_wrapper(decorator, generator_or_function)\ndef generator() -> t.iterator[t.anystr | none]:\nctx = _cv_request.get(none)\nif ctx is none:\nraise runtimeerror(\n\"'stream_with_context' can only be used when a request\"\n\" context is active, such as in a view function.\"\n)\nwith ctx:\nyield none\ntry:\nyield from gen\nfinally:\nif hasattr(gen, \"close\"):\ngen.close()\nwrapped_g = generator()\nnext(wrapped_g)\nreturn wrapped_g\ndef make_response(*args: t.any) -> response:", "ctx = _cv_request.get(none)\nif ctx is none:\nraise runtimeerror(\n\"'stream_with_context' can only be used when a request\"\n\" context is active, such as in a view function.\"\n)\nwith ctx:\nyield none\ntry:\nyield from gen\nfinally:\nif hasattr(gen, \"close\"):\ngen.close()\nwrapped_g = generator()\nnext(wrapped_g)\nreturn wrapped_g\ndef make_response(*args: t.any) -> response:\nif not args:\nreturn current_app.response_class()\nif len(args) == 1:\nargs = args[0]\nreturn current_app.make_response(args)\ndef url_for(\nendpoint: str,\n*,\n_anchor: str | none = none,\n_method: str | none = none,\n_scheme: str | none = none,\n_external: bool | none = none,\n**values: t.any,\n) -> str:\nreturn current_app.url_for(\nendpoint,\n_anchor=_anchor,\n_method=_method,\n_scheme=_scheme,\n_external=_external,\n**values,\n)\ndef redirect(\nlocation: str, code: int = 302, response: type[baseresponse] | none = none\n) -> baseresponse:\nif current_app:\nreturn current_app.redirect(location, code=code)\nreturn _wz_redirect(location, code=code, response=response)\ndef abort(code: int | baseresponse, *args: t.any, **kwargs: t.any) -> t.noreturn:\nif current_app:\ncurrent_app.aborter(code, *args, **kwargs)\n_wz_abort(code, *args, **kwargs)\ndef get_template_attribute(template_name: str, attribute: str) -> t.any:\nreturn getattr(current_app.jinja_env.get_template(template_name).module, attribute)\ndef flash(message: str, category: str = \"message\") -> none:\nflashes = session.get(\"_flashes\", [])\nflashes.append((category, message))\nsession[\"_flashes\"] = flashes\napp = current_app._get_current_object()\nmessage_flashed.send(\napp,\n_async_wrapper=app.ensure_sync,\nmessage=message,\ncategory=category,\n)\ndef get_flashed_messages(\nwith_categories: bool = false, category_filter: t.iterable[str] = ()\n) -> list[str] | list[tuple[str, str]]:\nflashes = request_ctx.flashes\nif flashes is none:\nflashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\nrequest_ctx.flashes = flashes\nif category_filter:", "message_flashed.send(\napp,\n_async_wrapper=app.ensure_sync,\nmessage=message,\ncategory=category,\n)\ndef get_flashed_messages(\nwith_categories: bool = false, category_filter: t.iterable[str] = ()\n) -> list[str] | list[tuple[str, str]]:\nflashes = request_ctx.flashes\nif flashes is none:\nflashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\nrequest_ctx.flashes = flashes\nif category_filter:\nflashes = list(filter(lambda f: f[0] in category_filter, flashes))\nif not with_categories:\nreturn [x[1] for x in flashes]\nreturn flashes\ndef _prepare_send_file_kwargs(**kwargs: t.any) -> dict[str, t.any]:\nif kwargs.get(\"max_age\") is none:\nkwargs[\"max_age\"] = current_app.get_send_file_max_age\nkwargs.update(\nenviron=request.environ,\nuse_x_sendfile=current_app.config[\"use_x_sendfile\"],\nresponse_class=current_app.response_class,\n_root_path=current_app.root_path,\n)\nreturn kwargs\ndef send_file(\npath_or_file: os.pathlike[t.anystr] | str | t.binaryio,\nmimetype: str | none = none,\nas_attachment: bool = false,\ndownload_name: str | none = none,\nconditional: bool = true,\netag: bool | str = true,\nlast_modified: datetime | int | float | none = none,\nmax_age: none | (int | t.callable[[str | none], int | none]) = none,\n) -> response:\nreturn werkzeug.utils.send_file(\n**_prepare_send_file_kwargs(\npath_or_file=path_or_file,\nenviron=request.environ,\nmimetype=mimetype,\nas_attachment=as_attachment,\ndownload_name=download_name,\nconditional=conditional,\netag=etag,\nlast_modified=last_modified,\nmax_age=max_age,\n)\n)\ndef send_from_directory(\ndirectory: os.pathlike[str] | str,\npath: os.pathlike[str] | str,\n**kwargs: t.any,\n) -> response:\nreturn werkzeug.utils.send_from_directory(\ndirectory, path, **_prepare_send_file_kwargs(**kwargs)\n)\ndef get_root_path(import_name: str) -> str:\nmod = sys.modules.get(import_name)\nif mod is not none and hasattr(mod, \"__file__\") and mod.__file__ is not none:\nreturn os.path.dirname(os.path.abspath(mod.__file__))\ntry:\nspec = importlib.util.find_spec(import_name)", "**kwargs: t.any,\n) -> response:\nreturn werkzeug.utils.send_from_directory(\ndirectory, path, **_prepare_send_file_kwargs(**kwargs)\n)\ndef get_root_path(import_name: str) -> str:\nmod = sys.modules.get(import_name)\nif mod is not none and hasattr(mod, \"__file__\") and mod.__file__ is not none:\nreturn os.path.dirname(os.path.abspath(mod.__file__))\ntry:\nspec = importlib.util.find_spec(import_name)\nif spec is none:\nraise valueerror\nexcept (importerror, valueerror):\nloader = none\nelse:\nloader = spec.loader\nif loader is none:\nreturn os.getcwd()\nif hasattr(loader, \"get_filename\"):\nfilepath = loader.get_filename(import_name)\nelse:\n__import__(import_name)\nmod = sys.modules[import_name]\nfilepath = getattr(mod, \"__file__\", none)\nif filepath is none:\nraise runtimeerror(\n\"no root path can be found for the provided module\"\nf\" {import_name!r}. this can happen because the module\"\n\" came from an import hook that does not provide file\"\n\" name information or because it's a namespace package.\"\n\" in this case the root path needs to be explicitly\"\n\" provided.\"\n)\nreturn os.path.dirname(os.path.abspath(filepath))\n@cache\ndef _split_blueprint_path(name: str) -> list[str]:\nout: list[str] = [name]\nif \".\" in name:\nout.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\nreturn out", "from __future__ import annotations\nimport collections.abc as c\nimport hashlib\nimport typing as t\nfrom collections.abc import mutablemapping\nfrom datetime import datetime\nfrom datetime import timezone\nfrom itsdangerous import badsignature\nfrom itsdangerous import urlsafetimedserializer\nfrom werkzeug.datastructures import callbackdict\nfrom .json.tag import taggedjsonserializer\nif t.type_checking:\nimport typing_extensions as te\nfrom .app import flask\nfrom .wrappers import request\nfrom .wrappers import response\nclass sessionmixin(mutablemapping[str, t.any]):\n@property\ndef permanent(self) -> bool:\nreturn self.get(\"_permanent\", false)\n@permanent.setter\ndef permanent(self, value: bool) -> none:\nself[\"_permanent\"] = bool(value)\nnew = false\nmodified = true\naccessed = true\nclass securecookiesession(callbackdict[str, t.any], sessionmixin):\nmodified = false\naccessed = false\ndef __init__(\nself,\ninitial: c.mapping[str, t.any] | c.iterable[tuple[str, t.any]] | none = none,\n) -> none:\ndef on_update(self: te.self) -> none:\nself.modified = true\nself.accessed = true\nsuper().__init__(initial, on_update)\ndef __getitem__(self, key: str) -> t.any:\nself.accessed = true\nreturn super().__getitem__(key)\ndef get(self, key: str, default: t.any = none) -> t.any:\nself.accessed = true\nreturn super().get(key, default)\ndef setdefault(self, key: str, default: t.any = none) -> t.any:\nself.accessed = true\nreturn super().setdefault(key, default)\nclass nullsession(securecookiesession):\ndef _fail(self, *args: t.any, **kwargs: t.any) -> t.noreturn:\nraise runtimeerror(\n\"the session is unavailable because no secret \"\n\"key was set.  set the secret_key on the \"\n\"application to something unique and secret.\"\n)\n__setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\ndel _fail\nclass sessioninterface:\nnull_session_class = nullsession\npickle_based = false\ndef make_null_session(self, app: flask) -> nullsession:\nreturn self.null_session_class()\ndef is_null_session(self, obj: object) -> bool:", "\"key was set.  set the secret_key on the \"\n\"application to something unique and secret.\"\n)\n__setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\ndel _fail\nclass sessioninterface:\nnull_session_class = nullsession\npickle_based = false\ndef make_null_session(self, app: flask) -> nullsession:\nreturn self.null_session_class()\ndef is_null_session(self, obj: object) -> bool:\nreturn isinstance(obj, self.null_session_class)\ndef get_cookie_name(self, app: flask) -> str:\nreturn app.config[\"session_cookie_name\"]\ndef get_cookie_domain(self, app: flask) -> str | none:\nreturn app.config[\"session_cookie_domain\"]\ndef get_cookie_path(self, app: flask) -> str:\nreturn app.config[\"session_cookie_path\"] or app.config[\"application_root\"]\ndef get_cookie_httponly(self, app: flask) -> bool:\nreturn app.config[\"session_cookie_httponly\"]\ndef get_cookie_secure(self, app: flask) -> bool:\nreturn app.config[\"session_cookie_secure\"]\ndef get_cookie_samesite(self, app: flask) -> str | none:\nreturn app.config[\"session_cookie_samesite\"]\ndef get_cookie_partitioned(self, app: flask) -> bool:\nreturn app.config[\"session_cookie_partitioned\"]\ndef get_expiration_time(self, app: flask, session: sessionmixin) -> datetime | none:\nif session.permanent:\nreturn datetime.now(timezone.utc) + app.permanent_session_lifetime\nreturn none\ndef should_set_cookie(self, app: flask, session: sessionmixin) -> bool:\nreturn session.modified or (\nsession.permanent and app.config[\"session_refresh_each_request\"]\n)\ndef open_session(self, app: flask, request: request) -> sessionmixin | none:\nraise notimplementederror()\ndef save_session(\nself, app: flask, session: sessionmixin, response: response\n) -> none:\nraise notimplementederror()\nsession_json_serializer = taggedjsonserializer()\ndef _lazy_sha1(string: bytes = b\"\") -> t.any:\nreturn hashlib.sha1(string)\nclass securecookiesessioninterface(sessioninterface):\nsalt = \"cookie-session\"\ndigest_method = staticmethod(_lazy_sha1)\nkey_derivation = \"hmac\"\nserializer = session_json_serializer\nsession_class = securecookiesession", "self, app: flask, session: sessionmixin, response: response\n) -> none:\nraise notimplementederror()\nsession_json_serializer = taggedjsonserializer()\ndef _lazy_sha1(string: bytes = b\"\") -> t.any:\nreturn hashlib.sha1(string)\nclass securecookiesessioninterface(sessioninterface):\nsalt = \"cookie-session\"\ndigest_method = staticmethod(_lazy_sha1)\nkey_derivation = \"hmac\"\nserializer = session_json_serializer\nsession_class = securecookiesession\ndef get_signing_serializer(self, app: flask) -> urlsafetimedserializer | none:\nif not app.secret_key:\nreturn none\nkeys: list[str | bytes] = [app.secret_key]\nif fallbacks := app.config[\"secret_key_fallbacks\"]:\nkeys.extend(fallbacks)\nreturn urlsafetimedserializer(\nkeys,\nsalt=self.salt,\nserializer=self.serializer,\nsigner_kwargs={\n\"key_derivation\": self.key_derivation,\n\"digest_method\": self.digest_method,\n},\n)\ndef open_session(self, app: flask, request: request) -> securecookiesession | none:\ns = self.get_signing_serializer(app)\nif s is none:\nreturn none\nval = request.cookies.get(self.get_cookie_name(app))\nif not val:\nreturn self.session_class()\nmax_age = int(app.permanent_session_lifetime.total_seconds())\ntry:\ndata = s.loads(val, max_age=max_age)\nreturn self.session_class(data)\nexcept badsignature:\nreturn self.session_class()\ndef save_session(\nself, app: flask, session: sessionmixin, response: response\n) -> none:\nname = self.get_cookie_name(app)\ndomain = self.get_cookie_domain(app)\npath = self.get_cookie_path(app)\nsecure = self.get_cookie_secure(app)\npartitioned = self.get_cookie_partitioned(app)\nsamesite = self.get_cookie_samesite(app)\nhttponly = self.get_cookie_httponly(app)\nif session.accessed:\nresponse.vary.add(\"cookie\")\nif not session:\nif session.modified:\nresponse.delete_cookie(\nname,\ndomain=domain,\npath=path,\nsecure=secure,\npartitioned=partitioned,\nsamesite=samesite,\nhttponly=httponly,\n)\nresponse.vary.add(\"cookie\")\nreturn\nif not self.should_set_cookie(app, session):\nreturn\nexpires = self.get_expiration_time(app, session)\nval = self.get_signing_serializer(app).dumps(dict(session))\nresponse.set_cookie(\nname,\nval,\nexpires=expires,", "response.delete_cookie(\nname,\ndomain=domain,\npath=path,\nsecure=secure,\npartitioned=partitioned,\nsamesite=samesite,\nhttponly=httponly,\n)\nresponse.vary.add(\"cookie\")\nreturn\nif not self.should_set_cookie(app, session):\nreturn\nexpires = self.get_expiration_time(app, session)\nval = self.get_signing_serializer(app).dumps(dict(session))\nresponse.set_cookie(\nname,\nval,\nexpires=expires,\nhttponly=httponly,\ndomain=domain,\npath=path,\nsecure=secure,\npartitioned=partitioned,\nsamesite=samesite,\n)\nresponse.vary.add(\"cookie\")", "import functools\nfrom flask import blueprint\nfrom flask import flash\nfrom flask import g\nfrom flask import redirect\nfrom flask import render_template\nfrom flask import request\nfrom flask import session\nfrom flask import url_for\nfrom werkzeug.security import check_password_hash\nfrom werkzeug.security import generate_password_hash\nfrom .db import get_db\nbp = blueprint(\"auth\", __name__, url_prefix=\"/auth\")\ndef login_required(view):\n@functools.wraps(view)\ndef wrapped_view(**kwargs):\nif g.user is none:\nreturn redirect(url_for(\"auth.login\"))\nreturn view(**kwargs)\nreturn wrapped_view\n@bp.before_app_request\ndef load_logged_in_user():\nuser_id = session.get(\"user_id\")\nif user_id is none:\ng.user = none\nelse:\ng.user = (\nget_db().execute(\"select * from user where id = ?\", (user_id,)).fetchone()\n)\n@bp.route(\"/register\", methods=(\"get\", \"post\"))\ndef register():\nif request.method == \"post\":\nusername = request.form[\"username\"]\npassword = request.form[\"password\"]\ndb = get_db()\nerror = none\nif not username:\nerror = \"username is required.\"\nelif not password:\nerror = \"password is required.\"\nif error is none:\ntry:\ndb.execute(\n\"insert into user (username, password) values (?, ?)\",\n(username, generate_password_hash(password)),\n)\ndb.commit()\nexcept db.integrityerror:\nerror = f\"user {username} is already registered.\"\nelse:\nreturn redirect(url_for(\"auth.login\"))\nflash(error)\nreturn render_template(\"auth/register.html\")\n@bp.route(\"/login\", methods=(\"get\", \"post\"))\ndef login():\nif request.method == \"post\":\nusername = request.form[\"username\"]\npassword = request.form[\"password\"]\ndb = get_db()\nerror = none\nuser = db.execute(\n\"select * from user where username = ?\", (username,)\n).fetchone()\nif user is none:\nerror = \"incorrect username.\"\nelif not check_password_hash(user[\"password\"], password):\nerror = \"incorrect password.\"\nif error is none:\nsession.clear()\nsession[\"user_id\"] = user[\"id\"]\nreturn redirect(url_for(\"index\"))\nflash(error)\nreturn render_template(\"auth/login.html\")\n@bp.route(\"/logout\")\ndef logout():\nsession.clear()\nreturn redirect(url_for(\"index\"))", "from flask import flask\napp1 = flask(\"app1\")\napp2 = flask(\"app2\")", "from io import stringio\nimport flask\ndef test_suppressed_exception_logging():\nclass suppressedflask(flask.flask):\ndef log_exception(self, exc_info):\npass\nout = stringio()\napp = suppressedflask(__name__)\n@app.route(\"/\")\ndef index():\nraise exception(\"test\")\nrv = app.test_client().get(\"/\", errors_stream=out)\nassert rv.status_code == 500\nassert b\"internal server error\" in rv.data\nassert not out.getvalue()", "import json\nimport os\nimport pytest\nimport flask\ntest_key = \"foo\"\nsecret_key = \"config\"\ndef common_object_test(app):\nassert app.secret_key == \"config\"\nassert app.config[\"test_key\"] == \"foo\"\nassert \"testconfig\" not in app.config\ndef test_config_from_pyfile():\napp = flask.flask(__name__)\napp.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\ncommon_object_test(app)\ndef test_config_from_object():\napp = flask.flask(__name__)\napp.config.from_object(__name__)\ncommon_object_test(app)\ndef test_config_from_file_json():\napp = flask.flask(__name__)\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\napp.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\ncommon_object_test(app)\ndef test_config_from_file_toml():\ntomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\napp = flask.flask(__name__)\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\napp.config.from_file(\nos.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=false\n)\ncommon_object_test(app)\ndef test_from_prefixed_env(monkeypatch):\nmonkeypatch.setenv(\"flask_string\", \"value\")\nmonkeypatch.setenv(\"flask_bool\", \"true\")\nmonkeypatch.setenv(\"flask_int\", \"1\")\nmonkeypatch.setenv(\"flask_float\", \"1.2\")\nmonkeypatch.setenv(\"flask_list\", \"[1, 2]\")\nmonkeypatch.setenv(\"flask_dict\", '{\"k\": \"v\"}')\nmonkeypatch.setenv(\"not_flask_other\", \"other\")\napp = flask.flask(__name__)\napp.config.from_prefixed_env()\nassert app.config[\"string\"] == \"value\"\nassert app.config[\"bool\"] is true\nassert app.config[\"int\"] == 1\nassert app.config[\"float\"] == 1.2\nassert app.config[\"list\"] == [1, 2]\nassert app.config[\"dict\"] == {\"k\": \"v\"}\nassert \"other\" not in app.config\ndef test_from_prefixed_env_custom_prefix(monkeypatch):\nmonkeypatch.setenv(\"flask_a\", \"a\")\nmonkeypatch.setenv(\"not_flask_a\", \"b\")\napp = flask.flask(__name__)", "assert app.config[\"float\"] == 1.2\nassert app.config[\"list\"] == [1, 2]\nassert app.config[\"dict\"] == {\"k\": \"v\"}\nassert \"other\" not in app.config\ndef test_from_prefixed_env_custom_prefix(monkeypatch):\nmonkeypatch.setenv(\"flask_a\", \"a\")\nmonkeypatch.setenv(\"not_flask_a\", \"b\")\napp = flask.flask(__name__)\napp.config.from_prefixed_env(\"not_flask\")\nassert app.config[\"a\"] == \"b\"\ndef test_from_prefixed_env_nested(monkeypatch):\nmonkeypatch.setenv(\"flask_exist__ok\", \"other\")\nmonkeypatch.setenv(\"flask_exist__inner__ik\", \"2\")\nmonkeypatch.setenv(\"flask_exist__new__more\", '{\"k\": false}')\nmonkeypatch.setenv(\"flask_new__k\", \"v\")\napp = flask.flask(__name__)\napp.config[\"exist\"] = {\"ok\": \"value\", \"flag\": true, \"inner\": {\"ik\": 1}}\napp.config.from_prefixed_env()\nif os.name != \"nt\":\nassert app.config[\"exist\"] == {\n\"ok\": \"other\",\n\"flag\": true,\n\"inner\": {\"ik\": 2},\n\"new\": {\"more\": {\"k\": false}},\n}\nelse:\nassert app.config[\"exist\"] == {\n\"ok\": \"value\",\n\"ok\": \"other\",\n\"flag\": true,\n\"inner\": {\"ik\": 1},\n\"inner\": {\"ik\": 2},\n\"new\": {\"more\": {\"k\": false}},\n}\nassert app.config[\"new\"] == {\"k\": \"v\"}\ndef test_config_from_mapping():\napp = flask.flask(__name__)\napp.config.from_mapping({\"secret_key\": \"config\", \"test_key\": \"foo\"})\ncommon_object_test(app)\napp = flask.flask(__name__)\napp.config.from_mapping([(\"secret_key\", \"config\"), (\"test_key\", \"foo\")])\ncommon_object_test(app)\napp = flask.flask(__name__)\napp.config.from_mapping(secret_key=\"config\", test_key=\"foo\")\ncommon_object_test(app)\napp = flask.flask(__name__)\napp.config.from_mapping(secret_key=\"config\", test_key=\"foo\", skip_key=\"skip\")\ncommon_object_test(app)\napp = flask.flask(__name__)\nwith pytest.raises(typeerror):\napp.config.from_mapping({}, {})\ndef test_config_from_class():\nclass base:\ntest_key = \"foo\"", "common_object_test(app)\napp = flask.flask(__name__)\napp.config.from_mapping(secret_key=\"config\", test_key=\"foo\")\ncommon_object_test(app)\napp = flask.flask(__name__)\napp.config.from_mapping(secret_key=\"config\", test_key=\"foo\", skip_key=\"skip\")\ncommon_object_test(app)\napp = flask.flask(__name__)\nwith pytest.raises(typeerror):\napp.config.from_mapping({}, {})\ndef test_config_from_class():\nclass base:\ntest_key = \"foo\"\nclass test(base):\nsecret_key = \"config\"\napp = flask.flask(__name__)\napp.config.from_object(test)\ncommon_object_test(app)\ndef test_config_from_envvar(monkeypatch):\nmonkeypatch.setattr(\"os.environ\", {})\napp = flask.flask(__name__)\nwith pytest.raises(runtimeerror) as e:\napp.config.from_envvar(\"foo_settings\")\nassert \"'foo_settings' is not set\" in str(e.value)\nassert not app.config.from_envvar(\"foo_settings\", silent=true)\nmonkeypatch.setattr(\n\"os.environ\", {\"foo_settings\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n)\nassert app.config.from_envvar(\"foo_settings\")\ncommon_object_test(app)\ndef test_config_from_envvar_missing(monkeypatch):\nmonkeypatch.setattr(\"os.environ\", {\"foo_settings\": \"missing.cfg\"})\napp = flask.flask(__name__)\nwith pytest.raises(ioerror) as e:\napp.config.from_envvar(\"foo_settings\")\nmsg = str(e.value)\nassert msg.startswith(\n\"[errno 2] unable to load configuration file (no such file or directory):\"\n)\nassert msg.endswith(\"missing.cfg'\")\nassert not app.config.from_envvar(\"foo_settings\", silent=true)\ndef test_config_missing():\napp = flask.flask(__name__)\nwith pytest.raises(ioerror) as e:\napp.config.from_pyfile(\"missing.cfg\")\nmsg = str(e.value)\nassert msg.startswith(\n\"[errno 2] unable to load configuration file (no such file or directory):\"\n)\nassert msg.endswith(\"missing.cfg'\")\nassert not app.config.from_pyfile(\"missing.cfg\", silent=true)\ndef test_config_missing_file():\napp = flask.flask(__name__)\nwith pytest.raises(ioerror) as e:\napp.config.from_file(\"missing.json\", load=json.load)\nmsg = str(e.value)\nassert msg.startswith(\n\"[errno 2] unable to load configuration file (no such file or directory):\"\n)\nassert msg.endswith(\"missing.json'\")", ")\nassert msg.endswith(\"missing.cfg'\")\nassert not app.config.from_pyfile(\"missing.cfg\", silent=true)\ndef test_config_missing_file():\napp = flask.flask(__name__)\nwith pytest.raises(ioerror) as e:\napp.config.from_file(\"missing.json\", load=json.load)\nmsg = str(e.value)\nassert msg.startswith(\n\"[errno 2] unable to load configuration file (no such file or directory):\"\n)\nassert msg.endswith(\"missing.json'\")\nassert not app.config.from_file(\"missing.json\", load=json.load, silent=true)\ndef test_custom_config_class():\nclass config(flask.config):\npass\nclass flask(flask.flask):\nconfig_class = config\napp = flask(__name__)\nassert isinstance(app.config, config)\napp.config.from_object(__name__)\ncommon_object_test(app)\ndef test_session_lifetime():\napp = flask.flask(__name__)\napp.config[\"permanent_session_lifetime\"] = 42\nassert app.permanent_session_lifetime.seconds == 42\ndef test_get_namespace():\napp = flask.flask(__name__)\napp.config[\"foo_option_1\"] = \"foo option 1\"\napp.config[\"foo_option_2\"] = \"foo option 2\"\napp.config[\"bar_stuff_1\"] = \"bar stuff 1\"\napp.config[\"bar_stuff_2\"] = \"bar stuff 2\"\nfoo_options = app.config.get_namespace(\"foo_\")\nassert 2 == len(foo_options)\nassert \"foo option 1\" == foo_options[\"option_1\"]\nassert \"foo option 2\" == foo_options[\"option_2\"]\nbar_options = app.config.get_namespace(\"bar_\", lowercase=false)\nassert 2 == len(bar_options)\nassert \"bar stuff 1\" == bar_options[\"stuff_1\"]\nassert \"bar stuff 2\" == bar_options[\"stuff_2\"]\nfoo_options = app.config.get_namespace(\"foo_\", trim_namespace=false)\nassert 2 == len(foo_options)\nassert \"foo option 1\" == foo_options[\"foo_option_1\"]\nassert \"foo option 2\" == foo_options[\"foo_option_2\"]\nbar_options = app.config.get_namespace(\n\"bar_\", lowercase=false, trim_namespace=false\n)\nassert 2 == len(bar_options)\nassert \"bar stuff 1\" == bar_options[\"bar_stuff_1\"]\nassert \"bar stuff 2\" == bar_options[\"bar_stuff_2\"]\n@pytest.mark.parametrize(\"encoding\", [\"utf-8\", \"iso-8859-15\", \"latin-1\"])", "assert \"foo option 2\" == foo_options[\"foo_option_2\"]\nbar_options = app.config.get_namespace(\n\"bar_\", lowercase=false, trim_namespace=false\n)\nassert 2 == len(bar_options)\nassert \"bar stuff 1\" == bar_options[\"bar_stuff_1\"]\nassert \"bar stuff 2\" == bar_options[\"bar_stuff_2\"]\n@pytest.mark.parametrize(\"encoding\", [\"utf-8\", \"iso-8859-15\", \"latin-1\"])\ndef test_from_pyfile_weird_encoding(tmp_path, encoding):\nf = tmp_path / \"my_config.py\"\nf.write_text(f'\napp = flask.flask(__name__)\napp.config.from_pyfile(os.fspath(f))\nvalue = app.config[\"test_value\"]\nassert value == \"f\u00f6\u00f6\"", "from celery.result import asyncresult\nfrom flask import blueprint\nfrom flask import request\nfrom . import tasks\nbp = blueprint(\"tasks\", __name__, url_prefix=\"/tasks\")\n@bp.get(\"/result/<id>\")\ndef result(id: str) -> dict[str, object]:\nresult = asyncresult(id)\nready = result.ready()\nreturn {\n\"ready\": ready,\n\"successful\": result.successful() if ready else none,\n\"value\": result.get() if ready else result.result,\n}\n@bp.post(\"/add\")\ndef add() -> dict[str, object]:\na = request.form.get(\"a\", type=int)\nb = request.form.get(\"b\", type=int)\nresult = tasks.add.delay(a, b)\nreturn {\"result_id\": result.id}\n@bp.post(\"/block\")\ndef block() -> dict[str, object]:\nresult = tasks.block.delay()\nreturn {\"result_id\": result.id}\n@bp.post(\"/process\")\ndef process() -> dict[str, object]:\nresult = tasks.process.delay(total=request.form.get(\"total\", type=int))\nreturn {\"result_id\": result.id}", "from flask import flask\napp = flask(__name__)\nfrom js_example import views", "from flask import flask\napp = flask(__name__)", "import os\nfrom flask import flask\ndef create_app(test_config=none):\napp = flask(__name__, instance_relative_config=true)\napp.config.from_mapping(\nsecret_key=\"dev\",\ndatabase=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n)\nif test_config is none:\napp.config.from_pyfile(\"config.py\", silent=true)\nelse:\napp.config.update(test_config)\ntry:\nos.makedirs(app.instance_path)\nexcept oserror:\npass\n@app.route(\"/hello\")\ndef hello():\nreturn \"hello, world!\"\nfrom . import db\ndb.init_app(app)\nfrom . import auth\nfrom . import blog\napp.register_blueprint(auth.bp)\napp.register_blueprint(blog.bp)\napp.add_url_rule(\"/\", endpoint=\"index\")\nreturn app", "from __future__ import annotations\nimport dataclasses\nimport decimal\nimport json\nimport typing as t\nimport uuid\nimport weakref\nfrom datetime import date\nfrom werkzeug.http import http_date\nif t.type_checking:\nfrom werkzeug.sansio.response import response\nfrom ..sansio.app import app\nclass jsonprovider:\ndef __init__(self, app: app) -> none:\nself._app: app = weakref.proxy(app)\ndef dumps(self, obj: t.any, **kwargs: t.any) -> str:\nraise notimplementederror\ndef dump(self, obj: t.any, fp: t.io[str], **kwargs: t.any) -> none:\nfp.write(self.dumps(obj, **kwargs))\ndef loads(self, s: str | bytes, **kwargs: t.any) -> t.any:\nraise notimplementederror\ndef load(self, fp: t.io[t.anystr], **kwargs: t.any) -> t.any:\nreturn self.loads(fp.read(), **kwargs)\ndef _prepare_response_obj(\nself, args: tuple[t.any, ...], kwargs: dict[str, t.any]\n) -> t.any:\nif args and kwargs:\nraise typeerror(\"app.json.response() takes either args or kwargs, not both\")\nif not args and not kwargs:\nreturn none\nif len(args) == 1:\nreturn args[0]\nreturn args or kwargs\ndef response(self, *args: t.any, **kwargs: t.any) -> response:\nobj = self._prepare_response_obj(args, kwargs)\nreturn self._app.response_class(self.dumps(obj), mimetype=\"application/json\")\ndef _default(o: t.any) -> t.any:\nif isinstance(o, date):\nreturn http_date(o)\nif isinstance(o, (decimal.decimal, uuid.uuid)):\nreturn str(o)\nif dataclasses and dataclasses.is_dataclass(o):\nreturn dataclasses.asdict(o)\nif hasattr(o, \"__html__\"):\nreturn str(o.__html__())\nraise typeerror(f\"object of type {type(o).__name__} is not json serializable\")\nclass defaultjsonprovider(jsonprovider):\ndefault: t.callable[[t.any], t.any] = staticmethod(_default)\nensure_ascii = true\nsort_keys = true\ncompact: bool | none = none\nmimetype = \"application/json\"\ndef dumps(self, obj: t.any, **kwargs: t.any) -> str:\nkwargs.setdefault(\"default\", self.default)\nkwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)", "class defaultjsonprovider(jsonprovider):\ndefault: t.callable[[t.any], t.any] = staticmethod(_default)\nensure_ascii = true\nsort_keys = true\ncompact: bool | none = none\nmimetype = \"application/json\"\ndef dumps(self, obj: t.any, **kwargs: t.any) -> str:\nkwargs.setdefault(\"default\", self.default)\nkwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\nkwargs.setdefault(\"sort_keys\", self.sort_keys)\nreturn json.dumps(obj, **kwargs)\ndef loads(self, s: str | bytes, **kwargs: t.any) -> t.any:\nreturn json.loads(s, **kwargs)\ndef response(self, *args: t.any, **kwargs: t.any) -> response:\nobj = self._prepare_response_obj(args, kwargs)\ndump_args: dict[str, t.any] = {}\nif (self.compact is none and self._app.debug) or self.compact is false:\ndump_args.setdefault(\"indent\", 2)\nelse:\ndump_args.setdefault(\"separators\", (\",\", \":\"))\nreturn self._app.response_class(\nf\"{self.dumps(obj, **dump_args)}\\n\", mimetype=self.mimetype\n)", "from flask import blueprint\nfrom flask import render_template\nfrontend = blueprint(\"frontend\", __name__, template_folder=\"templates\")\n@frontend.route(\"/\")\ndef index():\nreturn render_template(\"frontend/index.html\")\n@frontend.route(\"/missing\")\ndef missing_template():\nreturn render_template(\"missing_template.html\")", "from flaskr import create_app\ndef test_config():\nassert not create_app().testing\nassert create_app({\"testing\": true}).testing\ndef test_hello(client):\nresponse = client.get(\"/hello\")\nassert response.data == b\"hello, world!\"", "import pytest\nfrom flask import template_rendered\n@pytest.mark.parametrize(\n(\"path\", \"template_name\"),\n(\n(\"/\", \"fetch.html\"),\n(\"/plain\", \"xhr.html\"),\n(\"/fetch\", \"fetch.html\"),\n(\"/jquery\", \"jquery.html\"),\n),\n)\ndef test_index(app, client, path, template_name):\ndef check(sender, template, context):\nassert template.name == template_name\nwith template_rendered.connected_to(check, app):\nclient.get(path)\n@pytest.mark.parametrize(\n(\"a\", \"b\", \"result\"), ((2, 3, 5), (2.5, 3, 5.5), (2, none, 2), (2, \"b\", 2))\n)\ndef test_add(client, a, b, result):\nresponse = client.post(\"/add\", data={\"a\": a, \"b\": b})\nassert response.get_json()[\"result\"] == result", "from __future__ import annotations\nimport logging\nimport sys\nimport typing as t\nfrom werkzeug.local import localproxy\nfrom .globals import request\nif t.type_checking:\nfrom .sansio.app import app\n@localproxy\ndef wsgi_errors_stream() -> t.textio:\nif request:\nreturn request.environ[\"wsgi.errors\"]\nreturn sys.stderr\ndef has_level_handler(logger: logging.logger) -> bool:\nlevel = logger.geteffectivelevel()\ncurrent = logger\nwhile current:\nif any(handler.level <= level for handler in current.handlers):\nreturn true\nif not current.propagate:\nbreak\ncurrent = current.parent\nreturn false\ndefault_handler = logging.streamhandler(wsgi_errors_stream)\ndefault_handler.setformatter(\nlogging.formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\ndef create_logger(app: app) -> logging.logger:\nlogger = logging.getlogger(app.name)\nif app.debug and not logger.level:\nlogger.setlevel(logging.debug)\nif not has_level_handler(logger):\nlogger.addhandler(default_handler)\nreturn logger", "import gc\nimport re\nimport typing as t\nimport uuid\nimport warnings\nimport weakref\nfrom contextlib import nullcontext\nfrom datetime import datetime\nfrom datetime import timezone\nfrom platform import python_implementation\nimport pytest\nimport werkzeug.serving\nfrom markupsafe import markup\nfrom werkzeug.exceptions import badrequest\nfrom werkzeug.exceptions import forbidden\nfrom werkzeug.exceptions import notfound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import builderror\nfrom werkzeug.routing import requestredirect\nimport flask\nrequire_cpython_gc = pytest.mark.skipif(\npython_implementation() != \"cpython\",\nreason=\"requires cpython gc behavior\",\n)\ndef test_options_work(app, client):\n@app.route(\"/\", methods=[\"get\", \"post\"])\ndef index():\nreturn \"hello world\"\nrv = client.open(\"/\", method=\"options\")\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\", \"post\"]\nassert rv.data == b\"\"\ndef test_options_on_multiple_rules(app, client):\n@app.route(\"/\", methods=[\"get\", \"post\"])\ndef index():\nreturn \"hello world\"\n@app.route(\"/\", methods=[\"put\"])\ndef index_put():\nreturn \"aha!\"\nrv = client.open(\"/\", method=\"options\")\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\", \"post\", \"put\"]\n@pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\ndef test_method_route(app, client, method):\nmethod_route = getattr(app, method)\nclient_method = getattr(client, method)\n@method_route(\"/\")\ndef hello():\nreturn \"hello\"\nassert client_method(\"/\").data == b\"hello\"\ndef test_method_route_no_methods(app):\nwith pytest.raises(typeerror):\napp.get(\"/\", methods=[\"get\", \"post\"])\ndef test_provide_automatic_options_attr():\napp = flask.flask(__name__)\ndef index():\nreturn \"hello world!\"\nindex.provide_automatic_options = false\napp.route(\"/\")(index)\nrv = app.test_client().open(\"/\", method=\"options\")\nassert rv.status_code == 405\napp = flask.flask(__name__)\ndef index2():\nreturn \"hello world!\"\nindex2.provide_automatic_options = true\napp.route(\"/\", methods=[\"options\"])(index2)\nrv = app.test_client().open(\"/\", method=\"options\")\nassert sorted(rv.allow) == [\"options\"]\ndef test_provide_automatic_options_kwarg(app, client):\ndef index():\nreturn flask.request.method\ndef more():", "assert rv.status_code == 405\napp = flask.flask(__name__)\ndef index2():\nreturn \"hello world!\"\nindex2.provide_automatic_options = true\napp.route(\"/\", methods=[\"options\"])(index2)\nrv = app.test_client().open(\"/\", method=\"options\")\nassert sorted(rv.allow) == [\"options\"]\ndef test_provide_automatic_options_kwarg(app, client):\ndef index():\nreturn flask.request.method\ndef more():\nreturn flask.request.method\napp.add_url_rule(\"/\", view_func=index, provide_automatic_options=false)\napp.add_url_rule(\n\"/more\",\nview_func=more,\nmethods=[\"get\", \"post\"],\nprovide_automatic_options=false,\n)\nassert client.get(\"/\").data == b\"get\"\nrv = client.post(\"/\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\"]\nrv = client.open(\"/\", method=\"options\")\nassert rv.status_code == 405\nrv = client.head(\"/\")\nassert rv.status_code == 200\nassert not rv.data\nassert client.post(\"/more\").data == b\"post\"\nassert client.get(\"/more\").data == b\"get\"\nrv = client.delete(\"/more\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"post\"]\nrv = client.open(\"/more\", method=\"options\")\nassert rv.status_code == 405\ndef test_request_dispatching(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.request.method\n@app.route(\"/more\", methods=[\"get\", \"post\"])\ndef more():\nreturn flask.request.method\nassert client.get(\"/\").data == b\"get\"\nrv = client.post(\"/\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\"]\nrv = client.head(\"/\")\nassert rv.status_code == 200\nassert not rv.data\nassert client.post(\"/more\").data == b\"post\"\nassert client.get(\"/more\").data == b\"get\"\nrv = client.delete(\"/more\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\", \"post\"]\ndef test_disallow_string_for_allowed_methods(app):\nwith pytest.raises(typeerror):\napp.add_url_rule(\"/\", methods=\"get post\", endpoint=\"test\")\ndef test_url_mapping(app, client):\nrandom_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\ndef index():", "assert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\", \"post\"]\ndef test_disallow_string_for_allowed_methods(app):\nwith pytest.raises(typeerror):\napp.add_url_rule(\"/\", methods=\"get post\", endpoint=\"test\")\ndef test_url_mapping(app, client):\nrandom_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\ndef index():\nreturn flask.request.method\ndef more():\nreturn flask.request.method\ndef options():\nreturn random_uuid4\napp.add_url_rule(\"/\", \"index\", index)\napp.add_url_rule(\"/more\", \"more\", more, methods=[\"get\", \"post\"])\napp.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\nassert client.get(\"/\").data == b\"get\"\nrv = client.post(\"/\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\"]\nrv = client.head(\"/\")\nassert rv.status_code == 200\nassert not rv.data\nassert client.post(\"/more\").data == b\"post\"\nassert client.get(\"/more\").data == b\"get\"\nrv = client.delete(\"/more\")\nassert rv.status_code == 405\nassert sorted(rv.allow) == [\"get\", \"head\", \"options\", \"post\"]\nrv = client.open(\"/options\", method=\"options\")\nassert rv.status_code == 200\nassert random_uuid4 in rv.data.decode(\"utf-8\")\ndef test_werkzeug_routing(app, client):\nfrom werkzeug.routing import rule\nfrom werkzeug.routing import submount\napp.url_map.add(\nsubmount(\"/foo\", [rule(\"/bar\", endpoint=\"bar\"), rule(\"/\", endpoint=\"index\")])\n)\ndef bar():\nreturn \"bar\"\ndef index():\nreturn \"index\"\napp.view_functions[\"bar\"] = bar\napp.view_functions[\"index\"] = index\nassert client.get(\"/foo/\").data == b\"index\"\nassert client.get(\"/foo/bar\").data == b\"bar\"\ndef test_endpoint_decorator(app, client):\nfrom werkzeug.routing import rule\nfrom werkzeug.routing import submount\napp.url_map.add(\nsubmount(\"/foo\", [rule(\"/bar\", endpoint=\"bar\"), rule(\"/\", endpoint=\"index\")])\n)\n@app.endpoint(\"bar\")\ndef bar():\nreturn \"bar\"\n@app.endpoint(\"index\")\ndef index():\nreturn \"index\"\nassert client.get(\"/foo/\").data == b\"index\"", "assert client.get(\"/foo/bar\").data == b\"bar\"\ndef test_endpoint_decorator(app, client):\nfrom werkzeug.routing import rule\nfrom werkzeug.routing import submount\napp.url_map.add(\nsubmount(\"/foo\", [rule(\"/bar\", endpoint=\"bar\"), rule(\"/\", endpoint=\"index\")])\n)\n@app.endpoint(\"bar\")\ndef bar():\nreturn \"bar\"\n@app.endpoint(\"index\")\ndef index():\nreturn \"index\"\nassert client.get(\"/foo/\").data == b\"index\"\nassert client.get(\"/foo/bar\").data == b\"bar\"\ndef test_session(app, client):\n@app.route(\"/set\", methods=[\"post\"])\ndef set():\nassert not flask.session.accessed\nassert not flask.session.modified\nflask.session[\"value\"] = flask.request.form[\"value\"]\nassert flask.session.accessed\nassert flask.session.modified\nreturn \"value set\"\n@app.route(\"/get\")\ndef get():\nassert not flask.session.accessed\nassert not flask.session.modified\nv = flask.session.get(\"value\", \"none\")\nassert flask.session.accessed\nassert not flask.session.modified\nreturn v\nassert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\nassert client.get(\"/get\").data == b\"42\"\ndef test_session_path(app, client):\napp.config.update(application_root=\"/foo\")\n@app.route(\"/\")\ndef index():\nflask.session[\"testing\"] = 42\nreturn \"hello world\"\nrv = client.get(\"/\", \"http:\nassert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()\ndef test_session_using_application_root(app, client):\nclass prefixpathmiddleware:\ndef __init__(self, app, prefix):\nself.app = app\nself.prefix = prefix\ndef __call__(self, environ, start_response):\nenviron[\"script_name\"] = self.prefix\nreturn self.app(environ, start_response)\napp.wsgi_app = prefixpathmiddleware(app.wsgi_app, \"/bar\")\napp.config.update(application_root=\"/bar\")\n@app.route(\"/\")\ndef index():\nflask.session[\"testing\"] = 42\nreturn \"hello world\"\nrv = client.get(\"/\", \"http:\nassert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()\ndef test_session_using_session_settings(app, client):\napp.config.update(\nserver_name=\"www.example.com:8080\",\napplication_root=\"/test\",\nsession_cookie_domain=\".example.com\",\nsession_cookie_httponly=false,\nsession_cookie_secure=true,\nsession_cookie_partitioned=true,\nsession_cookie_samesite=\"lax\",", "return \"hello world\"\nrv = client.get(\"/\", \"http:\nassert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()\ndef test_session_using_session_settings(app, client):\napp.config.update(\nserver_name=\"www.example.com:8080\",\napplication_root=\"/test\",\nsession_cookie_domain=\".example.com\",\nsession_cookie_httponly=false,\nsession_cookie_secure=true,\nsession_cookie_partitioned=true,\nsession_cookie_samesite=\"lax\",\nsession_cookie_path=\"/\",\n)\n@app.route(\"/\")\ndef index():\nflask.session[\"testing\"] = 42\nreturn \"hello world\"\n@app.route(\"/clear\")\ndef clear():\nflask.session.pop(\"testing\", none)\nreturn \"goodbye world\"\nrv = client.get(\"/\", \"http:\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\nassert \"path=/\" in cookie\nassert \"secure\" in cookie\nassert \"httponly\" not in cookie\nassert \"samesite\" in cookie\nassert \"partitioned\" in cookie\nrv = client.get(\"/clear\", \"http:\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"session=;\" in cookie\nassert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\nassert \"path=/\" in cookie\nassert \"secure\" in cookie\nassert \"samesite\" in cookie\nassert \"partitioned\" in cookie\ndef test_session_using_samesite_attribute(app, client):\n@app.route(\"/\")\ndef index():\nflask.session[\"testing\"] = 42\nreturn \"hello world\"\napp.config.update(session_cookie_samesite=\"invalid\")\nwith pytest.raises(valueerror):\nclient.get(\"/\")\napp.config.update(session_cookie_samesite=none)\nrv = client.get(\"/\")\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"samesite\" not in cookie\napp.config.update(session_cookie_samesite=\"strict\")\nrv = client.get(\"/\")\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"samesite=strict\" in cookie\napp.config.update(session_cookie_samesite=\"lax\")\nrv = client.get(\"/\")\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"samesite=lax\" in cookie\ndef test_missing_session(app):\napp.secret_key = none\ndef expect_exception(f, *args, **kwargs):\ne = pytest.raises(runtimeerror, f, *args, **kwargs)", "cookie = rv.headers[\"set-cookie\"].lower()\nassert \"samesite=strict\" in cookie\napp.config.update(session_cookie_samesite=\"lax\")\nrv = client.get(\"/\")\ncookie = rv.headers[\"set-cookie\"].lower()\nassert \"samesite=lax\" in cookie\ndef test_missing_session(app):\napp.secret_key = none\ndef expect_exception(f, *args, **kwargs):\ne = pytest.raises(runtimeerror, f, *args, **kwargs)\nassert e.value.args and \"session is unavailable\" in e.value.args[0]\nwith app.test_request_context():\nassert flask.session.get(\"missing_key\") is none\nexpect_exception(flask.session.__setitem__, \"foo\", 42)\nexpect_exception(flask.session.pop, \"foo\")\ndef test_session_secret_key_fallbacks(app, client) -> none:\n@app.post(\"/\")\ndef set_session() -> str:\nflask.session[\"a\"] = 1\nreturn \"\"\n@app.get(\"/\")\ndef get_session() -> dict[str, t.any]:\nreturn dict(flask.session)\nclient.post()\nassert client.get().json == {\"a\": 1}\napp.secret_key = \"new test key\"\nassert client.get().json == {}\napp.config[\"secret_key_fallbacks\"] = [\"test key\"]\nassert client.get().json == {\"a\": 1}\ndef test_session_expiration(app, client):\npermanent = true\n@app.route(\"/\")\ndef index():\nflask.session[\"test\"] = 42\nflask.session.permanent = permanent\nreturn \"\"\n@app.route(\"/test\")\ndef test():\nreturn str(flask.session.permanent)\nrv = client.get(\"/\")\nassert \"set-cookie\" in rv.headers\nmatch = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\nexpires = parse_date(match.group())\nexpected = datetime.now(timezone.utc) + app.permanent_session_lifetime\nassert expires.year == expected.year\nassert expires.month == expected.month\nassert expires.day == expected.day\nrv = client.get(\"/test\")\nassert rv.data == b\"true\"\npermanent = false\nrv = client.get(\"/\")\nassert \"set-cookie\" in rv.headers\nmatch = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\nassert match is none\ndef test_session_stored_last(app, client):\n@app.after_request\ndef modify_session(response):\nflask.session[\"foo\"] = 42\nreturn response\n@app.route(\"/\")\ndef dump_session_contents():", "rv = client.get(\"/test\")\nassert rv.data == b\"true\"\npermanent = false\nrv = client.get(\"/\")\nassert \"set-cookie\" in rv.headers\nmatch = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\nassert match is none\ndef test_session_stored_last(app, client):\n@app.after_request\ndef modify_session(response):\nflask.session[\"foo\"] = 42\nreturn response\n@app.route(\"/\")\ndef dump_session_contents():\nreturn repr(flask.session.get(\"foo\"))\nassert client.get(\"/\").data == b\"none\"\nassert client.get(\"/\").data == b\"42\"\ndef test_session_special_types(app, client):\nnow = datetime.now(timezone.utc).replace(microsecond=0)\nthe_uuid = uuid.uuid4()\n@app.route(\"/\")\ndef dump_session_contents():\nflask.session[\"t\"] = (1, 2, 3)\nflask.session[\"b\"] = b\"\\xff\"\nflask.session[\"m\"] = markup(\"<html>\")\nflask.session[\"u\"] = the_uuid\nflask.session[\"d\"] = now\nflask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\nflask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\nflask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\nreturn \"\", 204\nwith client:\nclient.get(\"/\")\ns = flask.session\nassert s[\"t\"] == (1, 2, 3)\nassert type(s[\"b\"]) is bytes\nassert s[\"b\"] == b\"\\xff\"\nassert type(s[\"m\"]) is markup\nassert s[\"m\"] == markup(\"<html>\")\nassert s[\"u\"] == the_uuid\nassert s[\"d\"] == now\nassert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\nassert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\nassert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\ndef test_session_cookie_setting(app):\nis_permanent = true\n@app.route(\"/bump\")\ndef bump():\nrv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\nflask.session.permanent = is_permanent\nreturn str(rv)\n@app.route(\"/read\")\ndef read():\nreturn str(flask.session.get(\"foo\", 0))\ndef run_test(expect_header):\nwith app.test_client() as c:", "def test_session_cookie_setting(app):\nis_permanent = true\n@app.route(\"/bump\")\ndef bump():\nrv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\nflask.session.permanent = is_permanent\nreturn str(rv)\n@app.route(\"/read\")\ndef read():\nreturn str(flask.session.get(\"foo\", 0))\ndef run_test(expect_header):\nwith app.test_client() as c:\nassert c.get(\"/bump\").data == b\"1\"\nassert c.get(\"/bump\").data == b\"2\"\nassert c.get(\"/bump\").data == b\"3\"\nrv = c.get(\"/read\")\nset_cookie = rv.headers.get(\"set-cookie\")\nassert (set_cookie is not none) == expect_header\nassert rv.data == b\"3\"\nis_permanent = true\napp.config[\"session_refresh_each_request\"] = true\nrun_test(expect_header=true)\nis_permanent = true\napp.config[\"session_refresh_each_request\"] = false\nrun_test(expect_header=false)\nis_permanent = false\napp.config[\"session_refresh_each_request\"] = true\nrun_test(expect_header=false)\nis_permanent = false\napp.config[\"session_refresh_each_request\"] = false\nrun_test(expect_header=false)\ndef test_session_vary_cookie(app, client):\n@app.route(\"/set\")\ndef set_session():\nflask.session[\"test\"] = \"test\"\nreturn \"\"\n@app.route(\"/get\")\ndef get():\nreturn flask.session.get(\"test\")\n@app.route(\"/getitem\")\ndef getitem():\nreturn flask.session[\"test\"]\n@app.route(\"/setdefault\")\ndef setdefault():\nreturn flask.session.setdefault(\"test\", \"default\")\n@app.route(\"/clear\")\ndef clear():\nflask.session.clear()\nreturn \"\"\n@app.route(\"/vary-cookie-header-set\")\ndef vary_cookie_header_set():\nresponse = flask.response()\nresponse.vary.add(\"cookie\")\nflask.session[\"test\"] = \"test\"\nreturn response\n@app.route(\"/vary-header-set\")\ndef vary_header_set():\nresponse = flask.response()\nresponse.vary.update((\"accept-encoding\", \"accept-language\"))\nflask.session[\"test\"] = \"test\"\nreturn response\n@app.route(\"/no-vary-header\")\ndef no_vary_header():\nreturn \"\"\ndef expect(path, header_value=\"cookie\"):\nrv = client.get(path)\nif header_value:\nassert len(rv.headers.get_all(\"vary\")) == 1\nassert rv.headers[\"vary\"] == header_value\nelse:", "def vary_header_set():\nresponse = flask.response()\nresponse.vary.update((\"accept-encoding\", \"accept-language\"))\nflask.session[\"test\"] = \"test\"\nreturn response\n@app.route(\"/no-vary-header\")\ndef no_vary_header():\nreturn \"\"\ndef expect(path, header_value=\"cookie\"):\nrv = client.get(path)\nif header_value:\nassert len(rv.headers.get_all(\"vary\")) == 1\nassert rv.headers[\"vary\"] == header_value\nelse:\nassert \"vary\" not in rv.headers\nexpect(\"/set\")\nexpect(\"/get\")\nexpect(\"/getitem\")\nexpect(\"/setdefault\")\nexpect(\"/clear\")\nexpect(\"/vary-cookie-header-set\")\nexpect(\"/vary-header-set\", \"accept-encoding, accept-language, cookie\")\nexpect(\"/no-vary-header\", none)\ndef test_session_refresh_vary(app, client):\n@app.get(\"/login\")\ndef login():\nflask.session[\"user_id\"] = 1\nflask.session.permanent = true\nreturn \"\"\n@app.get(\"/ignored\")\ndef ignored():\nreturn \"\"\nrv = client.get(\"/login\")\nassert rv.headers[\"vary\"] == \"cookie\"\nrv = client.get(\"/ignored\")\nassert rv.headers[\"vary\"] == \"cookie\"\ndef test_flashes(app, req_ctx):\nassert not flask.session.modified\nflask.flash(\"zap\")\nflask.session.modified = false\nflask.flash(\"zip\")\nassert flask.session.modified\nassert list(flask.get_flashed_messages()) == [\"zap\", \"zip\"]\ndef test_extended_flashing(app):\n@app.route(\"/\")\ndef index():\nflask.flash(\"hello world\")\nflask.flash(\"hello world\", \"error\")\nflask.flash(markup(\"<em>testing</em>\"), \"warning\")\nreturn \"\"\n@app.route(\"/test/\")\ndef test():\nmessages = flask.get_flashed_messages()\nassert list(messages) == [\n\"hello world\",\n\"hello world\",\nmarkup(\"<em>testing</em>\"),\n]\nreturn \"\"\n@app.route(\"/test_with_categories/\")\ndef test_with_categories():\nmessages = flask.get_flashed_messages(with_categories=true)\nassert len(messages) == 3\nassert list(messages) == [\n(\"message\", \"hello world\"),\n(\"error\", \"hello world\"),\n(\"warning\", markup(\"<em>testing</em>\")),\n]\nreturn \"\"\n@app.route(\"/test_filter/\")\ndef test_filter():\nmessages = flask.get_flashed_messages(\ncategory_filter=[\"message\"], with_categories=true\n)\nassert list(messages) == [(\"message\", \"hello world\")]\nreturn \"\"\n@app.route(\"/test_filters/\")\ndef test_filters():", "assert len(messages) == 3\nassert list(messages) == [\n(\"message\", \"hello world\"),\n(\"error\", \"hello world\"),\n(\"warning\", markup(\"<em>testing</em>\")),\n]\nreturn \"\"\n@app.route(\"/test_filter/\")\ndef test_filter():\nmessages = flask.get_flashed_messages(\ncategory_filter=[\"message\"], with_categories=true\n)\nassert list(messages) == [(\"message\", \"hello world\")]\nreturn \"\"\n@app.route(\"/test_filters/\")\ndef test_filters():\nmessages = flask.get_flashed_messages(\ncategory_filter=[\"message\", \"warning\"], with_categories=true\n)\nassert list(messages) == [\n(\"message\", \"hello world\"),\n(\"warning\", markup(\"<em>testing</em>\")),\n]\nreturn \"\"\n@app.route(\"/test_filters_without_returning_categories/\")\ndef test_filters2():\nmessages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\nassert len(messages) == 2\nassert messages[0] == \"hello world\"\nassert messages[1] == markup(\"<em>testing</em>\")\nreturn \"\"\nclient = app.test_client()\nclient.get(\"/\")\nclient.get(\"/test_with_categories/\")\nclient = app.test_client()\nclient.get(\"/\")\nclient.get(\"/test_filter/\")\nclient = app.test_client()\nclient.get(\"/\")\nclient.get(\"/test_filters/\")\nclient = app.test_client()\nclient.get(\"/\")\nclient.get(\"/test_filters_without_returning_categories/\")\ndef test_request_processing(app, client):\nevts = []\n@app.before_request\ndef before_request():\nevts.append(\"before\")\n@app.after_request\ndef after_request(response):\nresponse.data += b\"|after\"\nevts.append(\"after\")\nreturn response\n@app.route(\"/\")\ndef index():\nassert \"before\" in evts\nassert \"after\" not in evts\nreturn \"request\"\nassert \"after\" not in evts\nrv = client.get(\"/\").data\nassert \"after\" in evts\nassert rv == b\"request|after\"\ndef test_request_preprocessing_early_return(app, client):\nevts = []\n@app.before_request\ndef before_request1():\nevts.append(1)\n@app.before_request\ndef before_request2():\nevts.append(2)\nreturn \"hello\"\n@app.before_request\ndef before_request3():\nevts.append(3)\nreturn \"bye\"\n@app.route(\"/\")\ndef index():\nevts.append(\"index\")\nreturn \"damnit\"\nrv = client.get(\"/\").data.strip()\nassert rv == b\"hello\"\nassert evts == [1, 2]\ndef test_after_request_processing(app, client):\n@app.route(\"/\")", "evts.append(1)\n@app.before_request\ndef before_request2():\nevts.append(2)\nreturn \"hello\"\n@app.before_request\ndef before_request3():\nevts.append(3)\nreturn \"bye\"\n@app.route(\"/\")\ndef index():\nevts.append(\"index\")\nreturn \"damnit\"\nrv = client.get(\"/\").data.strip()\nassert rv == b\"hello\"\nassert evts == [1, 2]\ndef test_after_request_processing(app, client):\n@app.route(\"/\")\ndef index():\n@flask.after_this_request\ndef foo(response):\nresponse.headers[\"x-foo\"] = \"a header\"\nreturn response\nreturn \"test\"\nresp = client.get(\"/\")\nassert resp.status_code == 200\nassert resp.headers[\"x-foo\"] == \"a header\"\ndef test_teardown_request_handler(app, client):\ncalled = []\n@app.teardown_request\ndef teardown_request(exc):\ncalled.append(true)\nreturn \"ignored\"\n@app.route(\"/\")\ndef root():\nreturn \"response\"\nrv = client.get(\"/\")\nassert rv.status_code == 200\nassert b\"response\" in rv.data\nassert len(called) == 1\ndef test_teardown_request_handler_debug_mode(app, client):\ncalled = []\n@app.teardown_request\ndef teardown_request(exc):\ncalled.append(true)\nreturn \"ignored\"\n@app.route(\"/\")\ndef root():\nreturn \"response\"\nrv = client.get(\"/\")\nassert rv.status_code == 200\nassert b\"response\" in rv.data\nassert len(called) == 1\ndef test_teardown_request_handler_error(app, client):\ncalled = []\napp.testing = false\n@app.teardown_request\ndef teardown_request1(exc):\nassert type(exc) is zerodivisionerror\ncalled.append(true)\ntry:\nraise typeerror()\nexcept exception:\npass\n@app.teardown_request\ndef teardown_request2(exc):\nassert type(exc) is zerodivisionerror\ncalled.append(true)\ntry:\nraise typeerror()\nexcept exception:\npass\n@app.route(\"/\")\ndef fails():\nraise zerodivisionerror\nrv = client.get(\"/\")\nassert rv.status_code == 500\nassert b\"internal server error\" in rv.data\nassert len(called) == 2\ndef test_before_after_request_order(app, client):\ncalled = []\n@app.before_request\ndef before1():\ncalled.append(1)\n@app.before_request\ndef before2():\ncalled.append(2)\n@app.after_request\ndef after1(response):\ncalled.append(4)\nreturn response\n@app.after_request\ndef after2(response):", "rv = client.get(\"/\")\nassert rv.status_code == 500\nassert b\"internal server error\" in rv.data\nassert len(called) == 2\ndef test_before_after_request_order(app, client):\ncalled = []\n@app.before_request\ndef before1():\ncalled.append(1)\n@app.before_request\ndef before2():\ncalled.append(2)\n@app.after_request\ndef after1(response):\ncalled.append(4)\nreturn response\n@app.after_request\ndef after2(response):\ncalled.append(3)\nreturn response\n@app.teardown_request\ndef finish1(exc):\ncalled.append(6)\n@app.teardown_request\ndef finish2(exc):\ncalled.append(5)\n@app.route(\"/\")\ndef index():\nreturn \"42\"\nrv = client.get(\"/\")\nassert rv.data == b\"42\"\nassert called == [1, 2, 3, 4, 5, 6]\ndef test_error_handling(app, client):\napp.testing = false\n@app.errorhandler(404)\ndef not_found(e):\nreturn \"not found\", 404\n@app.errorhandler(500)\ndef internal_server_error(e):\nreturn \"internal server error\", 500\n@app.errorhandler(forbidden)\ndef forbidden(e):\nreturn \"forbidden\", 403\n@app.route(\"/\")\ndef index():\nflask.abort(404)\n@app.route(\"/error\")\ndef error():\nraise zerodivisionerror\n@app.route(\"/forbidden\")\ndef error2():\nflask.abort(403)\nrv = client.get(\"/\")\nassert rv.status_code == 404\nassert rv.data == b\"not found\"\nrv = client.get(\"/error\")\nassert rv.status_code == 500\nassert b\"internal server error\" == rv.data\nrv = client.get(\"/forbidden\")\nassert rv.status_code == 403\nassert b\"forbidden\" == rv.data\ndef test_error_handling_processing(app, client):\napp.testing = false\n@app.errorhandler(500)\ndef internal_server_error(e):\nreturn \"internal server error\", 500\n@app.route(\"/\")\ndef broken_func():\nraise zerodivisionerror\n@app.after_request\ndef after_request(resp):\nresp.mimetype = \"text/x-special\"\nreturn resp\nresp = client.get(\"/\")\nassert resp.mimetype == \"text/x-special\"\nassert resp.data == b\"internal server error\"\ndef test_baseexception_error_handling(app, client):\napp.testing = false\n@app.route(\"/\")\ndef broken_func():\nraise keyboardinterrupt()\nwith pytest.raises(keyboardinterrupt):\nclient.get(\"/\")\ndef test_before_request_and_routing_errors(app, client):", "raise zerodivisionerror\n@app.after_request\ndef after_request(resp):\nresp.mimetype = \"text/x-special\"\nreturn resp\nresp = client.get(\"/\")\nassert resp.mimetype == \"text/x-special\"\nassert resp.data == b\"internal server error\"\ndef test_baseexception_error_handling(app, client):\napp.testing = false\n@app.route(\"/\")\ndef broken_func():\nraise keyboardinterrupt()\nwith pytest.raises(keyboardinterrupt):\nclient.get(\"/\")\ndef test_before_request_and_routing_errors(app, client):\n@app.before_request\ndef attach_something():\nflask.g.something = \"value\"\n@app.errorhandler(404)\ndef return_something(error):\nreturn flask.g.something, 404\nrv = client.get(\"/\")\nassert rv.status_code == 404\nassert rv.data == b\"value\"\ndef test_user_error_handling(app, client):\nclass myexception(exception):\npass\n@app.errorhandler(myexception)\ndef handle_my_exception(e):\nassert isinstance(e, myexception)\nreturn \"42\"\n@app.route(\"/\")\ndef index():\nraise myexception()\nassert client.get(\"/\").data == b\"42\"\ndef test_http_error_subclass_handling(app, client):\nclass forbiddensubclass(forbidden):\npass\n@app.errorhandler(forbiddensubclass)\ndef handle_forbidden_subclass(e):\nassert isinstance(e, forbiddensubclass)\nreturn \"banana\"\n@app.errorhandler(403)\ndef handle_403(e):\nassert not isinstance(e, forbiddensubclass)\nassert isinstance(e, forbidden)\nreturn \"apple\"\n@app.route(\"/1\")\ndef index1():\nraise forbiddensubclass()\n@app.route(\"/2\")\ndef index2():\nflask.abort(403)\n@app.route(\"/3\")\ndef index3():\nraise forbidden()\nassert client.get(\"/1\").data == b\"banana\"\nassert client.get(\"/2\").data == b\"apple\"\nassert client.get(\"/3\").data == b\"apple\"\ndef test_errorhandler_precedence(app, client):\nclass e1(exception):\npass\nclass e2(exception):\npass\nclass e3(e1, e2):\npass\n@app.errorhandler(e2)\ndef handle_e2(e):\nreturn \"e2\"\n@app.errorhandler(exception)\ndef handle_exception(e):\nreturn \"exception\"\n@app.route(\"/e1\")\ndef raise_e1():\nraise e1\n@app.route(\"/e3\")\ndef raise_e3():\nraise e3\nrv = client.get(\"/e1\")\nassert rv.data == b\"exception\"\nrv = client.get(\"/e3\")", "pass\nclass e3(e1, e2):\npass\n@app.errorhandler(e2)\ndef handle_e2(e):\nreturn \"e2\"\n@app.errorhandler(exception)\ndef handle_exception(e):\nreturn \"exception\"\n@app.route(\"/e1\")\ndef raise_e1():\nraise e1\n@app.route(\"/e3\")\ndef raise_e3():\nraise e3\nrv = client.get(\"/e1\")\nassert rv.data == b\"exception\"\nrv = client.get(\"/e3\")\nassert rv.data == b\"e2\"\n@pytest.mark.parametrize(\n(\"debug\", \"trap\", \"expect_key\", \"expect_abort\"),\n[(false, none, true, true), (true, none, false, true), (false, true, false, false)],\n)\ndef test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\napp.config[\"debug\"] = debug\napp.config[\"trap_bad_request_errors\"] = trap\n@app.route(\"/key\")\ndef fail():\nflask.request.form[\"missing_key\"]\n@app.route(\"/abort\")\ndef allow_abort():\nflask.abort(400)\nif expect_key:\nrv = client.get(\"/key\")\nassert rv.status_code == 400\nassert b\"missing_key\" not in rv.data\nelse:\nwith pytest.raises(keyerror) as exc_info:\nclient.get(\"/key\")\nassert exc_info.errisinstance(badrequest)\nassert \"missing_key\" in exc_info.value.get_description()\nif expect_abort:\nrv = client.get(\"/abort\")\nassert rv.status_code == 400\nelse:\nwith pytest.raises(badrequest):\nclient.get(\"/abort\")\ndef test_trapping_of_all_http_exceptions(app, client):\napp.config[\"trap_http_exceptions\"] = true\n@app.route(\"/fail\")\ndef fail():\nflask.abort(404)\nwith pytest.raises(notfound):\nclient.get(\"/fail\")\ndef test_error_handler_after_processor_error(app, client):\napp.testing = false\n@app.before_request\ndef before_request():\nif _trigger == \"before\":\nraise zerodivisionerror\n@app.after_request\ndef after_request(response):\nif _trigger == \"after\":\nraise zerodivisionerror\nreturn response\n@app.route(\"/\")\ndef index():\nreturn \"foo\"\n@app.errorhandler(500)\ndef internal_server_error(e):\nreturn \"hello server error\", 500\nfor _trigger in \"before\", \"after\":\nrv = client.get(\"/\")\nassert rv.status_code == 500\nassert rv.data == b\"hello server error\"", "raise zerodivisionerror\n@app.after_request\ndef after_request(response):\nif _trigger == \"after\":\nraise zerodivisionerror\nreturn response\n@app.route(\"/\")\ndef index():\nreturn \"foo\"\n@app.errorhandler(500)\ndef internal_server_error(e):\nreturn \"hello server error\", 500\nfor _trigger in \"before\", \"after\":\nrv = client.get(\"/\")\nassert rv.status_code == 500\nassert rv.data == b\"hello server error\"\ndef test_enctype_debug_helper(app, client):\nfrom flask.debughelpers import debugfileskeyerror\napp.debug = true\n@app.route(\"/fail\", methods=[\"post\"])\ndef index():\nreturn flask.request.files[\"foo\"].filename\nwith pytest.raises(debugfileskeyerror) as e:\nclient.post(\"/fail\", data={\"foo\": \"index.txt\"})\nassert \"no file contents were transmitted\" in str(e.value)\nassert \"this was submitted: 'index.txt'\" in str(e.value)\ndef test_response_types(app, client):\n@app.route(\"/text\")\ndef from_text():\nreturn \"h\u00e4llo w\u00f6rld\"\n@app.route(\"/bytes\")\ndef from_bytes():\nreturn \"h\u00e4llo w\u00f6rld\".encode()\n@app.route(\"/full_tuple\")\ndef from_full_tuple():\nreturn (\n\"meh\",\n400,\n{\"x-foo\": \"testing\", \"content-type\": \"text/plain; charset=utf-8\"},\n)\n@app.route(\"/text_headers\")\ndef from_text_headers():\nreturn \"hello\", {\"x-foo\": \"test\", \"content-type\": \"text/plain; charset=utf-8\"}\n@app.route(\"/text_status\")\ndef from_text_status():\nreturn \"hi, status!\", 400\n@app.route(\"/response_headers\")\ndef from_response_headers():\nreturn (\nflask.response(\n\"hello world\", 404, {\"content-type\": \"text/html\", \"x-foo\": \"baz\"}\n),\n{\"content-type\": \"text/plain\", \"x-foo\": \"bar\", \"x-bar\": \"foo\"},\n)\n@app.route(\"/response_status\")\ndef from_response_status():\nreturn app.response_class(\"hello world\", 400), 500\n@app.route(\"/wsgi\")\ndef from_wsgi():\nreturn notfound()\n@app.route(\"/dict\")\ndef from_dict():\nreturn {\"foo\": \"bar\"}, 201\n@app.route(\"/list\")\ndef from_list():\nreturn [\"foo\", \"bar\"], 201\nassert client.get(\"/text\").data == \"h\u00e4llo w\u00f6rld\".encode()", ")\n@app.route(\"/response_status\")\ndef from_response_status():\nreturn app.response_class(\"hello world\", 400), 500\n@app.route(\"/wsgi\")\ndef from_wsgi():\nreturn notfound()\n@app.route(\"/dict\")\ndef from_dict():\nreturn {\"foo\": \"bar\"}, 201\n@app.route(\"/list\")\ndef from_list():\nreturn [\"foo\", \"bar\"], 201\nassert client.get(\"/text\").data == \"h\u00e4llo w\u00f6rld\".encode()\nassert client.get(\"/bytes\").data == \"h\u00e4llo w\u00f6rld\".encode()\nrv = client.get(\"/full_tuple\")\nassert rv.data == b\"meh\"\nassert rv.headers[\"x-foo\"] == \"testing\"\nassert rv.status_code == 400\nassert rv.mimetype == \"text/plain\"\nrv = client.get(\"/text_headers\")\nassert rv.data == b\"hello\"\nassert rv.headers[\"x-foo\"] == \"test\"\nassert rv.status_code == 200\nassert rv.mimetype == \"text/plain\"\nrv = client.get(\"/text_status\")\nassert rv.data == b\"hi, status!\"\nassert rv.status_code == 400\nassert rv.mimetype == \"text/html\"\nrv = client.get(\"/response_headers\")\nassert rv.data == b\"hello world\"\nassert rv.content_type == \"text/plain\"\nassert rv.headers.getlist(\"x-foo\") == [\"bar\"]\nassert rv.headers[\"x-bar\"] == \"foo\"\nassert rv.status_code == 404\nrv = client.get(\"/response_status\")\nassert rv.data == b\"hello world\"\nassert rv.status_code == 500\nrv = client.get(\"/wsgi\")\nassert b\"not found\" in rv.data\nassert rv.status_code == 404\nrv = client.get(\"/dict\")\nassert rv.json == {\"foo\": \"bar\"}\nassert rv.status_code == 201\nrv = client.get(\"/list\")\nassert rv.json == [\"foo\", \"bar\"]\nassert rv.status_code == 201\ndef test_response_type_errors():\napp = flask.flask(__name__)\napp.testing = true\n@app.route(\"/none\")\ndef from_none():\npass\n@app.route(\"/small_tuple\")\ndef from_small_tuple():\nreturn (\"hello\",)\n@app.route(\"/large_tuple\")\ndef from_large_tuple():\nreturn \"hello\", 234, {\"x-foo\": \"bar\"}, \"???\"\n@app.route(\"/bad_type\")\ndef from_bad_type():\nreturn true\n@app.route(\"/bad_wsgi\")\ndef from_bad_wsgi():\nreturn lambda: none", "app.testing = true\n@app.route(\"/none\")\ndef from_none():\npass\n@app.route(\"/small_tuple\")\ndef from_small_tuple():\nreturn (\"hello\",)\n@app.route(\"/large_tuple\")\ndef from_large_tuple():\nreturn \"hello\", 234, {\"x-foo\": \"bar\"}, \"???\"\n@app.route(\"/bad_type\")\ndef from_bad_type():\nreturn true\n@app.route(\"/bad_wsgi\")\ndef from_bad_wsgi():\nreturn lambda: none\nc = app.test_client()\nwith pytest.raises(typeerror) as e:\nc.get(\"/none\")\nassert \"returned none\" in str(e.value)\nassert \"from_none\" in str(e.value)\nwith pytest.raises(typeerror) as e:\nc.get(\"/small_tuple\")\nassert \"tuple must have the form\" in str(e.value)\nwith pytest.raises(typeerror):\nc.get(\"/large_tuple\")\nwith pytest.raises(typeerror) as e:\nc.get(\"/bad_type\")\nassert \"it was a bool\" in str(e.value)\nwith pytest.raises(typeerror):\nc.get(\"/bad_wsgi\")\ndef test_make_response(app, req_ctx):\nrv = flask.make_response()\nassert rv.status_code == 200\nassert rv.data == b\"\"\nassert rv.mimetype == \"text/html\"\nrv = flask.make_response(\"awesome\")\nassert rv.status_code == 200\nassert rv.data == b\"awesome\"\nassert rv.mimetype == \"text/html\"\nrv = flask.make_response(\"w00t\", 404)\nassert rv.status_code == 404\nassert rv.data == b\"w00t\"\nassert rv.mimetype == \"text/html\"\nrv = flask.make_response(c for c in \"hello\")\nassert rv.status_code == 200\nassert rv.data == b\"hello\"\nassert rv.mimetype == \"text/html\"\ndef test_make_response_with_response_instance(app, req_ctx):\nrv = flask.make_response(flask.jsonify({\"msg\": \"w00t\"}), 400)\nassert rv.status_code == 400\nassert rv.data == b'{\"msg\":\"w00t\"}\\n'\nassert rv.mimetype == \"application/json\"\nrv = flask.make_response(flask.response(\"\"), 400)\nassert rv.status_code == 400\nassert rv.data == b\"\"\nassert rv.mimetype == \"text/html\"\nrv = flask.make_response(\nflask.response(\"\", headers={\"content-type\": \"text/html\"}),\n400,\n[(\"x-foo\", \"bar\")],\n)\nassert rv.status_code == 400", "assert rv.data == b'{\"msg\":\"w00t\"}\\n'\nassert rv.mimetype == \"application/json\"\nrv = flask.make_response(flask.response(\"\"), 400)\nassert rv.status_code == 400\nassert rv.data == b\"\"\nassert rv.mimetype == \"text/html\"\nrv = flask.make_response(\nflask.response(\"\", headers={\"content-type\": \"text/html\"}),\n400,\n[(\"x-foo\", \"bar\")],\n)\nassert rv.status_code == 400\nassert rv.headers[\"content-type\"] == \"text/html\"\nassert rv.headers[\"x-foo\"] == \"bar\"\n@pytest.mark.parametrize(\"compact\", [true, false])\ndef test_jsonify_no_prettyprint(app, compact):\napp.json.compact = compact\nrv = app.json.response({\"msg\": {\"submsg\": \"w00t\"}, \"msg2\": \"foobar\"})\ndata = rv.data.strip()\nassert (b\" \" not in data) is compact\nassert (b\"\\n\" not in data) is compact\ndef test_jsonify_mimetype(app, req_ctx):\napp.json.mimetype = \"application/vnd.api+json\"\nmsg = {\"msg\": {\"submsg\": \"w00t\"}}\nrv = flask.make_response(flask.jsonify(msg), 200)\nassert rv.mimetype == \"application/vnd.api+json\"\ndef test_json_dump_dataclass(app, req_ctx):\nfrom dataclasses import make_dataclass\ndata = make_dataclass(\"data\", [(\"name\", str)])\nvalue = app.json.dumps(data(\"flask\"))\nvalue = app.json.loads(value)\nassert value == {\"name\": \"flask\"}\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\nwith pytest.raises(typeerror) as e:\nflask.jsonify(\"fake args\", kwargs=\"fake\")\nassert \"args or kwargs\" in str(e.value)\ndef test_url_generation(app, req_ctx):\n@app.route(\"/hello/<name>\", methods=[\"post\"])\ndef hello():\npass\nassert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\nassert (\nflask.url_for(\"hello\", name=\"test x\", _external=true)\n== \"http:\n)\ndef test_build_error_handler(app):\nwith app.test_request_context():\npytest.raises(builderror, flask.url_for, \"spam\")\ntry:\nwith app.test_request_context():\nflask.url_for(\"spam\")\nexcept builderror as err:\nerror = err\ntry:\nraise runtimeerror(\"test case where builderror is not current.\")", "assert (\nflask.url_for(\"hello\", name=\"test x\", _external=true)\n== \"http:\n)\ndef test_build_error_handler(app):\nwith app.test_request_context():\npytest.raises(builderror, flask.url_for, \"spam\")\ntry:\nwith app.test_request_context():\nflask.url_for(\"spam\")\nexcept builderror as err:\nerror = err\ntry:\nraise runtimeerror(\"test case where builderror is not current.\")\nexcept runtimeerror:\npytest.raises(builderror, app.handle_url_build_error, error, \"spam\", {})\ndef handler(error, endpoint, values):\nreturn \"/test_handler/\"\napp.url_build_error_handlers.append(handler)\nwith app.test_request_context():\nassert flask.url_for(\"spam\") == \"/test_handler/\"\ndef test_build_error_handler_reraise(app):\ndef handler_raises_build_error(error, endpoint, values):\nraise error\napp.url_build_error_handlers.append(handler_raises_build_error)\nwith app.test_request_context():\npytest.raises(builderror, flask.url_for, \"not.existing\")\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n@app.url_build_error_handlers.append\ndef handler(error, endpoint, values):\nassert values == {\n\"_external\": false,\n\"_anchor\": none,\n\"_method\": none,\n\"_scheme\": none,\n}\nreturn \"handled\"\nwith app.test_request_context():\nflask.url_for(\"/\")\ndef test_static_files(app, client):\nrv = client.get(\"/static/index.html\")\nassert rv.status_code == 200\nassert rv.data.strip() == b\"<h1>hello world!</h1>\"\nwith app.test_request_context():\nassert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\nrv.close()\ndef test_static_url_path():\napp = flask.flask(__name__, static_url_path=\"/foo\")\napp.testing = true\nrv = app.test_client().get(\"/foo/index.html\")\nassert rv.status_code == 200\nrv.close()\nwith app.test_request_context():\nassert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\ndef test_static_url_path_with_ending_slash():\napp = flask.flask(__name__, static_url_path=\"/foo/\")\napp.testing = true\nrv = app.test_client().get(\"/foo/index.html\")\nassert rv.status_code == 200\nrv.close()\nwith app.test_request_context():\nassert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\ndef test_static_url_empty_path(app):", "def test_static_url_path_with_ending_slash():\napp = flask.flask(__name__, static_url_path=\"/foo/\")\napp.testing = true\nrv = app.test_client().get(\"/foo/index.html\")\nassert rv.status_code == 200\nrv.close()\nwith app.test_request_context():\nassert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\ndef test_static_url_empty_path(app):\napp = flask.flask(__name__, static_folder=\"\", static_url_path=\"\")\nrv = app.test_client().open(\"/static/index.html\", method=\"get\")\nassert rv.status_code == 200\nrv.close()\ndef test_static_url_empty_path_default(app):\napp = flask.flask(__name__, static_folder=\"\")\nrv = app.test_client().open(\"/static/index.html\", method=\"get\")\nassert rv.status_code == 200\nrv.close()\ndef test_static_folder_with_pathlib_path(app):\nfrom pathlib import path\napp = flask.flask(__name__, static_folder=path(\"static\"))\nrv = app.test_client().open(\"/static/index.html\", method=\"get\")\nassert rv.status_code == 200\nrv.close()\ndef test_static_folder_with_ending_slash():\napp = flask.flask(__name__, static_folder=\"static/\")\n@app.route(\"/<path:path>\")\ndef catch_all(path):\nreturn path\nrv = app.test_client().get(\"/catch/all\")\nassert rv.data == b\"catch/all\"\ndef test_static_route_with_host_matching():\napp = flask.flask(__name__, host_matching=true, static_host=\"example.com\")\nc = app.test_client()\nrv = c.get(\"http:\nassert rv.status_code == 200\nrv.close()\nwith app.test_request_context():\nrv = flask.url_for(\"static\", filename=\"index.html\", _external=true)\nassert rv == \"http:\nwith pytest.raises(assertionerror):\nflask.flask(__name__, static_host=\"example.com\")\nwith pytest.raises(assertionerror):\nflask.flask(__name__, host_matching=true)\nflask.flask(__name__, host_matching=true, static_folder=none)\ndef test_request_locals():\nassert repr(flask.g) == \"<localproxy unbound>\"\nassert not flask.g\n@pytest.mark.parametrize(\n(\"subdomain_matching\", \"host_matching\", \"expect_base\", \"expect_abc\", \"expect_xyz\"),\n[\n(false, false, \"default\", \"default\", \"default\"),\n(true, false, \"default\", \"abc\", \"<invalid>\"),", "flask.flask(__name__, host_matching=true, static_folder=none)\ndef test_request_locals():\nassert repr(flask.g) == \"<localproxy unbound>\"\nassert not flask.g\n@pytest.mark.parametrize(\n(\"subdomain_matching\", \"host_matching\", \"expect_base\", \"expect_abc\", \"expect_xyz\"),\n[\n(false, false, \"default\", \"default\", \"default\"),\n(true, false, \"default\", \"abc\", \"<invalid>\"),\n(false, true, \"default\", \"abc\", \"default\"),\n],\n)\ndef test_server_name_matching(\nsubdomain_matching: bool,\nhost_matching: bool,\nexpect_base: str,\nexpect_abc: str,\nexpect_xyz: str,\n) -> none:\napp = flask.flask(\n__name__,\nsubdomain_matching=subdomain_matching,\nhost_matching=host_matching,\nstatic_host=\"example.test\" if host_matching else none,\n)\napp.config[\"server_name\"] = \"example.test\"\n@app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n@app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\ndef index(name: str) -> str:\nreturn name\nclient = app.test_client()\nr = client.get(base_url=\"http:\nassert r.text == expect_base\nr = client.get(base_url=\"http:\nassert r.text == expect_abc\nwith pytest.warns() if subdomain_matching else nullcontext():\nr = client.get(base_url=\"http:\nassert r.text == expect_xyz\ndef test_server_name_subdomain():\napp = flask.flask(__name__, subdomain_matching=true)\nclient = app.test_client()\n@app.route(\"/\")\ndef index():\nreturn \"default\"\n@app.route(\"/\", subdomain=\"foo\")\ndef subdomain():\nreturn \"subdomain\"\napp.config[\"server_name\"] = \"dev.local:5000\"\nrv = client.get(\"/\")\nassert rv.data == b\"default\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"default\"\nrv = client.get(\"/\", \"https:\nassert rv.data == b\"default\"\napp.config[\"server_name\"] = \"dev.local:443\"\nrv = client.get(\"/\", \"https:\nif rv.status_code != 404:\nassert rv.data == b\"default\"\napp.config[\"server_name\"] = \"dev.local\"\nrv = client.get(\"/\", \"https:\nassert rv.data == b\"default\"\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\n\"ignore\", \"current server name\", userwarning, \"flask.app\"\n)\nrv = client.get(\"/\", \"http:", "app.config[\"server_name\"] = \"dev.local:443\"\nrv = client.get(\"/\", \"https:\nif rv.status_code != 404:\nassert rv.data == b\"default\"\napp.config[\"server_name\"] = \"dev.local\"\nrv = client.get(\"/\", \"https:\nassert rv.data == b\"default\"\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\n\"ignore\", \"current server name\", userwarning, \"flask.app\"\n)\nrv = client.get(\"/\", \"http:\nassert rv.status_code == 404\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"subdomain\"\n@pytest.mark.parametrize(\"key\", [\"testing\", \"propagate_exceptions\", \"debug\", none])\ndef test_exception_propagation(app, client, key):\napp.testing = false\n@app.route(\"/\")\ndef index():\nraise zerodivisionerror\nif key is not none:\napp.config[key] = true\nwith pytest.raises(zerodivisionerror):\nclient.get(\"/\")\nelse:\nassert client.get(\"/\").status_code == 500\n@pytest.mark.parametrize(\"debug\", [true, false])\n@pytest.mark.parametrize(\"use_debugger\", [true, false])\n@pytest.mark.parametrize(\"use_reloader\", [true, false])\n@pytest.mark.parametrize(\"propagate_exceptions\", [none, true, false])\ndef test_werkzeug_passthrough_errors(\nmonkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\nrv = {}\ndef run_simple_mock(*args, **kwargs):\nrv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.config[\"propagate_exceptions\"] = propagate_exceptions\napp.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\ndef test_url_processors(app, client):\n@app.url_defaults\ndef add_language_code(endpoint, values):\nif flask.g.lang_code is not none and app.url_map.is_endpoint_expecting(\nendpoint, \"lang_code\"\n):\nvalues.setdefault(\"lang_code\", flask.g.lang_code)\n@app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\nflask.g.lang_code = values.pop(\"lang_code\", none)\n@app.route(\"/<lang_code>/\")\ndef index():\nreturn flask.url_for(\"about\")\n@app.route(\"/<lang_code>/about\")\ndef about():\nreturn flask.url_for(\"something_else\")\n@app.route(\"/foo\")\ndef something_else():\nreturn flask.url_for(\"about\", lang_code=\"en\")", "):\nvalues.setdefault(\"lang_code\", flask.g.lang_code)\n@app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\nflask.g.lang_code = values.pop(\"lang_code\", none)\n@app.route(\"/<lang_code>/\")\ndef index():\nreturn flask.url_for(\"about\")\n@app.route(\"/<lang_code>/about\")\ndef about():\nreturn flask.url_for(\"something_else\")\n@app.route(\"/foo\")\ndef something_else():\nreturn flask.url_for(\"about\", lang_code=\"en\")\nassert client.get(\"/de/\").data == b\"/de/about\"\nassert client.get(\"/de/about\").data == b\"/foo\"\nassert client.get(\"/foo\").data == b\"/en/about\"\ndef test_inject_blueprint_url_defaults(app):\nbp = flask.blueprint(\"foo\", __name__, template_folder=\"template\")\n@bp.url_defaults\ndef bp_defaults(endpoint, values):\nvalues[\"page\"] = \"login\"\n@bp.route(\"/<page>\")\ndef view(page):\npass\napp.register_blueprint(bp)\nvalues = dict()\napp.inject_url_defaults(\"foo.view\", values)\nexpected = dict(page=\"login\")\nassert values == expected\nwith app.test_request_context(\"/somepage\"):\nurl = flask.url_for(\"foo.view\")\nexpected = \"/login\"\nassert url == expected\ndef test_nonascii_pathinfo(app, client):\n@app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\ndef index():\nreturn \"hello world!\"\nrv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\nassert rv.data == b\"hello world!\"\ndef test_no_setup_after_first_request(app, client):\napp.debug = true\n@app.route(\"/\")\ndef index():\nreturn \"awesome\"\nassert client.get(\"/\").data == b\"awesome\"\nwith pytest.raises(assertionerror) as exc_info:\napp.add_url_rule(\"/foo\", endpoint=\"late\")\nassert \"setup method 'add_url_rule'\" in str(exc_info.value)\ndef test_routing_redirect_debugging(monkeypatch, app, client):\napp.config[\"debug\"] = true\n@app.route(\"/user/\", methods=[\"get\", \"post\"])\ndef user():\nreturn flask.request.form[\"status\"]\nrv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=true)\nassert rv.data == b\"success\"\nmonkeypatch.setattr(requestredirect, \"code\", 301)\nwith client, pytest.raises(assertionerror) as exc_info:\nclient.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=true)\nassert \"canonical url 'http:\ndef test_route_decorator_custom_endpoint(app, client):", "def user():\nreturn flask.request.form[\"status\"]\nrv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=true)\nassert rv.data == b\"success\"\nmonkeypatch.setattr(requestredirect, \"code\", 301)\nwith client, pytest.raises(assertionerror) as exc_info:\nclient.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=true)\nassert \"canonical url 'http:\ndef test_route_decorator_custom_endpoint(app, client):\napp.debug = true\n@app.route(\"/foo/\")\ndef foo():\nreturn flask.request.endpoint\n@app.route(\"/bar/\", endpoint=\"bar\")\ndef for_bar():\nreturn flask.request.endpoint\n@app.route(\"/bar/123\", endpoint=\"123\")\ndef for_bar_foo():\nreturn flask.request.endpoint\nwith app.test_request_context():\nassert flask.url_for(\"foo\") == \"/foo/\"\nassert flask.url_for(\"bar\") == \"/bar/\"\nassert flask.url_for(\"123\") == \"/bar/123\"\nassert client.get(\"/foo/\").data == b\"foo\"\nassert client.get(\"/bar/\").data == b\"bar\"\nassert client.get(\"/bar/123\").data == b\"123\"\ndef test_get_method_on_g(app_ctx):\nassert flask.g.get(\"x\") is none\nassert flask.g.get(\"x\", 11) == 11\nflask.g.x = 42\nassert flask.g.get(\"x\") == 42\nassert flask.g.x == 42\ndef test_g_iteration_protocol(app_ctx):\nflask.g.foo = 23\nflask.g.bar = 42\nassert \"foo\" in flask.g\nassert \"foos\" not in flask.g\nassert sorted(flask.g) == [\"bar\", \"foo\"]\ndef test_subdomain_basic_support():\napp = flask.flask(__name__, subdomain_matching=true)\napp.config[\"server_name\"] = \"localhost.localdomain\"\nclient = app.test_client()\n@app.route(\"/\")\ndef normal_index():\nreturn \"normal index\"\n@app.route(\"/\", subdomain=\"test\")\ndef test_index():\nreturn \"test index\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"normal index\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"test index\"\ndef test_subdomain_matching():\napp = flask.flask(__name__, subdomain_matching=true)\nclient = app.test_client()\napp.config[\"server_name\"] = \"localhost.localdomain\"\n@app.route(\"/\", subdomain=\"<user>\")\ndef index(user):\nreturn f\"index for {user}\"", "def test_index():\nreturn \"test index\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"normal index\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"test index\"\ndef test_subdomain_matching():\napp = flask.flask(__name__, subdomain_matching=true)\nclient = app.test_client()\napp.config[\"server_name\"] = \"localhost.localdomain\"\n@app.route(\"/\", subdomain=\"<user>\")\ndef index(user):\nreturn f\"index for {user}\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"index for mitsuhiko\"\ndef test_subdomain_matching_with_ports():\napp = flask.flask(__name__, subdomain_matching=true)\napp.config[\"server_name\"] = \"localhost.localdomain:3000\"\nclient = app.test_client()\n@app.route(\"/\", subdomain=\"<user>\")\ndef index(user):\nreturn f\"index for {user}\"\nrv = client.get(\"/\", \"http:\nassert rv.data == b\"index for mitsuhiko\"\n@pytest.mark.parametrize(\"matching\", (false, true))\ndef test_subdomain_matching_other_name(matching):\napp = flask.flask(__name__, subdomain_matching=matching)\napp.config[\"server_name\"] = \"localhost.localdomain:3000\"\nclient = app.test_client()\n@app.route(\"/\")\ndef index():\nreturn \"\", 204\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\n\"ignore\", \"current server name\", userwarning, \"flask.app\"\n)\nrv = client.get(\"/\", \"http:\nassert rv.status_code == 404 if matching else 204\nrv = client.get(\"/\", \"http:\nassert rv.status_code == 404 if matching else 204\ndef test_multi_route_rules(app, client):\n@app.route(\"/\")\n@app.route(\"/<test>/\")\ndef index(test=\"a\"):\nreturn test\nrv = client.open(\"/\")\nassert rv.data == b\"a\"\nrv = client.open(\"/b/\")\nassert rv.data == b\"b\"\ndef test_multi_route_class_views(app, client):\nclass view:\ndef __init__(self, app):\napp.add_url_rule(\"/\", \"index\", self.index)\napp.add_url_rule(\"/<test>/\", \"index\", self.index)\ndef index(self, test=\"a\"):\nreturn test\n_ = view(app)\nrv = client.open(\"/\")\nassert rv.data == b\"a\"\nrv = client.open(\"/b/\")\nassert rv.data == b\"b\"\ndef test_run_defaults(monkeypatch, app):\nrv = {}\ndef run_simple_mock(*args, **kwargs):", "def __init__(self, app):\napp.add_url_rule(\"/\", \"index\", self.index)\napp.add_url_rule(\"/<test>/\", \"index\", self.index)\ndef index(self, test=\"a\"):\nreturn test\n_ = view(app)\nrv = client.open(\"/\")\nassert rv.data == b\"a\"\nrv = client.open(\"/b/\")\nassert rv.data == b\"b\"\ndef test_run_defaults(monkeypatch, app):\nrv = {}\ndef run_simple_mock(*args, **kwargs):\nrv[\"result\"] = \"running...\"\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.run()\nassert rv[\"result\"] == \"running...\"\ndef test_run_server_port(monkeypatch, app):\nrv = {}\ndef run_simple_mock(hostname, port, application, *args, **kwargs):\nrv[\"result\"] = f\"running on {hostname}:{port} ...\"\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\nhostname, port = \"localhost\", 8000\napp.run(hostname, port, debug=true)\nassert rv[\"result\"] == f\"running on {hostname}:{port} ...\"\n@pytest.mark.parametrize(\n\"host,port,server_name,expect_host,expect_port\",\n(\n(none, none, \"pocoo.org:8080\", \"pocoo.org\", 8080),\n(\"localhost\", none, \"pocoo.org:8080\", \"localhost\", 8080),\n(none, 80, \"pocoo.org:8080\", \"pocoo.org\", 80),\n(\"localhost\", 80, \"pocoo.org:8080\", \"localhost\", 80),\n(\"localhost\", 0, \"localhost:8080\", \"localhost\", 0),\n(none, none, \"localhost:8080\", \"localhost\", 8080),\n(none, none, \"localhost:0\", \"localhost\", 0),\n),\n)\ndef test_run_from_config(\nmonkeypatch, host, port, server_name, expect_host, expect_port, app\n):\ndef run_simple_mock(hostname, port, *args, **kwargs):\nassert hostname == expect_host\nassert port == expect_port\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.config[\"server_name\"] = server_name\napp.run(host, port)\ndef test_max_cookie_size(app, client, recwarn):\napp.config[\"max_cookie_size\"] = 100", "):\ndef run_simple_mock(hostname, port, *args, **kwargs):\nassert hostname == expect_host\nassert port == expect_port\nmonkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\napp.config[\"server_name\"] = server_name\napp.run(host, port)\ndef test_max_cookie_size(app, client, recwarn):\napp.config[\"max_cookie_size\"] = 100\nresponse = flask.response()\ndefault = flask.flask.default_config[\"max_cookie_size\"]\nassert response.max_cookie_size == default\nwith app.app_context():\nassert flask.response().max_cookie_size == 100\n@app.route(\"/\")\ndef index():\nr = flask.response(\"\", status=204)\nr.set_cookie(\"foo\", \"bar\" * 100)\nreturn r\nclient.get(\"/\")\nassert len(recwarn) == 1\nw = recwarn.pop()\nassert \"cookie is too large\" in str(w.message)\napp.config[\"max_cookie_size\"] = 0\nclient.get(\"/\")\nassert len(recwarn) == 0\n@require_cpython_gc\ndef test_app_freed_on_zero_refcount():\ngc.disable()\ntry:\napp = flask.flask(__name__)\nassert app.view_functions[\"static\"]\nweak = weakref.ref(app)\nassert weak() is not none\ndel app\nassert weak() is none\nfinally:\ngc.enable()", "import importlib.metadata\nimport click\nimport pytest\nimport flask\nfrom flask import appcontext_popped\nfrom flask.cli import scriptinfo\nfrom flask.globals import _cv_request\nfrom flask.json import jsonify\nfrom flask.testing import environbuilder\nfrom flask.testing import flaskclirunner\ndef test_environ_defaults_from_config(app, client):\napp.config[\"server_name\"] = \"example.com:1234\"\napp.config[\"application_root\"] = \"/foo\"\n@app.route(\"/\")\ndef index():\nreturn flask.request.url\nctx = app.test_request_context()\nassert ctx.request.url == \"http:\nrv = client.get(\"/\")\nassert rv.data == b\"http:\ndef test_environ_defaults(app, client, app_ctx, req_ctx):\n@app.route(\"/\")\ndef index():\nreturn flask.request.url\nctx = app.test_request_context()\nassert ctx.request.url == \"http:\nwith client:\nrv = client.get(\"/\")\nassert rv.data == b\"http:\ndef test_environ_base_default(app, client):\n@app.route(\"/\")\ndef index():\nflask.g.remote_addr = flask.request.remote_addr\nflask.g.user_agent = flask.request.user_agent.string\nreturn \"\"\nwith client:\nclient.get(\"/\")\nassert flask.g.remote_addr == \"127.0.0.1\"\nassert flask.g.user_agent == (\nf\"werkzeug/{importlib.metadata.version('werkzeug')}\"\n)\ndef test_environ_base_modified(app, client):\n@app.route(\"/\")\ndef index():\nflask.g.remote_addr = flask.request.remote_addr\nflask.g.user_agent = flask.request.user_agent.string\nreturn \"\"\nclient.environ_base[\"remote_addr\"] = \"192.168.0.22\"\nclient.environ_base[\"http_user_agent\"] = \"foo\"\nwith client:\nclient.get(\"/\")\nassert flask.g.remote_addr == \"192.168.0.22\"\nassert flask.g.user_agent == \"foo\"\ndef test_client_open_environ(app, client, request):\n@app.route(\"/index\")\ndef index():\nreturn flask.request.remote_addr\nbuilder = environbuilder(app, path=\"/index\", method=\"get\")\nrequest.addfinalizer(builder.close)\nrv = client.open(builder)\nassert rv.data == b\"127.0.0.1\"\nenviron = builder.get_environ()\nclient.environ_base[\"remote_addr\"] = \"127.0.0.2\"\nrv = client.open(environ)\nassert rv.data == b\"127.0.0.2\"\ndef test_specify_url_scheme(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.request.url", "request.addfinalizer(builder.close)\nrv = client.open(builder)\nassert rv.data == b\"127.0.0.1\"\nenviron = builder.get_environ()\nclient.environ_base[\"remote_addr\"] = \"127.0.0.2\"\nrv = client.open(environ)\nassert rv.data == b\"127.0.0.2\"\ndef test_specify_url_scheme(app, client):\n@app.route(\"/\")\ndef index():\nreturn flask.request.url\nctx = app.test_request_context(url_scheme=\"https\")\nassert ctx.request.url == \"https:\nrv = client.get(\"/\", url_scheme=\"https\")\nassert rv.data == b\"https:\ndef test_path_is_url(app):\neb = environbuilder(app, \"https:\nassert eb.url_scheme == \"https\"\nassert eb.host == \"example.com\"\nassert eb.script_root == \"\"\nassert eb.path == \"/\"\ndef test_environbuilder_json_dumps(app):\napp.json.ensure_ascii = false\neb = environbuilder(app, json=\"\\u20ac\")\nassert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'\ndef test_blueprint_with_subdomain():\napp = flask.flask(__name__, subdomain_matching=true)\napp.config[\"server_name\"] = \"example.com:1234\"\napp.config[\"application_root\"] = \"/foo\"\nclient = app.test_client()\nbp = flask.blueprint(\"company\", __name__, subdomain=\"xxx\")\n@bp.route(\"/\")\ndef index():\nreturn flask.request.url\napp.register_blueprint(bp)\nctx = app.test_request_context(\"/\", subdomain=\"xxx\")\nassert ctx.request.url == \"http:\nwith ctx:\nassert ctx.request.blueprint == bp.name\nrv = client.get(\"/\", subdomain=\"xxx\")\nassert rv.data == b\"http:\ndef test_redirect_keep_session(app, client, app_ctx):\n@app.route(\"/\", methods=[\"get\", \"post\"])\ndef index():\nif flask.request.method == \"post\":\nreturn flask.redirect(\"/getsession\")\nflask.session[\"data\"] = \"foo\"\nreturn \"index\"\n@app.route(\"/getsession\")\ndef get_session():\nreturn flask.session.get(\"data\", \"<missing>\")\nwith client:\nrv = client.get(\"/getsession\")\nassert rv.data == b\"<missing>\"\nrv = client.get(\"/\")\nassert rv.data == b\"index\"\nassert flask.session.get(\"data\") == \"foo\"\nrv = client.post(\"/\", data={}, follow_redirects=true)\nassert rv.data == b\"foo\"\nassert flask.session.get(\"data\") == \"foo\"\nrv = client.get(\"/getsession\")", "def get_session():\nreturn flask.session.get(\"data\", \"<missing>\")\nwith client:\nrv = client.get(\"/getsession\")\nassert rv.data == b\"<missing>\"\nrv = client.get(\"/\")\nassert rv.data == b\"index\"\nassert flask.session.get(\"data\") == \"foo\"\nrv = client.post(\"/\", data={}, follow_redirects=true)\nassert rv.data == b\"foo\"\nassert flask.session.get(\"data\") == \"foo\"\nrv = client.get(\"/getsession\")\nassert rv.data == b\"foo\"\ndef test_session_transactions(app, client):\n@app.route(\"/\")\ndef index():\nreturn str(flask.session[\"foo\"])\nwith client:\nwith client.session_transaction() as sess:\nassert len(sess) == 0\nsess[\"foo\"] = [42]\nassert len(sess) == 1\nrv = client.get(\"/\")\nassert rv.data == b\"[42]\"\nwith client.session_transaction() as sess:\nassert len(sess) == 1\nassert sess[\"foo\"] == [42]\ndef test_session_transactions_no_null_sessions():\napp = flask.flask(__name__)\nwith app.test_client() as c:\nwith pytest.raises(runtimeerror) as e:\nwith c.session_transaction():\npass\nassert \"session backend did not open a session\" in str(e.value)\ndef test_session_transactions_keep_context(app, client, req_ctx):\nclient.get(\"/\")\nreq = flask.request._get_current_object()\nassert req is not none\nwith client.session_transaction():\nassert req is flask.request._get_current_object()\ndef test_session_transaction_needs_cookies(app):\nc = app.test_client(use_cookies=false)\nwith pytest.raises(typeerror, match=\"cookies are disabled.\"):\nwith c.session_transaction():\npass\ndef test_test_client_context_binding(app, client):\napp.testing = false\n@app.route(\"/\")\ndef index():\nflask.g.value = 42\nreturn \"hello world!\"\n@app.route(\"/other\")\ndef other():\nraise zerodivisionerror\nwith client:\nresp = client.get(\"/\")\nassert flask.g.value == 42\nassert resp.data == b\"hello world!\"\nassert resp.status_code == 200\nwith client:\nresp = client.get(\"/other\")\nassert not hasattr(flask.g, \"value\")\nassert b\"internal server error\" in resp.data\nassert resp.status_code == 500\nflask.g.value = 23\nwith pytest.raises(runtimeerror):\nflask.g.value\ndef test_reuse_client(client):\nc = client\nwith c:\nassert client.get(\"/\").status_code == 404\nwith c:", "assert resp.status_code == 200\nwith client:\nresp = client.get(\"/other\")\nassert not hasattr(flask.g, \"value\")\nassert b\"internal server error\" in resp.data\nassert resp.status_code == 500\nflask.g.value = 23\nwith pytest.raises(runtimeerror):\nflask.g.value\ndef test_reuse_client(client):\nc = client\nwith c:\nassert client.get(\"/\").status_code == 404\nwith c:\nassert client.get(\"/\").status_code == 404\ndef test_full_url_request(app, client):\n@app.route(\"/action\", methods=[\"post\"])\ndef action():\nreturn \"x\"\nwith client:\nrv = client.post(\"http:\nassert rv.status_code == 200\nassert \"gin\" in flask.request.form\nassert \"vodka\" in flask.request.args\ndef test_json_request_and_response(app, client):\n@app.route(\"/echo\", methods=[\"post\"])\ndef echo():\nreturn jsonify(flask.request.get_json())\nwith client:\njson_data = {\"drink\": {\"gin\": 1, \"tonic\": true}, \"price\": 10}\nrv = client.post(\"/echo\", json=json_data)\nassert flask.request.is_json\nassert flask.request.get_json() == json_data\nassert rv.status_code == 200\nassert rv.is_json\nassert rv.get_json() == json_data\ndef test_client_json_no_app_context(app, client):\n@app.route(\"/hello\", methods=[\"post\"])\ndef hello():\nreturn f\"hello, {flask.request.json['name']}!\"\nclass namespace:\ncount = 0\ndef add(self, app):\nself.count += 1\nns = namespace()\nwith appcontext_popped.connected_to(ns.add, app):\nrv = client.post(\"/hello\", json={\"name\": \"flask\"})\nassert rv.get_data(as_text=true) == \"hello, flask!\"\nassert ns.count == 1\ndef test_subdomain():\napp = flask.flask(__name__, subdomain_matching=true)\napp.config[\"server_name\"] = \"example.com\"\nclient = app.test_client()\n@app.route(\"/\", subdomain=\"<company_id>\")\ndef view(company_id):\nreturn company_id\nwith app.test_request_context():\nurl = flask.url_for(\"view\", company_id=\"xxx\")\nwith client:\nresponse = client.get(url)\nassert 200 == response.status_code\nassert b\"xxx\" == response.data\ndef test_nosubdomain(app, client):\napp.config[\"server_name\"] = \"example.com\"\n@app.route(\"/<company_id>\")", "client = app.test_client()\n@app.route(\"/\", subdomain=\"<company_id>\")\ndef view(company_id):\nreturn company_id\nwith app.test_request_context():\nurl = flask.url_for(\"view\", company_id=\"xxx\")\nwith client:\nresponse = client.get(url)\nassert 200 == response.status_code\nassert b\"xxx\" == response.data\ndef test_nosubdomain(app, client):\napp.config[\"server_name\"] = \"example.com\"\n@app.route(\"/<company_id>\")\ndef view(company_id):\nreturn company_id\nwith app.test_request_context():\nurl = flask.url_for(\"view\", company_id=\"xxx\")\nwith client:\nresponse = client.get(url)\nassert 200 == response.status_code\nassert b\"xxx\" == response.data\ndef test_cli_runner_class(app):\nrunner = app.test_cli_runner()\nassert isinstance(runner, flaskclirunner)\nclass subrunner(flaskclirunner):\npass\napp.test_cli_runner_class = subrunner\nrunner = app.test_cli_runner()\nassert isinstance(runner, subrunner)\ndef test_cli_invoke(app):\n@app.cli.command(\"hello\")\ndef hello_command():\nclick.echo(\"hello, world!\")\nrunner = app.test_cli_runner()\nresult = runner.invoke(args=[\"hello\"])\nassert \"hello\" in result.output\nresult = runner.invoke(hello_command)\nassert \"hello\" in result.output\ndef test_cli_custom_obj(app):\nclass ns:\ncalled = false\ndef create_app():\nns.called = true\nreturn app\n@app.cli.command(\"hello\")\ndef hello_command():\nclick.echo(\"hello, world!\")\nscript_info = scriptinfo(create_app=create_app)\nrunner = app.test_cli_runner()\nrunner.invoke(hello_command, obj=script_info)\nassert ns.called\ndef test_client_pop_all_preserved(app, req_ctx, client):\n@app.route(\"/\")\ndef index():\nreturn flask.stream_with_context(\"hello\")\nwith client:\nrv = client.get(\"/\")\nrv.close()\nassert _cv_request.get(none) is req_ctx", "from .cli import main\nmain()", "from __future__ import annotations\nfrom blinker import namespace\n_signals = namespace()\ntemplate_rendered = _signals.signal(\"template-rendered\")\nbefore_render_template = _signals.signal(\"before-render-template\")\nrequest_started = _signals.signal(\"request-started\")\nrequest_finished = _signals.signal(\"request-finished\")\nrequest_tearing_down = _signals.signal(\"request-tearing-down\")\ngot_request_exception = _signals.signal(\"got-request-exception\")\nappcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\nappcontext_pushed = _signals.signal(\"appcontext-pushed\")\nappcontext_popped = _signals.signal(\"appcontext-popped\")\nmessage_flashed = _signals.signal(\"message-flashed\")", "from flask import jsonify\nfrom flask import render_template\nfrom flask import request\nfrom . import app\n@app.route(\"/\", defaults={\"js\": \"fetch\"})\n@app.route(\"/<any(xhr, jquery, fetch):js>\")\ndef index(js):\nreturn render_template(f\"{js}.html\", js=js)\n@app.route(\"/add\", methods=[\"post\"])\ndef add():\na = request.form.get(\"a\", 0, type=float)\nb = request.form.get(\"b\", 0, type=float)\nreturn jsonify(result=a + b)", "from __future__ import annotations\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import tracebacktype\nfrom urllib.parse import quote as _url_quote\nimport click\nfrom werkzeug.datastructures import headers\nfrom werkzeug.datastructures import immutabledict\nfrom werkzeug.exceptions import badrequestkeyerror\nfrom werkzeug.exceptions import httpexception\nfrom werkzeug.exceptions import internalservererror\nfrom werkzeug.routing import builderror\nfrom werkzeug.routing import mapadapter\nfrom werkzeug.routing import requestredirect\nfrom werkzeug.routing import routingexception\nfrom werkzeug.routing import rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import response as baseresponse\nfrom werkzeug.wsgi import get_host\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import appcontext\nfrom .ctx import requestcontext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import app\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import securecookiesessioninterface\nfrom .sessions import sessioninterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import environment\nfrom .wrappers import request\nfrom .wrappers import response\nif t.type_checking:\nfrom _typeshed.wsgi import startresponse\nfrom _typeshed.wsgi import wsgienvironment\nfrom .testing import flaskclient\nfrom .testing import flaskclirunner\nfrom .typing import headersvalue\nt_shell_context_processor = t.typevar(\n\"t_shell_context_processor\", bound=ft.shellcontextprocessorcallable\n)\nt_teardown = t.typevar(\"t_teardown\", bound=ft.teardowncallable)\nt_template_filter = t.typevar(\"t_template_filter\", bound=ft.templatefiltercallable)", "from _typeshed.wsgi import wsgienvironment\nfrom .testing import flaskclient\nfrom .testing import flaskclirunner\nfrom .typing import headersvalue\nt_shell_context_processor = t.typevar(\n\"t_shell_context_processor\", bound=ft.shellcontextprocessorcallable\n)\nt_teardown = t.typevar(\"t_teardown\", bound=ft.teardowncallable)\nt_template_filter = t.typevar(\"t_template_filter\", bound=ft.templatefiltercallable)\nt_template_global = t.typevar(\"t_template_global\", bound=ft.templateglobalcallable)\nt_template_test = t.typevar(\"t_template_test\", bound=ft.templatetestcallable)\ndef _make_timedelta(value: timedelta | int | none) -> timedelta | none:\nif value is none or isinstance(value, timedelta):\nreturn value\nreturn timedelta(seconds=value)\nclass flask(app):\ndefault_config = immutabledict(\n{\n\"debug\": none,\n\"testing\": false,\n\"propagate_exceptions\": none,\n\"secret_key\": none,\n\"secret_key_fallbacks\": none,\n\"permanent_session_lifetime\": timedelta(days=31),\n\"use_x_sendfile\": false,\n\"trusted_hosts\": none,\n\"server_name\": none,\n\"application_root\": \"/\",\n\"session_cookie_name\": \"session\",\n\"session_cookie_domain\": none,\n\"session_cookie_path\": none,\n\"session_cookie_httponly\": true,\n\"session_cookie_secure\": false,\n\"session_cookie_partitioned\": false,\n\"session_cookie_samesite\": none,\n\"session_refresh_each_request\": true,\n\"max_content_length\": none,\n\"max_form_memory_size\": 500_000,\n\"max_form_parts\": 1_000,\n\"send_file_max_age_default\": none,\n\"trap_bad_request_errors\": none,\n\"trap_http_exceptions\": false,\n\"explain_template_loading\": false,\n\"preferred_url_scheme\": \"http\",\n\"templates_auto_reload\": none,\n\"max_cookie_size\": 4093,\n\"provide_automatic_options\": true,\n}\n)\nrequest_class: type[request] = request\nresponse_class: type[response] = response\nsession_interface: sessioninterface = securecookiesessioninterface()\ndef __init__(\nself,\nimport_name: str,\nstatic_url_path: str | none = none,\nstatic_folder: str | os.pathlike[str] | none = \"static\",\nstatic_host: str | none = none,\nhost_matching: bool = false,\nsubdomain_matching: bool = false,", "}\n)\nrequest_class: type[request] = request\nresponse_class: type[response] = response\nsession_interface: sessioninterface = securecookiesessioninterface()\ndef __init__(\nself,\nimport_name: str,\nstatic_url_path: str | none = none,\nstatic_folder: str | os.pathlike[str] | none = \"static\",\nstatic_host: str | none = none,\nhost_matching: bool = false,\nsubdomain_matching: bool = false,\ntemplate_folder: str | os.pathlike[str] | none = \"templates\",\ninstance_path: str | none = none,\ninstance_relative_config: bool = false,\nroot_path: str | none = none,\n):\nsuper().__init__(\nimport_name=import_name,\nstatic_url_path=static_url_path,\nstatic_folder=static_folder,\nstatic_host=static_host,\nhost_matching=host_matching,\nsubdomain_matching=subdomain_matching,\ntemplate_folder=template_folder,\ninstance_path=instance_path,\ninstance_relative_config=instance_relative_config,\nroot_path=root_path,\n)\nself.cli = cli.appgroup()\nself.cli.name = self.name\nif self.has_static_folder:\nassert bool(static_host) == host_matching, (\n\"invalid static_host/host_matching combination\"\n)\nself_ref = weakref.ref(self)\nself.add_url_rule(\nf\"{self.static_url_path}/<path:filename>\",\nendpoint=\"static\",\nhost=static_host,\nview_func=lambda **kw: self_ref().send_static_file(**kw),\n)\ndef get_send_file_max_age(self, filename: str | none) -> int | none:\nvalue = current_app.config[\"send_file_max_age_default\"]\nif value is none:\nreturn none\nif isinstance(value, timedelta):\nreturn int(value.total_seconds())\nreturn value\ndef send_static_file(self, filename: str) -> response:\nif not self.has_static_folder:\nraise runtimeerror(\"'static_folder' must be set to serve static_files.\")\nmax_age = self.get_send_file_max_age(filename)\nreturn send_from_directory(\nt.cast(str, self.static_folder), filename, max_age=max_age\n)\ndef open_resource(\nself, resource: str, mode: str = \"rb\", encoding: str | none = none\n) -> t.io[t.anystr]:\nif mode not in {\"r\", \"rt\", \"rb\"}:\nraise valueerror(\"resources can only be opened for reading.\")\npath = os.path.join(self.root_path, resource)\nif mode == \"rb\":\nreturn open(path, mode)\nreturn open(path, mode, encoding=encoding)", ")\ndef open_resource(\nself, resource: str, mode: str = \"rb\", encoding: str | none = none\n) -> t.io[t.anystr]:\nif mode not in {\"r\", \"rt\", \"rb\"}:\nraise valueerror(\"resources can only be opened for reading.\")\npath = os.path.join(self.root_path, resource)\nif mode == \"rb\":\nreturn open(path, mode)\nreturn open(path, mode, encoding=encoding)\ndef open_instance_resource(\nself, resource: str, mode: str = \"rb\", encoding: str | none = \"utf-8\"\n) -> t.io[t.anystr]:\npath = os.path.join(self.instance_path, resource)\nif \"b\" in mode:\nreturn open(path, mode)\nreturn open(path, mode, encoding=encoding)\ndef create_jinja_environment(self) -> environment:\noptions = dict(self.jinja_options)\nif \"autoescape\" not in options:\noptions[\"autoescape\"] = self.select_jinja_autoescape\nif \"auto_reload\" not in options:\nauto_reload = self.config[\"templates_auto_reload\"]\nif auto_reload is none:\nauto_reload = self.debug\noptions[\"auto_reload\"] = auto_reload\nrv = self.jinja_environment(self, **options)\nrv.globals.update(\nurl_for=self.url_for,\nget_flashed_messages=get_flashed_messages,\nconfig=self.config,\nrequest=request,\nsession=session,\ng=g,\n)\nrv.policies[\"json.dumps_function\"] = self.json.dumps\nreturn rv\ndef create_url_adapter(self, request: request | none) -> mapadapter | none:\nif request is not none:\nif (trusted_hosts := self.config[\"trusted_hosts\"]) is not none:\nrequest.trusted_hosts = trusted_hosts\nrequest.host = get_host(request.environ, request.trusted_hosts)\nsubdomain = none\nserver_name = self.config[\"server_name\"]\nif self.url_map.host_matching:\nserver_name = none\nelif not self.subdomain_matching:\nsubdomain = self.url_map.default_subdomain or \"\"\nreturn self.url_map.bind_to_environ(\nrequest.environ, server_name=server_name, subdomain=subdomain\n)\nif self.config[\"server_name\"] is not none:\nreturn self.url_map.bind(\nself.config[\"server_name\"],\nscript_name=self.config[\"application_root\"],\nurl_scheme=self.config[\"preferred_url_scheme\"],\n)\nreturn none\ndef raise_routing_exception(self, request: request) -> t.noreturn:\nif (\nnot self.debug\nor not isinstance(request.routing_exception, requestredirect)", "return self.url_map.bind_to_environ(\nrequest.environ, server_name=server_name, subdomain=subdomain\n)\nif self.config[\"server_name\"] is not none:\nreturn self.url_map.bind(\nself.config[\"server_name\"],\nscript_name=self.config[\"application_root\"],\nurl_scheme=self.config[\"preferred_url_scheme\"],\n)\nreturn none\ndef raise_routing_exception(self, request: request) -> t.noreturn:\nif (\nnot self.debug\nor not isinstance(request.routing_exception, requestredirect)\nor request.routing_exception.code in {307, 308}\nor request.method in {\"get\", \"head\", \"options\"}\n):\nraise request.routing_exception\nfrom .debughelpers import formdataroutingredirect\nraise formdataroutingredirect(request)\ndef update_template_context(self, context: dict[str, t.any]) -> none:\nnames: t.iterable[str | none] = (none,)\nif request:\nnames = chain(names, reversed(request.blueprints))\norig_ctx = context.copy()\nfor name in names:\nif name in self.template_context_processors:\nfor func in self.template_context_processors[name]:\ncontext.update(self.ensure_sync(func)())\ncontext.update(orig_ctx)\ndef make_shell_context(self) -> dict[str, t.any]:\nrv = {\"app\": self, \"g\": g}\nfor processor in self.shell_context_processors:\nrv.update(processor())\nreturn rv\ndef run(\nself,\nhost: str | none = none,\nport: int | none = none,\ndebug: bool | none = none,\nload_dotenv: bool = true,\n**options: t.any,\n) -> none:\nif os.environ.get(\"flask_run_from_cli\") == \"true\":\nif not is_running_from_reloader():\nclick.secho(\n\" * ignoring a call to 'app.run()' that would block\"\n\" the current 'flask' cli command.\\n\"\n\"   only call 'app.run()' in an 'if __name__ ==\"\n' \"__main__\"\\' guard.',\nfg=\"red\",\n)\nreturn\nif get_load_dotenv(load_dotenv):\ncli.load_dotenv()\nif \"flask_debug\" in os.environ:\nself.debug = get_debug_flag()\nif debug is not none:\nself.debug = bool(debug)\nserver_name = self.config.get(\"server_name\")\nsn_host = sn_port = none\nif server_name:\nsn_host, _, sn_port = server_name.partition(\":\")\nif not host:\nif sn_host:\nhost = sn_host\nelse:\nhost = \"127.0.0.1\"", "cli.load_dotenv()\nif \"flask_debug\" in os.environ:\nself.debug = get_debug_flag()\nif debug is not none:\nself.debug = bool(debug)\nserver_name = self.config.get(\"server_name\")\nsn_host = sn_port = none\nif server_name:\nsn_host, _, sn_port = server_name.partition(\":\")\nif not host:\nif sn_host:\nhost = sn_host\nelse:\nhost = \"127.0.0.1\"\nif port or port == 0:\nport = int(port)\nelif sn_port:\nport = int(sn_port)\nelse:\nport = 5000\noptions.setdefault(\"use_reloader\", self.debug)\noptions.setdefault(\"use_debugger\", self.debug)\noptions.setdefault(\"threaded\", true)\ncli.show_server_banner(self.debug, self.name)\nfrom werkzeug.serving import run_simple\ntry:\nrun_simple(t.cast(str, host), port, self, **options)\nfinally:\nself._got_first_request = false\ndef test_client(self, use_cookies: bool = true, **kwargs: t.any) -> flaskclient:\ncls = self.test_client_class\nif cls is none:\nfrom .testing import flaskclient as cls\nreturn cls(\nself, self.response_class, use_cookies=use_cookies, **kwargs\n)\ndef test_cli_runner(self, **kwargs: t.any) -> flaskclirunner:\ncls = self.test_cli_runner_class\nif cls is none:\nfrom .testing import flaskclirunner as cls\nreturn cls(self, **kwargs)\ndef handle_http_exception(\nself, e: httpexception\n) -> httpexception | ft.responsereturnvalue:\nif e.code is none:\nreturn e\nif isinstance(e, routingexception):\nreturn e\nhandler = self._find_error_handler(e, request.blueprints)\nif handler is none:\nreturn e\nreturn self.ensure_sync(handler)(e)\ndef handle_user_exception(\nself, e: exception\n) -> httpexception | ft.responsereturnvalue:\nif isinstance(e, badrequestkeyerror) and (\nself.debug or self.config[\"trap_bad_request_errors\"]\n):\ne.show_exception = true\nif isinstance(e, httpexception) and not self.trap_http_exception(e):\nreturn self.handle_http_exception(e)\nhandler = self._find_error_handler(e, request.blueprints)\nif handler is none:\nraise\nreturn self.ensure_sync(handler)(e)\ndef handle_exception(self, e: exception) -> response:\nexc_info = sys.exc_info()", "if isinstance(e, badrequestkeyerror) and (\nself.debug or self.config[\"trap_bad_request_errors\"]\n):\ne.show_exception = true\nif isinstance(e, httpexception) and not self.trap_http_exception(e):\nreturn self.handle_http_exception(e)\nhandler = self._find_error_handler(e, request.blueprints)\nif handler is none:\nraise\nreturn self.ensure_sync(handler)(e)\ndef handle_exception(self, e: exception) -> response:\nexc_info = sys.exc_info()\ngot_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\npropagate = self.config[\"propagate_exceptions\"]\nif propagate is none:\npropagate = self.testing or self.debug\nif propagate:\nif exc_info[1] is e:\nraise\nraise e\nself.log_exception(exc_info)\nserver_error: internalservererror | ft.responsereturnvalue\nserver_error = internalservererror(original_exception=e)\nhandler = self._find_error_handler(server_error, request.blueprints)\nif handler is not none:\nserver_error = self.ensure_sync(handler)(server_error)\nreturn self.finalize_request(server_error, from_error_handler=true)\ndef log_exception(\nself,\nexc_info: (tuple[type, baseexception, tracebacktype] | tuple[none, none, none]),\n) -> none:\nself.logger.error(\nf\"exception on {request.path} [{request.method}]\", exc_info=exc_info\n)\ndef dispatch_request(self) -> ft.responsereturnvalue:\nreq = request_ctx.request\nif req.routing_exception is not none:\nself.raise_routing_exception(req)\nrule: rule = req.url_rule\nif (\ngetattr(rule, \"provide_automatic_options\", false)\nand req.method == \"options\"\n):\nreturn self.make_default_options_response()\nview_args: dict[str, t.any] = req.view_args\nreturn self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\ndef full_dispatch_request(self) -> response:\nself._got_first_request = true\ntry:\nrequest_started.send(self, _async_wrapper=self.ensure_sync)\nrv = self.preprocess_request()\nif rv is none:\nrv = self.dispatch_request()\nexcept exception as e:\nrv = self.handle_user_exception(e)\nreturn self.finalize_request(rv)\ndef finalize_request(\nself,\nrv: ft.responsereturnvalue | httpexception,\nfrom_error_handler: bool = false,\n) -> response:\nresponse = self.make_response(rv)\ntry:\nresponse = self.process_response(response)\nrequest_finished.send(", "request_started.send(self, _async_wrapper=self.ensure_sync)\nrv = self.preprocess_request()\nif rv is none:\nrv = self.dispatch_request()\nexcept exception as e:\nrv = self.handle_user_exception(e)\nreturn self.finalize_request(rv)\ndef finalize_request(\nself,\nrv: ft.responsereturnvalue | httpexception,\nfrom_error_handler: bool = false,\n) -> response:\nresponse = self.make_response(rv)\ntry:\nresponse = self.process_response(response)\nrequest_finished.send(\nself, _async_wrapper=self.ensure_sync, response=response\n)\nexcept exception:\nif not from_error_handler:\nraise\nself.logger.exception(\n\"request finalizing failed with an error while handling an error\"\n)\nreturn response\ndef make_default_options_response(self) -> response:\nadapter = request_ctx.url_adapter\nmethods = adapter.allowed_methods()\nrv = self.response_class()\nrv.allow.update(methods)\nreturn rv\ndef ensure_sync(self, func: t.callable[..., t.any]) -> t.callable[..., t.any]:\nif iscoroutinefunction(func):\nreturn self.async_to_sync(func)\nreturn func\ndef async_to_sync(\nself, func: t.callable[..., t.coroutine[t.any, t.any, t.any]]\n) -> t.callable[..., t.any]:\ntry:\nfrom asgiref.sync import async_to_sync as asgiref_async_to_sync\nexcept importerror:\nraise runtimeerror(\n\"install flask with the 'async' extra in order to use async views.\"\n) from none\nreturn asgiref_async_to_sync(func)\ndef url_for(\nself,\n/,\nendpoint: str,\n*,\n_anchor: str | none = none,\n_method: str | none = none,\n_scheme: str | none = none,\n_external: bool | none = none,\n**values: t.any,\n) -> str:\nreq_ctx = _cv_request.get(none)\nif req_ctx is not none:\nurl_adapter = req_ctx.url_adapter\nblueprint_name = req_ctx.request.blueprint\nif endpoint[:1] == \".\":\nif blueprint_name is not none:\nendpoint = f\"{blueprint_name}{endpoint}\"\nelse:\nendpoint = endpoint[1:]\nif _external is none:\n_external = _scheme is not none\nelse:\napp_ctx = _cv_app.get(none)\nif app_ctx is not none:\nurl_adapter = app_ctx.url_adapter\nelse:\nurl_adapter = self.create_url_adapter(none)\nif url_adapter is none:\nraise runtimeerror(", "if endpoint[:1] == \".\":\nif blueprint_name is not none:\nendpoint = f\"{blueprint_name}{endpoint}\"\nelse:\nendpoint = endpoint[1:]\nif _external is none:\n_external = _scheme is not none\nelse:\napp_ctx = _cv_app.get(none)\nif app_ctx is not none:\nurl_adapter = app_ctx.url_adapter\nelse:\nurl_adapter = self.create_url_adapter(none)\nif url_adapter is none:\nraise runtimeerror(\n\"unable to build urls outside an active request\"\n\" without 'server_name' configured. also configure\"\n\" 'application_root' and 'preferred_url_scheme' as\"\n\" needed.\"\n)\nif _external is none:\n_external = true\nif _scheme is not none and not _external:\nraise valueerror(\"when specifying '_scheme', '_external' must be true.\")\nself.inject_url_defaults(endpoint, values)\ntry:\nrv = url_adapter.build(\nendpoint,\nvalues,\nmethod=_method,\nurl_scheme=_scheme,\nforce_external=_external,\n)\nexcept builderror as error:\nvalues.update(\n_anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n)\nreturn self.handle_url_build_error(error, endpoint, values)\nif _anchor is not none:\n_anchor = _url_quote(_anchor, safe=\"%!\nrv = f\"{rv}\nreturn rv\ndef make_response(self, rv: ft.responsereturnvalue) -> response:\nstatus: int | none = none\nheaders: headersvalue | none = none\nif isinstance(rv, tuple):\nlen_rv = len(rv)\nif len_rv == 3:\nrv, status, headers = rv\nelif len_rv == 2:\nif isinstance(rv[1], (headers, dict, tuple, list)):\nrv, headers = rv\nelse:\nrv, status = rv\nelse:\nraise typeerror(\n\"the view function did not return a valid response tuple.\"\n\" the tuple must have the form (body, status, headers),\"\n\" (body, status), or (body, headers).\"\n)\nif rv is none:\nraise typeerror(\nf\"the view function for {request.endpoint!r} did not\"\n\" return a valid response. the function either returned\"\n\" none or ended without a return statement.\"\n)\nif not isinstance(rv, self.response_class):\nif isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.iterator):\nrv = self.response_class(\nrv,\nstatus=status,\nheaders=headers,\n)", ")\nif rv is none:\nraise typeerror(\nf\"the view function for {request.endpoint!r} did not\"\n\" return a valid response. the function either returned\"\n\" none or ended without a return statement.\"\n)\nif not isinstance(rv, self.response_class):\nif isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.iterator):\nrv = self.response_class(\nrv,\nstatus=status,\nheaders=headers,\n)\nstatus = headers = none\nelif isinstance(rv, (dict, list)):\nrv = self.json.response(rv)\nelif isinstance(rv, baseresponse) or callable(rv):\ntry:\nrv = self.response_class.force_type(\nrv,\nrequest.environ,\n)\nexcept typeerror as e:\nraise typeerror(\nf\"{e}\\nthe view function did not return a valid\"\n\" response. the return type must be a string,\"\n\" dict, list, tuple with headers or status,\"\n\" response instance, or wsgi callable, but it\"\nf\" was a {type(rv).__name__}.\"\n).with_traceback(sys.exc_info()[2]) from none\nelse:\nraise typeerror(\n\"the view function did not return a valid\"\n\" response. the return type must be a string,\"\n\" dict, list, tuple with headers or status,\"\n\" response instance, or wsgi callable, but it was a\"\nf\" {type(rv).__name__}.\"\n)\nrv = t.cast(response, rv)\nif status is not none:\nif isinstance(status, (str, bytes, bytearray)):\nrv.status = status\nelse:\nrv.status_code = status\nif headers:\nrv.headers.update(headers)\nreturn rv\ndef preprocess_request(self) -> ft.responsereturnvalue | none:\nnames = (none, *reversed(request.blueprints))\nfor name in names:\nif name in self.url_value_preprocessors:\nfor url_func in self.url_value_preprocessors[name]:\nurl_func(request.endpoint, request.view_args)\nfor name in names:\nif name in self.before_request_funcs:\nfor before_func in self.before_request_funcs[name]:\nrv = self.ensure_sync(before_func)()\nif rv is not none:\nreturn rv\nreturn none\ndef process_response(self, response: response) -> response:\nctx = request_ctx._get_current_object()\nfor func in ctx._after_request_functions:\nresponse = self.ensure_sync(func)(response)\nfor name in chain(request.blueprints, (none,)):\nif name in self.after_request_funcs:\nfor func in reversed(self.after_request_funcs[name]):", "for before_func in self.before_request_funcs[name]:\nrv = self.ensure_sync(before_func)()\nif rv is not none:\nreturn rv\nreturn none\ndef process_response(self, response: response) -> response:\nctx = request_ctx._get_current_object()\nfor func in ctx._after_request_functions:\nresponse = self.ensure_sync(func)(response)\nfor name in chain(request.blueprints, (none,)):\nif name in self.after_request_funcs:\nfor func in reversed(self.after_request_funcs[name]):\nresponse = self.ensure_sync(func)(response)\nif not self.session_interface.is_null_session(ctx.session):\nself.session_interface.save_session(self, ctx.session, response)\nreturn response\ndef do_teardown_request(\nself,\nexc: baseexception | none = _sentinel,\n) -> none:\nif exc is _sentinel:\nexc = sys.exc_info()[1]\nfor name in chain(request.blueprints, (none,)):\nif name in self.teardown_request_funcs:\nfor func in reversed(self.teardown_request_funcs[name]):\nself.ensure_sync(func)(exc)\nrequest_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\ndef do_teardown_appcontext(\nself,\nexc: baseexception | none = _sentinel,\n) -> none:\nif exc is _sentinel:\nexc = sys.exc_info()[1]\nfor func in reversed(self.teardown_appcontext_funcs):\nself.ensure_sync(func)(exc)\nappcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\ndef app_context(self) -> appcontext:\nreturn appcontext(self)\ndef request_context(self, environ: wsgienvironment) -> requestcontext:\nreturn requestcontext(self, environ)\ndef test_request_context(self, *args: t.any, **kwargs: t.any) -> requestcontext:\nfrom .testing import environbuilder\nbuilder = environbuilder(self, *args, **kwargs)\ntry:\nreturn self.request_context(builder.get_environ())\nfinally:\nbuilder.close()\ndef wsgi_app(\nself, environ: wsgienvironment, start_response: startresponse\n) -> cabc.iterable[bytes]:\nctx = self.request_context(environ)\nerror: baseexception | none = none\ntry:\ntry:\nctx.push()\nresponse = self.full_dispatch_request()\nexcept exception as e:\nerror = e\nresponse = self.handle_exception(e)\nexcept:\nerror = sys.exc_info()[1]\nraise\nreturn response(environ, start_response)\nfinally:\nif \"werkzeug.debug.preserve_context\" in environ:", ") -> cabc.iterable[bytes]:\nctx = self.request_context(environ)\nerror: baseexception | none = none\ntry:\ntry:\nctx.push()\nresponse = self.full_dispatch_request()\nexcept exception as e:\nerror = e\nresponse = self.handle_exception(e)\nexcept:\nerror = sys.exc_info()[1]\nraise\nreturn response(environ, start_response)\nfinally:\nif \"werkzeug.debug.preserve_context\" in environ:\nenviron[\"werkzeug.debug.preserve_context\"](_cv_app.get())\nenviron[\"werkzeug.debug.preserve_context\"](_cv_request.get())\nif error is not none and self.should_ignore_error(error):\nerror = none\nctx.pop(error)\ndef __call__(\nself, environ: wsgienvironment, start_response: startresponse\n) -> cabc.iterable[bytes]:\nreturn self.wsgi_app(environ, start_response)", "import sqlite3\nimport pytest\nfrom flaskr.db import get_db\ndef test_get_close_db(app):\nwith app.app_context():\ndb = get_db()\nassert db is get_db()\nwith pytest.raises(sqlite3.programmingerror) as e:\ndb.execute(\"select 1\")\nassert \"closed\" in str(e.value)\ndef test_init_db_command(runner, monkeypatch):\nclass recorder:\ncalled = false\ndef fake_init_db():\nrecorder.called = true\nmonkeypatch.setattr(\"flaskr.db.init_db\", fake_init_db)\nresult = runner.invoke(args=[\"init-db\"])\nassert \"initialized\" in result.output\nassert recorder.called", "from __future__ import annotations\nfrom flask import flask\nfrom flask import response\napp = flask(__name__)\n@app.after_request\ndef after_sync(response: response) -> response:\nreturn response()\n@app.after_request\nasync def after_async(response: response) -> response:\nreturn response()\n@app.before_request\ndef before_sync() -> none: ...\n@app.before_request\nasync def before_async() -> none: ...\n@app.teardown_appcontext\ndef teardown_sync(exc: baseexception | none) -> none: ...\n@app.teardown_appcontext\nasync def teardown_async(exc: baseexception | none) -> none: ...", "import io\nimport os\nimport pytest\nimport werkzeug.exceptions\nimport flask\nfrom flask.helpers import get_debug_flag\nclass fakepath:\ndef __init__(self, path):\nself.path = path\ndef __fspath__(self):\nreturn self.path\nclass pybytesio:\ndef __init__(self, *args, **kwargs):\nself._io = io.bytesio(*args, **kwargs)\ndef __getattr__(self, name):\nreturn getattr(self._io, name)\nclass testsendfile:\ndef test_send_file(self, app, req_ctx):\nrv = flask.send_file(\"static/index.html\")\nassert rv.direct_passthrough\nassert rv.mimetype == \"text/html\"\nwith app.open_resource(\"static/index.html\") as f:\nrv.direct_passthrough = false\nassert rv.data == f.read()\nrv.close()\ndef test_static_file(self, app, req_ctx):\nrv = app.send_static_file(\"index.html\")\nassert rv.cache_control.max_age is none\nrv.close()\nrv = flask.send_file(\"static/index.html\")\nassert rv.cache_control.max_age is none\nrv.close()\napp.config[\"send_file_max_age_default\"] = 3600\nrv = app.send_static_file(\"index.html\")\nassert rv.cache_control.max_age == 3600\nrv.close()\nrv = flask.send_file(\"static/index.html\")\nassert rv.cache_control.max_age == 3600\nrv.close()\nrv = app.send_static_file(fakepath(\"index.html\"))\nassert rv.cache_control.max_age == 3600\nrv.close()\nclass staticfileapp(flask.flask):\ndef get_send_file_max_age(self, filename):\nreturn 10\napp = staticfileapp(__name__)\nwith app.test_request_context():\nrv = app.send_static_file(\"index.html\")\nassert rv.cache_control.max_age == 10\nrv.close()\nrv = flask.send_file(\"static/index.html\")\nassert rv.cache_control.max_age == 10\nrv.close()\ndef test_send_from_directory(self, app, req_ctx):\napp.root_path = os.path.join(\nos.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n)\nrv = flask.send_from_directory(\"static\", \"hello.txt\")\nrv.direct_passthrough = false\nassert rv.data.strip() == b\"hello subdomain\"\nrv.close()\nclass testurlfor:\ndef test_url_for_with_anchor(self, app, req_ctx):\n@app.route(\"/\")\ndef index():\nreturn \"42\"", "app.root_path = os.path.join(\nos.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n)\nrv = flask.send_from_directory(\"static\", \"hello.txt\")\nrv.direct_passthrough = false\nassert rv.data.strip() == b\"hello subdomain\"\nrv.close()\nclass testurlfor:\ndef test_url_for_with_anchor(self, app, req_ctx):\n@app.route(\"/\")\ndef index():\nreturn \"42\"\nassert flask.url_for(\"index\", _anchor=\"x y\") == \"/\ndef test_url_for_with_scheme(self, app, req_ctx):\n@app.route(\"/\")\ndef index():\nreturn \"42\"\nassert (\nflask.url_for(\"index\", _external=true, _scheme=\"https\")\n== \"https:\n)\ndef test_url_for_with_scheme_not_external(self, app, req_ctx):\napp.add_url_rule(\"/\", endpoint=\"index\")\nurl = flask.url_for(\"index\", _scheme=\"https\")\nassert url == \"https:\nwith pytest.raises(valueerror):\nflask.url_for(\"index\", _scheme=\"https\", _external=false)\ndef test_url_for_with_alternating_schemes(self, app, req_ctx):\n@app.route(\"/\")\ndef index():\nreturn \"42\"\nassert flask.url_for(\"index\", _external=true) == \"http:\nassert (\nflask.url_for(\"index\", _external=true, _scheme=\"https\")\n== \"https:\n)\nassert flask.url_for(\"index\", _external=true) == \"http:\ndef test_url_with_method(self, app, req_ctx):\nfrom flask.views import methodview\nclass myview(methodview):\ndef get(self, id=none):\nif id is none:\nreturn \"list\"\nreturn f\"get {id:d}\"\ndef post(self):\nreturn \"create\"\nmyview = myview.as_view(\"myview\")\napp.add_url_rule(\"/myview/\", methods=[\"get\"], view_func=myview)\napp.add_url_rule(\"/myview/<int:id>\", methods=[\"get\"], view_func=myview)\napp.add_url_rule(\"/myview/create\", methods=[\"post\"], view_func=myview)\nassert flask.url_for(\"myview\", _method=\"get\") == \"/myview/\"\nassert flask.url_for(\"myview\", id=42, _method=\"get\") == \"/myview/42\"\nassert flask.url_for(\"myview\", _method=\"post\") == \"/myview/create\"\ndef test_url_for_with_self(self, app, req_ctx):\n@app.route(\"/<self>\")\ndef index(self):\nreturn \"42\"", "assert flask.url_for(\"myview\", _method=\"get\") == \"/myview/\"\nassert flask.url_for(\"myview\", id=42, _method=\"get\") == \"/myview/42\"\nassert flask.url_for(\"myview\", _method=\"post\") == \"/myview/create\"\ndef test_url_for_with_self(self, app, req_ctx):\n@app.route(\"/<self>\")\ndef index(self):\nreturn \"42\"\nassert flask.url_for(\"index\", self=\"2\") == \"/2\"\ndef test_redirect_no_app():\nresponse = flask.redirect(\"https:\nassert response.location == \"https:\nassert response.status_code == 307\ndef test_redirect_with_app(app):\ndef redirect(location, code=302):\nraise valueerror\napp.redirect = redirect\nwith app.app_context(), pytest.raises(valueerror):\nflask.redirect(\"other\")\ndef test_abort_no_app():\nwith pytest.raises(werkzeug.exceptions.unauthorized):\nflask.abort(401)\nwith pytest.raises(lookuperror):\nflask.abort(900)\ndef test_app_aborter_class():\nclass myaborter(werkzeug.exceptions.aborter):\npass\nclass myflask(flask.flask):\naborter_class = myaborter\napp = myflask(__name__)\nassert isinstance(app.aborter, myaborter)\ndef test_abort_with_app(app):\nclass my900error(werkzeug.exceptions.httpexception):\ncode = 900\napp.aborter.mapping[900] = my900error\nwith app.app_context(), pytest.raises(my900error):\nflask.abort(900)\nclass testnoimports:\ndef test_name_with_import_error(self, modules_tmp_path):\n(modules_tmp_path / \"importerror.py\").write_text(\"raise notimplementederror()\")\ntry:\nflask.flask(\"importerror\")\nexcept notimplementederror:\nassertionerror(\"flask(import_name) is importing import_name.\")\nclass teststreaming:\ndef test_streaming_with_context(self, app, client):\n@app.route(\"/\")\ndef index():\ndef generate():\nyield \"hello \"\nyield flask.request.args[\"name\"]\nyield \"!\"\nreturn flask.response(flask.stream_with_context(generate()))\nrv = client.get(\"/?name=world\")\nassert rv.data == b\"hello world!\"\ndef test_streaming_with_context_as_decorator(self, app, client):\n@app.route(\"/\")\ndef index():\n@flask.stream_with_context\ndef generate(hello):\nyield hello\nyield flask.request.args[\"name\"]\nyield \"!\"\nreturn flask.response(generate(\"hello \"))\nrv = client.get(\"/?name=world\")", "yield \"!\"\nreturn flask.response(flask.stream_with_context(generate()))\nrv = client.get(\"/?name=world\")\nassert rv.data == b\"hello world!\"\ndef test_streaming_with_context_as_decorator(self, app, client):\n@app.route(\"/\")\ndef index():\n@flask.stream_with_context\ndef generate(hello):\nyield hello\nyield flask.request.args[\"name\"]\nyield \"!\"\nreturn flask.response(generate(\"hello \"))\nrv = client.get(\"/?name=world\")\nassert rv.data == b\"hello world!\"\ndef test_streaming_with_context_and_custom_close(self, app, client):\ncalled = []\nclass wrapper:\ndef __init__(self, gen):\nself._gen = gen\ndef __iter__(self):\nreturn self\ndef close(self):\ncalled.append(42)\ndef __next__(self):\nreturn next(self._gen)\nnext = __next__\n@app.route(\"/\")\ndef index():\ndef generate():\nyield \"hello \"\nyield flask.request.args[\"name\"]\nyield \"!\"\nreturn flask.response(flask.stream_with_context(wrapper(generate())))\nrv = client.get(\"/?name=world\")\nassert rv.data == b\"hello world!\"\nassert called == [42]\ndef test_stream_keeps_session(self, app, client):\n@app.route(\"/\")\ndef index():\nflask.session[\"test\"] = \"flask\"\n@flask.stream_with_context\ndef gen():\nyield flask.session[\"test\"]\nreturn flask.response(gen())\nrv = client.get(\"/\")\nassert rv.data == b\"flask\"\nclass testhelpers:\n@pytest.mark.parametrize(\n(\"debug\", \"expect\"),\n[\n(\"\", false),\n(\"0\", false),\n(\"false\", false),\n(\"no\", false),\n(\"true\", true),\n],\n)\ndef test_get_debug_flag(self, monkeypatch, debug, expect):\nmonkeypatch.setenv(\"flask_debug\", debug)\nassert get_debug_flag() == expect\ndef test_make_response(self):\napp = flask.flask(__name__)\nwith app.test_request_context():\nrv = flask.helpers.make_response()\nassert rv.status_code == 200\nassert rv.mimetype == \"text/html\"\nrv = flask.helpers.make_response(\"hello\")\nassert rv.status_code == 200\nassert rv.data == b\"hello\"\nassert rv.mimetype == \"text/html\"\n@pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\ndef test_open_resource(mode):\napp = flask.flask(__name__)\nwith app.open_resource(\"static/index.html\", mode) as f:\nassert \"<h1>hello world!</h1>\" in str(f.read())", "rv = flask.helpers.make_response(\"hello\")\nassert rv.status_code == 200\nassert rv.data == b\"hello\"\nassert rv.mimetype == \"text/html\"\n@pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\ndef test_open_resource(mode):\napp = flask.flask(__name__)\nwith app.open_resource(\"static/index.html\", mode) as f:\nassert \"<h1>hello world!</h1>\" in str(f.read())\n@pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\ndef test_open_resource_exceptions(mode):\napp = flask.flask(__name__)\nwith pytest.raises(valueerror):\napp.open_resource(\"static/index.html\", mode)\n@pytest.mark.parametrize(\"encoding\", (\"utf-8\", \"utf-16-le\"))\ndef test_open_resource_with_encoding(tmp_path, encoding):\napp = flask.flask(__name__, root_path=os.fspath(tmp_path))\n(tmp_path / \"test\").write_text(\"test\", encoding=encoding)\nwith app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\nassert f.read() == \"test\"", "import os\nimport tempfile\nimport pytest\nfrom flaskr import create_app\nfrom flaskr.db import get_db\nfrom flaskr.db import init_db\nwith open(os.path.join(os.path.dirname(__file__), \"data.sql\"), \"rb\") as f:\n_data_sql = f.read().decode(\"utf8\")\n@pytest.fixture\ndef app():\ndb_fd, db_path = tempfile.mkstemp()\napp = create_app({\"testing\": true, \"database\": db_path})\nwith app.app_context():\ninit_db()\nget_db().executescript(_data_sql)\nyield app\nos.close(db_fd)\nos.unlink(db_path)\n@pytest.fixture\ndef client(app):\nreturn app.test_client()\n@pytest.fixture\ndef runner(app):\nreturn app.test_cli_runner()\nclass authactions:\ndef __init__(self, client):\nself._client = client\ndef login(self, username=\"test\", password=\"test\"):\nreturn self._client.post(\n\"/auth/login\", data={\"username\": username, \"password\": password}\n)\ndef logout(self):\nreturn self._client.get(\"/auth/logout\")\n@pytest.fixture\ndef auth(client):\nreturn authactions(client)", "import time\nfrom celery import shared_task\nfrom celery import task\n@shared_task(ignore_result=false)\ndef add(a: int, b: int) -> int:\nreturn a + b\n@shared_task()\ndef block() -> none:\ntime.sleep(5)\n@shared_task(bind=true, ignore_result=false)\ndef process(self: task, total: int) -> object:\nfor i in range(total):\nself.update_state(state=\"progress\", meta={\"current\": i + 1, \"total\": total})\ntime.sleep(1)\nreturn {\"current\": total, \"total\": total}", "from werkzeug.routing import baseconverter\nfrom flask import request\nfrom flask import session\nfrom flask import url_for\ndef test_custom_converters(app, client):\nclass listconverter(baseconverter):\ndef to_python(self, value):\nreturn value.split(\",\")\ndef to_url(self, value):\nbase_to_url = super().to_url\nreturn \",\".join(base_to_url(x) for x in value)\napp.url_map.converters[\"list\"] = listconverter\n@app.route(\"/<list:args>\")\ndef index(args):\nreturn \"|\".join(args)\nassert client.get(\"/1,2,3\").data == b\"1|2|3\"\nwith app.test_request_context():\nassert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"\ndef test_context_available(app, client):\nclass contextconverter(baseconverter):\ndef to_python(self, value):\nassert request is not none\nassert session is not none\nreturn value\napp.url_map.converters[\"ctx\"] = contextconverter\n@app.get(\"/<ctx:name>\")\ndef index(name):\nreturn name\nassert client.get(\"/admin\").data == b\"admin\"", "from flask import blueprint\nfrom flask import flash\nfrom flask import g\nfrom flask import redirect\nfrom flask import render_template\nfrom flask import request\nfrom flask import url_for\nfrom werkzeug.exceptions import abort\nfrom .auth import login_required\nfrom .db import get_db\nbp = blueprint(\"blog\", __name__)\n@bp.route(\"/\")\ndef index():\ndb = get_db()\nposts = db.execute(\n\"select p.id, title, body, created, author_id, username\"\n\" from post p join user u on p.author_id = u.id\"\n\" order by created desc\"\n).fetchall()\nreturn render_template(\"blog/index.html\", posts=posts)\ndef get_post(id, check_author=true):\npost = (\nget_db()\n.execute(\n\"select p.id, title, body, created, author_id, username\"\n\" from post p join user u on p.author_id = u.id\"\n\" where p.id = ?\",\n(id,),\n)\n.fetchone()\n)\nif post is none:\nabort(404, f\"post id {id} doesn't exist.\")\nif check_author and post[\"author_id\"] != g.user[\"id\"]:\nabort(403)\nreturn post\n@bp.route(\"/create\", methods=(\"get\", \"post\"))\n@login_required\ndef create():\nif request.method == \"post\":\ntitle = request.form[\"title\"]\nbody = request.form[\"body\"]\nerror = none\nif not title:\nerror = \"title is required.\"\nif error is not none:\nflash(error)\nelse:\ndb = get_db()\ndb.execute(\n\"insert into post (title, body, author_id) values (?, ?, ?)\",\n(title, body, g.user[\"id\"]),\n)\ndb.commit()\nreturn redirect(url_for(\"blog.index\"))\nreturn render_template(\"blog/create.html\")\n@bp.route(\"/<int:id>/update\", methods=(\"get\", \"post\"))\n@login_required\ndef update(id):\npost = get_post(id)\nif request.method == \"post\":\ntitle = request.form[\"title\"]\nbody = request.form[\"body\"]\nerror = none\nif not title:\nerror = \"title is required.\"\nif error is not none:\nflash(error)\nelse:\ndb = get_db()\ndb.execute(\n\"update post set title = ?, body = ? where id = ?\", (title, body, id)\n)\ndb.commit()\nreturn redirect(url_for(\"blog.index\"))\nreturn render_template(\"blog/update.html\", post=post)\n@bp.route(\"/<int:id>/delete\", methods=(\"post\",))\n@login_required", "error = none\nif not title:\nerror = \"title is required.\"\nif error is not none:\nflash(error)\nelse:\ndb = get_db()\ndb.execute(\n\"update post set title = ?, body = ? where id = ?\", (title, body, id)\n)\ndb.commit()\nreturn redirect(url_for(\"blog.index\"))\nreturn render_template(\"blog/update.html\", post=post)\n@bp.route(\"/<int:id>/delete\", methods=(\"post\",))\n@login_required\ndef delete(id):\nget_post(id)\ndb = get_db()\ndb.execute(\"delete from post where id = ?\", (id,))\ndb.commit()\nreturn redirect(url_for(\"blog.index\"))", "from __future__ import annotations\nimport ast\nimport collections.abc as cabc\nimport importlib.metadata\nimport inspect\nimport os\nimport platform\nimport re\nimport sys\nimport traceback\nimport typing as t\nfrom functools import update_wrapper\nfrom operator import itemgetter\nfrom types import moduletype\nimport click\nfrom click.core import parametersource\nfrom werkzeug import run_simple\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.utils import import_string\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom .helpers import get_load_dotenv\nif t.type_checking:\nimport ssl\nfrom _typeshed.wsgi import startresponse\nfrom _typeshed.wsgi import wsgiapplication\nfrom _typeshed.wsgi import wsgienvironment\nfrom .app import flask\nclass noappexception(click.usageerror):\ndef find_best_app(module: moduletype) -> flask:\nfrom . import flask\nfor attr_name in (\"app\", \"application\"):\napp = getattr(module, attr_name, none)\nif isinstance(app, flask):\nreturn app\nmatches = [v for v in module.__dict__.values() if isinstance(v, flask)]\nif len(matches) == 1:\nreturn matches[0]\nelif len(matches) > 1:\nraise noappexception(\n\"detected multiple flask applications in module\"\nf\" '{module.__name__}'. use '{module.__name__}:name'\"\n\" to specify the correct one.\"\n)\nfor attr_name in (\"create_app\", \"make_app\"):\napp_factory = getattr(module, attr_name, none)\nif inspect.isfunction(app_factory):\ntry:\napp = app_factory()\nif isinstance(app, flask):\nreturn app\nexcept typeerror as e:\nif not _called_with_wrong_args(app_factory):\nraise\nraise noappexception(\nf\"detected factory '{attr_name}' in module '{module.__name__}',\"\n\" but could not call it without arguments. use\"\nf\" '{module.__name__}:{attr_name}(args)'\"\n\" to specify arguments.\"\n) from e\nraise noappexception(\n\"failed to find flask application or factory in module\"\nf\" '{module.__name__}'. use '{module.__name__}:name'\"\n\" to specify one.\"\n)\ndef _called_with_wrong_args(f: t.callable[..., flask]) -> bool:\ntb = sys.exc_info()[2]\ntry:\nwhile tb is not none:", "f\" '{module.__name__}:{attr_name}(args)'\"\n\" to specify arguments.\"\n) from e\nraise noappexception(\n\"failed to find flask application or factory in module\"\nf\" '{module.__name__}'. use '{module.__name__}:name'\"\n\" to specify one.\"\n)\ndef _called_with_wrong_args(f: t.callable[..., flask]) -> bool:\ntb = sys.exc_info()[2]\ntry:\nwhile tb is not none:\nif tb.tb_frame.f_code is f.__code__:\nreturn false\ntb = tb.tb_next\nreturn true\nfinally:\ndel tb\ndef find_app_by_string(module: moduletype, app_name: str) -> flask:\nfrom . import flask\ntry:\nexpr = ast.parse(app_name.strip(), mode=\"eval\").body\nexcept syntaxerror:\nraise noappexception(\nf\"failed to parse {app_name!r} as an attribute name or function call.\"\n) from none\nif isinstance(expr, ast.name):\nname = expr.id\nargs = []\nkwargs = {}\nelif isinstance(expr, ast.call):\nif not isinstance(expr.func, ast.name):\nraise noappexception(\nf\"function reference must be a simple name: {app_name!r}.\"\n)\nname = expr.func.id\ntry:\nargs = [ast.literal_eval(arg) for arg in expr.args]\nkwargs = {\nkw.arg: ast.literal_eval(kw.value)\nfor kw in expr.keywords\nif kw.arg is not none\n}\nexcept valueerror:\nraise noappexception(\nf\"failed to parse arguments as literal values: {app_name!r}.\"\n) from none\nelse:\nraise noappexception(\nf\"failed to parse {app_name!r} as an attribute name or function call.\"\n)\ntry:\nattr = getattr(module, name)\nexcept attributeerror as e:\nraise noappexception(\nf\"failed to find attribute {name!r} in {module.__name__!r}.\"\n) from e\nif inspect.isfunction(attr):\ntry:\napp = attr(*args, **kwargs)\nexcept typeerror as e:\nif not _called_with_wrong_args(attr):\nraise\nraise noappexception(\nf\"the factory {app_name!r} in module\"\nf\" {module.__name__!r} could not be called with the\"\n\" specified arguments.\"\n) from e\nelse:\napp = attr\nif isinstance(app, flask):\nreturn app\nraise noappexception(\n\"a valid flask application was not obtained from\"", "try:\napp = attr(*args, **kwargs)\nexcept typeerror as e:\nif not _called_with_wrong_args(attr):\nraise\nraise noappexception(\nf\"the factory {app_name!r} in module\"\nf\" {module.__name__!r} could not be called with the\"\n\" specified arguments.\"\n) from e\nelse:\napp = attr\nif isinstance(app, flask):\nreturn app\nraise noappexception(\n\"a valid flask application was not obtained from\"\nf\" '{module.__name__}:{app_name}'.\"\n)\ndef prepare_import(path: str) -> str:\npath = os.path.realpath(path)\nfname, ext = os.path.splitext(path)\nif ext == \".py\":\npath = fname\nif os.path.basename(path) == \"__init__\":\npath = os.path.dirname(path)\nmodule_name = []\nwhile true:\npath, name = os.path.split(path)\nmodule_name.append(name)\nif not os.path.exists(os.path.join(path, \"__init__.py\")):\nbreak\nif sys.path[0] != path:\nsys.path.insert(0, path)\nreturn \".\".join(module_name[::-1])\n@t.overload\ndef locate_app(\nmodule_name: str, app_name: str | none, raise_if_not_found: t.literal[true] = true\n) -> flask: ...\n@t.overload\ndef locate_app(\nmodule_name: str, app_name: str | none, raise_if_not_found: t.literal[false] = ...\n) -> flask | none: ...\ndef locate_app(\nmodule_name: str, app_name: str | none, raise_if_not_found: bool = true\n) -> flask | none:\ntry:\n__import__(module_name)\nexcept importerror:\nif sys.exc_info()[2].tb_next:\nraise noappexception(\nf\"while importing {module_name!r}, an importerror was\"\nf\" raised:\\n\\n{traceback.format_exc()}\"\n) from none\nelif raise_if_not_found:\nraise noappexception(f\"could not import {module_name!r}.\") from none\nelse:\nreturn none\nmodule = sys.modules[module_name]\nif app_name is none:\nreturn find_best_app(module)\nelse:\nreturn find_app_by_string(module, app_name)\ndef get_version(ctx: click.context, param: click.parameter, value: t.any) -> none:\nif not value or ctx.resilient_parsing:\nreturn\nflask_version = importlib.metadata.version(\"flask\")", "else:\nreturn none\nmodule = sys.modules[module_name]\nif app_name is none:\nreturn find_best_app(module)\nelse:\nreturn find_app_by_string(module, app_name)\ndef get_version(ctx: click.context, param: click.parameter, value: t.any) -> none:\nif not value or ctx.resilient_parsing:\nreturn\nflask_version = importlib.metadata.version(\"flask\")\nwerkzeug_version = importlib.metadata.version(\"werkzeug\")\nclick.echo(\nf\"python {platform.python_version()}\\n\"\nf\"flask {flask_version}\\n\"\nf\"werkzeug {werkzeug_version}\",\ncolor=ctx.color,\n)\nctx.exit()\nversion_option = click.option(\n[\"--version\"],\nhelp=\"show the flask version.\",\nexpose_value=false,\ncallback=get_version,\nis_flag=true,\nis_eager=true,\n)\nclass scriptinfo:\ndef __init__(\nself,\napp_import_path: str | none = none,\ncreate_app: t.callable[..., flask] | none = none,\nset_debug_flag: bool = true,\nload_dotenv_defaults: bool = true,\n) -> none:\nself.app_import_path = app_import_path\nself.create_app = create_app\nself.data: dict[t.any, t.any] = {}\nself.set_debug_flag = set_debug_flag\nself.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)\nself._loaded_app: flask | none = none\ndef load_app(self) -> flask:\nif self._loaded_app is not none:\nreturn self._loaded_app\napp: flask | none = none\nif self.create_app is not none:\napp = self.create_app()\nelse:\nif self.app_import_path:\npath, name = (\nre.split(r\":(?![\\\\/])\", self.app_import_path, maxsplit=1) + [none]\n)[:2]\nimport_name = prepare_import(path)\napp = locate_app(import_name, name)\nelse:\nfor path in (\"wsgi.py\", \"app.py\"):\nimport_name = prepare_import(path)\napp = locate_app(import_name, none, raise_if_not_found=false)\nif app is not none:\nbreak\nif app is none:\nraise noappexception(\n\"could not locate a flask application. use the\"\n\" 'flask --app' option, 'flask_app' environment\"\n\" variable, or a 'wsgi.py' or 'app.py' file in the\"\n\" current directory.\"\n)\nif self.set_debug_flag:\napp.debug = get_debug_flag()", "app = locate_app(import_name, none, raise_if_not_found=false)\nif app is not none:\nbreak\nif app is none:\nraise noappexception(\n\"could not locate a flask application. use the\"\n\" 'flask --app' option, 'flask_app' environment\"\n\" variable, or a 'wsgi.py' or 'app.py' file in the\"\n\" current directory.\"\n)\nif self.set_debug_flag:\napp.debug = get_debug_flag()\nself._loaded_app = app\nreturn app\npass_script_info = click.make_pass_decorator(scriptinfo, ensure=true)\nf = t.typevar(\"f\", bound=t.callable[..., t.any])\ndef with_appcontext(f: f) -> f:\n@click.pass_context\ndef decorator(ctx: click.context, /, *args: t.any, **kwargs: t.any) -> t.any:\nif not current_app:\napp = ctx.ensure_object(scriptinfo).load_app()\nctx.with_resource(app.app_context())\nreturn ctx.invoke(f, *args, **kwargs)\nreturn update_wrapper(decorator, f)\nclass appgroup(click.group):\ndef command(\nself, *args: t.any, **kwargs: t.any\n) -> t.callable[[t.callable[..., t.any]], click.command]:\nwrap_for_ctx = kwargs.pop(\"with_appcontext\", true)\ndef decorator(f: t.callable[..., t.any]) -> click.command:\nif wrap_for_ctx:\nf = with_appcontext(f)\nreturn super(appgroup, self).command(*args, **kwargs)(f)\nreturn decorator\ndef group(\nself, *args: t.any, **kwargs: t.any\n) -> t.callable[[t.callable[..., t.any]], click.group]:\nkwargs.setdefault(\"cls\", appgroup)\nreturn super().group(*args, **kwargs)\ndef _set_app(ctx: click.context, param: click.option, value: str | none) -> str | none:\nif value is none:\nreturn none\ninfo = ctx.ensure_object(scriptinfo)\ninfo.app_import_path = value\nreturn value\n_app_option = click.option(\n[\"-a\", \"--app\"],\nmetavar=\"import\",\nhelp=(\n\"the flask application or factory function to load, in the form 'module:name'.\"\n\" module can be a dotted import or file path. name is not required if it is\"\n\" 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to\"\n\" pass arguments.\"\n),", "info.app_import_path = value\nreturn value\n_app_option = click.option(\n[\"-a\", \"--app\"],\nmetavar=\"import\",\nhelp=(\n\"the flask application or factory function to load, in the form 'module:name'.\"\n\" module can be a dotted import or file path. name is not required if it is\"\n\" 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to\"\n\" pass arguments.\"\n),\nis_eager=true,\nexpose_value=false,\ncallback=_set_app,\n)\ndef _set_debug(ctx: click.context, param: click.option, value: bool) -> bool | none:\nsource = ctx.get_parameter_source(param.name)\nif source is not none and source in (\nparametersource.default,\nparametersource.default_map,\n):\nreturn none\nos.environ[\"flask_debug\"] = \"1\" if value else \"0\"\nreturn value\n_debug_option = click.option(\n[\"--debug/--no-debug\"],\nhelp=\"set debug mode.\",\nexpose_value=false,\ncallback=_set_debug,\n)\ndef _env_file_callback(\nctx: click.context, param: click.option, value: str | none\n) -> str | none:\ntry:\nimport dotenv\nexcept importerror:\nif value is not none:\nraise click.badparameter(\n\"python-dotenv must be installed to load an env file.\",\nctx=ctx,\nparam=param,\n) from none\nif value is not none or ctx.obj.load_dotenv_defaults:\nload_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\nreturn value\n_env_file_option = click.option(\n[\"-e\", \"--env-file\"],\ntype=click.path(exists=true, dir_okay=false),\nhelp=(\n\"load environment variables from this file, taking precedence over\"\n\" those set by '.env' and '.flaskenv'. variables set directly in the\"\n\" environment take highest precedence. python-dotenv must be installed.\"\n),\nis_eager=true,\nexpose_value=false,\ncallback=_env_file_callback,\n)\nclass flaskgroup(appgroup):\ndef __init__(\nself,\nadd_default_commands: bool = true,\ncreate_app: t.callable[..., flask] | none = none,\nadd_version_option: bool = true,\nload_dotenv: bool = true,\nset_debug_flag: bool = true,\n**extra: t.any,\n) -> none:\nparams: list[click.parameter] = list(extra.pop(\"params\", none) or ())", "expose_value=false,\ncallback=_env_file_callback,\n)\nclass flaskgroup(appgroup):\ndef __init__(\nself,\nadd_default_commands: bool = true,\ncreate_app: t.callable[..., flask] | none = none,\nadd_version_option: bool = true,\nload_dotenv: bool = true,\nset_debug_flag: bool = true,\n**extra: t.any,\n) -> none:\nparams: list[click.parameter] = list(extra.pop(\"params\", none) or ())\nparams.extend((_env_file_option, _app_option, _debug_option))\nif add_version_option:\nparams.append(version_option)\nif \"context_settings\" not in extra:\nextra[\"context_settings\"] = {}\nextra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"flask\")\nsuper().__init__(params=params, **extra)\nself.create_app = create_app\nself.load_dotenv = load_dotenv\nself.set_debug_flag = set_debug_flag\nif add_default_commands:\nself.add_command(run_command)\nself.add_command(shell_command)\nself.add_command(routes_command)\nself._loaded_plugin_commands = false\ndef _load_plugin_commands(self) -> none:\nif self._loaded_plugin_commands:\nreturn\nif sys.version_info >= (3, 10):\nfrom importlib import metadata\nelse:\nimport importlib_metadata as metadata\nfor ep in metadata.entry_points(group=\"flask.commands\"):\nself.add_command(ep.load(), ep.name)\nself._loaded_plugin_commands = true\ndef get_command(self, ctx: click.context, name: str) -> click.command | none:\nself._load_plugin_commands()\nrv = super().get_command(ctx, name)\nif rv is not none:\nreturn rv\ninfo = ctx.ensure_object(scriptinfo)\ntry:\napp = info.load_app()\nexcept noappexception as e:\nclick.secho(f\"error: {e.format_message()}\\n\", err=true, fg=\"red\")\nreturn none\nif not current_app or current_app._get_current_object() is not app:\nctx.with_resource(app.app_context())\nreturn app.cli.get_command(ctx, name)\ndef list_commands(self, ctx: click.context) -> list[str]:\nself._load_plugin_commands()\nrv = set(super().list_commands(ctx))\ninfo = ctx.ensure_object(scriptinfo)\ntry:\nrv.update(info.load_app().cli.list_commands(ctx))\nexcept noappexception as e:\nclick.secho(f\"error: {e.format_message()}\\n\", err=true, fg=\"red\")\nexcept exception:", "ctx.with_resource(app.app_context())\nreturn app.cli.get_command(ctx, name)\ndef list_commands(self, ctx: click.context) -> list[str]:\nself._load_plugin_commands()\nrv = set(super().list_commands(ctx))\ninfo = ctx.ensure_object(scriptinfo)\ntry:\nrv.update(info.load_app().cli.list_commands(ctx))\nexcept noappexception as e:\nclick.secho(f\"error: {e.format_message()}\\n\", err=true, fg=\"red\")\nexcept exception:\nclick.secho(f\"{traceback.format_exc()}\\n\", err=true, fg=\"red\")\nreturn sorted(rv)\ndef make_context(\nself,\ninfo_name: str | none,\nargs: list[str],\nparent: click.context | none = none,\n**extra: t.any,\n) -> click.context:\nos.environ[\"flask_run_from_cli\"] = \"true\"\nif \"obj\" not in extra and \"obj\" not in self.context_settings:\nextra[\"obj\"] = scriptinfo(\ncreate_app=self.create_app,\nset_debug_flag=self.set_debug_flag,\nload_dotenv_defaults=self.load_dotenv,\n)\nreturn super().make_context(info_name, args, parent=parent, **extra)\ndef parse_args(self, ctx: click.context, args: list[str]) -> list[str]:\nif (not args and self.no_args_is_help) or (\nlen(args) == 1 and args[0] in self.get_help_option_names(ctx)\n):\n_env_file_option.handle_parse_result(ctx, {}, [])\n_app_option.handle_parse_result(ctx, {}, [])\nreturn super().parse_args(ctx, args)\ndef _path_is_ancestor(path: str, other: str) -> bool:\nreturn os.path.join(path, other[len(path) :].lstrip(os.sep)) == other\ndef load_dotenv(\npath: str | os.pathlike[str] | none = none, load_defaults: bool = true\n) -> bool:\ntry:\nimport dotenv\nexcept importerror:\nif path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\nclick.secho(\n\" * tip: there are .env files present. install python-dotenv\"\n\" to use them.\",\nfg=\"yellow\",\nerr=true,\n)\nreturn false\ndata: dict[str, str | none] = {}\nif load_defaults:\nfor default_name in (\".flaskenv\", \".env\"):\nif not (default_path := dotenv.find_dotenv(default_name, usecwd=true)):\ncontinue", "click.secho(\n\" * tip: there are .env files present. install python-dotenv\"\n\" to use them.\",\nfg=\"yellow\",\nerr=true,\n)\nreturn false\ndata: dict[str, str | none] = {}\nif load_defaults:\nfor default_name in (\".flaskenv\", \".env\"):\nif not (default_path := dotenv.find_dotenv(default_name, usecwd=true)):\ncontinue\ndata |= dotenv.dotenv_values(default_path, encoding=\"utf-8\")\nif path is not none and os.path.isfile(path):\ndata |= dotenv.dotenv_values(path, encoding=\"utf-8\")\nfor key, value in data.items():\nif key in os.environ or value is none:\ncontinue\nos.environ[key] = value\nreturn bool(data)\ndef show_server_banner(debug: bool, app_import_path: str | none) -> none:\nif is_running_from_reloader():\nreturn\nif app_import_path is not none:\nclick.echo(f\" * serving flask app '{app_import_path}'\")\nif debug is not none:\nclick.echo(f\" * debug mode: {'on' if debug else 'off'}\")\nclass certparamtype(click.paramtype):\nname = \"path\"\ndef __init__(self) -> none:\nself.path_type = click.path(exists=true, dir_okay=false, resolve_path=true)\ndef convert(\nself, value: t.any, param: click.parameter | none, ctx: click.context | none\n) -> t.any:\ntry:\nimport ssl\nexcept importerror:\nraise click.badparameter(\n'using \"--cert\" requires python to be compiled with ssl support.',\nctx,\nparam,\n) from none\ntry:\nreturn self.path_type(value, param, ctx)\nexcept click.badparameter:\nvalue = click.string(value, param, ctx).lower()\nif value == \"adhoc\":\ntry:\nimport cryptography\nexcept importerror:\nraise click.badparameter(\n\"using ad-hoc certificates requires the cryptography library.\",\nctx,\nparam,\n) from none\nreturn value\nobj = import_string(value, silent=true)\nif isinstance(obj, ssl.sslcontext):\nreturn obj\nraise\ndef _validate_key(ctx: click.context, param: click.parameter, value: t.any) -> t.any:\ncert = ctx.params.get(\"cert\")\nis_adhoc = cert == \"adhoc\"\ntry:\nimport ssl\nexcept importerror:\nis_context = false\nelse:\nis_context = isinstance(cert, ssl.sslcontext)\nif value is not none:\nif is_adhoc:", "obj = import_string(value, silent=true)\nif isinstance(obj, ssl.sslcontext):\nreturn obj\nraise\ndef _validate_key(ctx: click.context, param: click.parameter, value: t.any) -> t.any:\ncert = ctx.params.get(\"cert\")\nis_adhoc = cert == \"adhoc\"\ntry:\nimport ssl\nexcept importerror:\nis_context = false\nelse:\nis_context = isinstance(cert, ssl.sslcontext)\nif value is not none:\nif is_adhoc:\nraise click.badparameter(\n'when \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n)\nif is_context:\nraise click.badparameter(\n'when \"--cert\" is an sslcontext object, \"--key\" is not used.',\nctx,\nparam,\n)\nif not cert:\nraise click.badparameter('\"--cert\" must also be specified.', ctx, param)\nctx.params[\"cert\"] = cert, value\nelse:\nif cert and not (is_adhoc or is_context):\nraise click.badparameter('required when using \"--cert\".', ctx, param)\nreturn value\nclass separatedpathtype(click.path):\ndef convert(\nself, value: t.any, param: click.parameter | none, ctx: click.context | none\n) -> t.any:\nitems = self.split_envvar_value(value)\nsuper_convert = super().convert\nreturn [super_convert(item, param, ctx) for item in items]\n@click.command(\"run\", short_help=\"run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"the interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"the port to bind to.\")\n@click.option(\n\"--cert\",\ntype=certparamtype(),\nhelp=\"specify a certificate file to use https.\",\nis_eager=true,\n)\n@click.option(\n\"--key\",\ntype=click.path(exists=true, dir_okay=false, resolve_path=true),\ncallback=_validate_key,\nexpose_value=false,\nhelp=\"the key file to use when specifying a certificate.\",\n)\n@click.option(\n\"--reload/--no-reload\",\ndefault=none,\nhelp=\"enable or disable the reloader. by default the reloader \"\n\"is active if debug is enabled.\",\n)\n@click.option(\n\"--debugger/--no-debugger\",\ndefault=none,\nhelp=\"enable or disable the debugger. by default the debugger \"\n\"is active if debug is enabled.\",\n)\n@click.option(", "callback=_validate_key,\nexpose_value=false,\nhelp=\"the key file to use when specifying a certificate.\",\n)\n@click.option(\n\"--reload/--no-reload\",\ndefault=none,\nhelp=\"enable or disable the reloader. by default the reloader \"\n\"is active if debug is enabled.\",\n)\n@click.option(\n\"--debugger/--no-debugger\",\ndefault=none,\nhelp=\"enable or disable the debugger. by default the debugger \"\n\"is active if debug is enabled.\",\n)\n@click.option(\n\"--with-threads/--without-threads\",\ndefault=true,\nhelp=\"enable or disable multithreading.\",\n)\n@click.option(\n\"--extra-files\",\ndefault=none,\ntype=separatedpathtype(),\nhelp=(\n\"extra files that trigger a reload on change. multiple paths\"\nf\" are separated by {os.path.pathsep!r}.\"\n),\n)\n@click.option(\n\"--exclude-patterns\",\ndefault=none,\ntype=separatedpathtype(),\nhelp=(\n\"files matching these fnmatch patterns will not trigger a reload\"\n\" on change. multiple patterns are separated by\"\nf\" {os.path.pathsep!r}.\"\n),\n)\n@pass_script_info\ndef run_command(\ninfo: scriptinfo,\nhost: str,\nport: int,\nreload: bool,\ndebugger: bool,\nwith_threads: bool,\ncert: ssl.sslcontext | tuple[str, str | none] | t.literal[\"adhoc\"] | none,\nextra_files: list[str] | none,\nexclude_patterns: list[str] | none,\n) -> none:\ntry:\napp: wsgiapplication = info.load_app()\nexcept exception as e:\nif is_running_from_reloader():\ntraceback.print_exc()\nerr = e\ndef app(\nenviron: wsgienvironment, start_response: startresponse\n) -> cabc.iterable[bytes]:\nraise err from none\nelse:\nraise e from none\ndebug = get_debug_flag()\nif reload is none:\nreload = debug\nif debugger is none:\ndebugger = debug\nshow_server_banner(debug, info.app_import_path)\nrun_simple(\nhost,\nport,\napp,\nuse_reloader=reload,\nuse_debugger=debugger,\nthreaded=with_threads,\nssl_context=cert,\nextra_files=extra_files,\nexclude_patterns=exclude_patterns,\n)\nrun_command.params.insert(0, _debug_option)\n@click.command(\"shell\", short_help=\"run a shell in the app context.\")\n@with_appcontext\ndef shell_command() -> none:\nimport code\nbanner = (", "run_simple(\nhost,\nport,\napp,\nuse_reloader=reload,\nuse_debugger=debugger,\nthreaded=with_threads,\nssl_context=cert,\nextra_files=extra_files,\nexclude_patterns=exclude_patterns,\n)\nrun_command.params.insert(0, _debug_option)\n@click.command(\"shell\", short_help=\"run a shell in the app context.\")\n@with_appcontext\ndef shell_command() -> none:\nimport code\nbanner = (\nf\"python {sys.version} on {sys.platform}\\n\"\nf\"app: {current_app.import_name}\\n\"\nf\"instance: {current_app.instance_path}\"\n)\nctx: dict[str, t.any] = {}\nstartup = os.environ.get(\"pythonstartup\")\nif startup and os.path.isfile(startup):\nwith open(startup) as f:\neval(compile(f.read(), startup, \"exec\"), ctx)\nctx.update(current_app.make_shell_context())\ninteractive_hook = getattr(sys, \"__interactivehook__\", none)\nif interactive_hook is not none:\ntry:\nimport readline\nfrom rlcompleter import completer\nexcept importerror:\npass\nelse:\nreadline.set_completer(completer(ctx).complete)\ninteractive_hook()\ncode.interact(banner=banner, local=ctx)\n@click.command(\"routes\", short_help=\"show the routes for the app.\")\n@click.option(\n\"--sort\",\n\"-s\",\ntype=click.choice((\"endpoint\", \"methods\", \"domain\", \"rule\", \"match\")),\ndefault=\"endpoint\",\nhelp=(\n\"method to sort routes by. 'match' is the order that flask will match routes\"\n\" when dispatching a request.\"\n),\n)\n@click.option(\"--all-methods\", is_flag=true, help=\"show head and options methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> none:\nrules = list(current_app.url_map.iter_rules())\nif not rules:\nclick.echo(\"no routes were registered.\")\nreturn\nignored_methods = set() if all_methods else {\"head\", \"options\"}\nhost_matching = current_app.url_map.host_matching\nhas_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\nrows = []\nfor rule in rules:\nrow = [\nrule.endpoint,\n\", \".join(sorted((rule.methods or set()) - ignored_methods)),\n]\nif has_domain:\nrow.append((rule.host if host_matching else rule.subdomain) or \"\")\nrow.append(rule.rule)\nrows.append(row)\nheaders = [\"endpoint\", \"methods\"]", "host_matching = current_app.url_map.host_matching\nhas_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\nrows = []\nfor rule in rules:\nrow = [\nrule.endpoint,\n\", \".join(sorted((rule.methods or set()) - ignored_methods)),\n]\nif has_domain:\nrow.append((rule.host if host_matching else rule.subdomain) or \"\")\nrow.append(rule.rule)\nrows.append(row)\nheaders = [\"endpoint\", \"methods\"]\nsorts = [\"endpoint\", \"methods\"]\nif has_domain:\nheaders.append(\"host\" if host_matching else \"subdomain\")\nsorts.append(\"domain\")\nheaders.append(\"rule\")\nsorts.append(\"rule\")\ntry:\nrows.sort(key=itemgetter(sorts.index(sort)))\nexcept valueerror:\npass\nrows.insert(0, headers)\nwidths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\nrows.insert(1, [\"-\" * w for w in widths])\ntemplate = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\nfor row in rows:\nclick.echo(template.format(*row))\ncli = flaskgroup(\nname=\"flask\",\nhelp=,\n)\ndef main() -> none:\ncli.main()\nif __name__ == \"__main__\":\nmain()", "from __future__ import annotations\nimport typing as t\nfrom jinja2 import baseloader\nfrom jinja2 import environment as baseenvironment\nfrom jinja2 import template\nfrom jinja2 import templatenotfound\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .helpers import stream_with_context\nfrom .signals import before_render_template\nfrom .signals import template_rendered\nif t.type_checking:\nfrom .app import flask\nfrom .sansio.app import app\nfrom .sansio.scaffold import scaffold\ndef _default_template_ctx_processor() -> dict[str, t.any]:\nappctx = _cv_app.get(none)\nreqctx = _cv_request.get(none)\nrv: dict[str, t.any] = {}\nif appctx is not none:\nrv[\"g\"] = appctx.g\nif reqctx is not none:\nrv[\"request\"] = reqctx.request\nrv[\"session\"] = reqctx.session\nreturn rv\nclass environment(baseenvironment):\ndef __init__(self, app: app, **options: t.any) -> none:\nif \"loader\" not in options:\noptions[\"loader\"] = app.create_global_jinja_loader()\nbaseenvironment.__init__(self, **options)\nself.app = app\nclass dispatchingjinjaloader(baseloader):\ndef __init__(self, app: app) -> none:\nself.app = app\ndef get_source(\nself, environment: baseenvironment, template: str\n) -> tuple[str, str | none, t.callable[[], bool] | none]:\nif self.app.config[\"explain_template_loading\"]:\nreturn self._get_source_explained(environment, template)\nreturn self._get_source_fast(environment, template)\ndef _get_source_explained(\nself, environment: baseenvironment, template: str\n) -> tuple[str, str | none, t.callable[[], bool] | none]:\nattempts = []\nrv: tuple[str, str | none, t.callable[[], bool] | none] | none\ntrv: none | (tuple[str, str | none, t.callable[[], bool] | none]) = none\nfor srcobj, loader in self._iter_loaders(template):\ntry:\nrv = loader.get_source(environment, template)\nif trv is none:\ntrv = rv\nexcept templatenotfound:\nrv = none", "attempts = []\nrv: tuple[str, str | none, t.callable[[], bool] | none] | none\ntrv: none | (tuple[str, str | none, t.callable[[], bool] | none]) = none\nfor srcobj, loader in self._iter_loaders(template):\ntry:\nrv = loader.get_source(environment, template)\nif trv is none:\ntrv = rv\nexcept templatenotfound:\nrv = none\nattempts.append((loader, srcobj, rv))\nfrom .debughelpers import explain_template_loading_attempts\nexplain_template_loading_attempts(self.app, template, attempts)\nif trv is not none:\nreturn trv\nraise templatenotfound(template)\ndef _get_source_fast(\nself, environment: baseenvironment, template: str\n) -> tuple[str, str | none, t.callable[[], bool] | none]:\nfor _srcobj, loader in self._iter_loaders(template):\ntry:\nreturn loader.get_source(environment, template)\nexcept templatenotfound:\ncontinue\nraise templatenotfound(template)\ndef _iter_loaders(self, template: str) -> t.iterator[tuple[scaffold, baseloader]]:\nloader = self.app.jinja_loader\nif loader is not none:\nyield self.app, loader\nfor blueprint in self.app.iter_blueprints():\nloader = blueprint.jinja_loader\nif loader is not none:\nyield blueprint, loader\ndef list_templates(self) -> list[str]:\nresult = set()\nloader = self.app.jinja_loader\nif loader is not none:\nresult.update(loader.list_templates())\nfor blueprint in self.app.iter_blueprints():\nloader = blueprint.jinja_loader\nif loader is not none:\nfor template in loader.list_templates():\nresult.add(template)\nreturn list(result)\ndef _render(app: flask, template: template, context: dict[str, t.any]) -> str:\napp.update_template_context(context)\nbefore_render_template.send(\napp, _async_wrapper=app.ensure_sync, template=template, context=context\n)\nrv = template.render(context)\ntemplate_rendered.send(\napp, _async_wrapper=app.ensure_sync, template=template, context=context\n)\nreturn rv\ndef render_template(\ntemplate_name_or_list: str | template | list[str | template],\n**context: t.any,\n) -> str:\napp = current_app._get_current_object()\ntemplate = app.jinja_env.get_or_select_template(template_name_or_list)\nreturn _render(app, template, context)", ")\nrv = template.render(context)\ntemplate_rendered.send(\napp, _async_wrapper=app.ensure_sync, template=template, context=context\n)\nreturn rv\ndef render_template(\ntemplate_name_or_list: str | template | list[str | template],\n**context: t.any,\n) -> str:\napp = current_app._get_current_object()\ntemplate = app.jinja_env.get_or_select_template(template_name_or_list)\nreturn _render(app, template, context)\ndef render_template_string(source: str, **context: t.any) -> str:\napp = current_app._get_current_object()\ntemplate = app.jinja_env.from_string(source)\nreturn _render(app, template, context)\ndef _stream(\napp: flask, template: template, context: dict[str, t.any]\n) -> t.iterator[str]:\napp.update_template_context(context)\nbefore_render_template.send(\napp, _async_wrapper=app.ensure_sync, template=template, context=context\n)\ndef generate() -> t.iterator[str]:\nyield from template.generate(context)\ntemplate_rendered.send(\napp, _async_wrapper=app.ensure_sync, template=template, context=context\n)\nrv = generate()\nif request:\nrv = stream_with_context(rv)\nreturn rv\ndef stream_template(\ntemplate_name_or_list: str | template | list[str | template],\n**context: t.any,\n) -> t.iterator[str]:\napp = current_app._get_current_object()\ntemplate = app.jinja_env.get_or_select_template(template_name_or_list)\nreturn _stream(app, template, context)\ndef stream_template_string(source: str, **context: t.any) -> t.iterator[str]:\napp = current_app._get_current_object()\ntemplate = app.jinja_env.from_string(source)\nreturn _stream(app, template, context)", "from __future__ import annotations\nimport errno\nimport json\nimport os\nimport types\nimport typing as t\nfrom werkzeug.utils import import_string\nif t.type_checking:\nimport typing_extensions as te\nfrom .sansio.app import app\nt = t.typevar(\"t\")\nclass configattribute(t.generic[t]):\ndef __init__(\nself, name: str, get_converter: t.callable[[t.any], t] | none = none\n) -> none:\nself.__name__ = name\nself.get_converter = get_converter\n@t.overload\ndef __get__(self, obj: none, owner: none) -> te.self: ...\n@t.overload\ndef __get__(self, obj: app, owner: type[app]) -> t: ...\ndef __get__(self, obj: app | none, owner: type[app] | none = none) -> t | te.self:\nif obj is none:\nreturn self\nrv = obj.config[self.__name__]\nif self.get_converter is not none:\nrv = self.get_converter(rv)\nreturn rv\ndef __set__(self, obj: app, value: t.any) -> none:\nobj.config[self.__name__] = value\nclass config(dict):\ndef __init__(\nself,\nroot_path: str | os.pathlike[str],\ndefaults: dict[str, t.any] | none = none,\n) -> none:\nsuper().__init__(defaults or {})\nself.root_path = root_path\ndef from_envvar(self, variable_name: str, silent: bool = false) -> bool:\nrv = os.environ.get(variable_name)\nif not rv:\nif silent:\nreturn false\nraise runtimeerror(\nf\"the environment variable {variable_name!r} is not set\"\n\" and as such configuration could not be loaded. set\"\n\" this variable and make it point to a configuration\"\n\" file\"\n)\nreturn self.from_pyfile(rv, silent=silent)\ndef from_prefixed_env(\nself, prefix: str = \"flask\", *, loads: t.callable[[str], t.any] = json.loads\n) -> bool:\nprefix = f\"{prefix}_\"\nfor key in sorted(os.environ):\nif not key.startswith(prefix):\ncontinue\nvalue = os.environ[key]\nkey = key.removeprefix(prefix)\ntry:\nvalue = loads(value)\nexcept exception:\npass\nif \"__\" not in key:\nself[key] = value\ncontinue\ncurrent = self\n*parts, tail = key.split(\"__\")", ") -> bool:\nprefix = f\"{prefix}_\"\nfor key in sorted(os.environ):\nif not key.startswith(prefix):\ncontinue\nvalue = os.environ[key]\nkey = key.removeprefix(prefix)\ntry:\nvalue = loads(value)\nexcept exception:\npass\nif \"__\" not in key:\nself[key] = value\ncontinue\ncurrent = self\n*parts, tail = key.split(\"__\")\nfor part in parts:\nif part not in current:\ncurrent[part] = {}\ncurrent = current[part]\ncurrent[tail] = value\nreturn true\ndef from_pyfile(\nself, filename: str | os.pathlike[str], silent: bool = false\n) -> bool:\nfilename = os.path.join(self.root_path, filename)\nd = types.moduletype(\"config\")\nd.__file__ = filename\ntry:\nwith open(filename, mode=\"rb\") as config_file:\nexec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\nexcept oserror as e:\nif silent and e.errno in (errno.enoent, errno.eisdir, errno.enotdir):\nreturn false\ne.strerror = f\"unable to load configuration file ({e.strerror})\"\nraise\nself.from_object(d)\nreturn true\ndef from_object(self, obj: object | str) -> none:\nif isinstance(obj, str):\nobj = import_string(obj)\nfor key in dir(obj):\nif key.isupper():\nself[key] = getattr(obj, key)\ndef from_file(\nself,\nfilename: str | os.pathlike[str],\nload: t.callable[[t.io[t.any]], t.mapping[str, t.any]],\nsilent: bool = false,\ntext: bool = true,\n) -> bool:\nfilename = os.path.join(self.root_path, filename)\ntry:\nwith open(filename, \"r\" if text else \"rb\") as f:\nobj = load(f)\nexcept oserror as e:\nif silent and e.errno in (errno.enoent, errno.eisdir):\nreturn false\ne.strerror = f\"unable to load configuration file ({e.strerror})\"\nraise\nreturn self.from_mapping(obj)\ndef from_mapping(\nself, mapping: t.mapping[str, t.any] | none = none, **kwargs: t.any\n) -> bool:\nmappings: dict[str, t.any] = {}\nif mapping is not none:\nmappings.update(mapping)\nmappings.update(kwargs)\nfor key, value in mappings.items():\nif key.isupper():\nself[key] = value", "e.strerror = f\"unable to load configuration file ({e.strerror})\"\nraise\nreturn self.from_mapping(obj)\ndef from_mapping(\nself, mapping: t.mapping[str, t.any] | none = none, **kwargs: t.any\n) -> bool:\nmappings: dict[str, t.any] = {}\nif mapping is not none:\nmappings.update(mapping)\nmappings.update(kwargs)\nfor key, value in mappings.items():\nif key.isupper():\nself[key] = value\nreturn true\ndef get_namespace(\nself, namespace: str, lowercase: bool = true, trim_namespace: bool = true\n) -> dict[str, t.any]:\nrv = {}\nfor k, v in self.items():\nif not k.startswith(namespace):\ncontinue\nif trim_namespace:\nkey = k[len(namespace) :]\nelse:\nkey = k\nif lowercase:\nkey = key.lower()\nrv[key] = v\nreturn rv\ndef __repr__(self) -> str:\nreturn f\"<{type(self).__name__} {dict.__repr__(self)}>\"", "import packaging.version\nfrom pallets_sphinx_themes import get_version\nfrom pallets_sphinx_themes import projectlink\nproject = \"flask\"\ncopyright = \"2010 pallets\"\nauthor = \"pallets\"\nrelease, version = get_version(\"flask\")\ndefault_role = \"code\"\nextensions = [\n\"sphinx.ext.autodoc\",\n\"sphinx.ext.extlinks\",\n\"sphinx.ext.intersphinx\",\n\"sphinxcontrib.log_cabinet\",\n\"sphinx_tabs.tabs\",\n\"pallets_sphinx_themes\",\n]\nautodoc_member_order = \"bysource\"\nautodoc_typehints = \"description\"\nautodoc_preserve_defaults = true\nextlinks = {\n\"issue\": (\"https:\n\"pr\": (\"https:\n\"ghsa\": (\"https:\n}\nintersphinx_mapping = {\n\"python\": (\"https:\n\"werkzeug\": (\"https:\n\"click\": (\"https:\n\"jinja\": (\"https:\n\"itsdangerous\": (\"https:\n\"sqlalchemy\": (\"https:\n\"wtforms\": (\"https:\n\"blinker\": (\"https:\n}\nhtml_theme = \"flask\"\nhtml_theme_options = {\"index_sidebar_logo\": false}\nhtml_context = {\n\"project_links\": [\nprojectlink(\"donate\", \"https:\nprojectlink(\"pypi releases\", \"https:\nprojectlink(\"source code\", \"https:\nprojectlink(\"issue tracker\", \"https:\nprojectlink(\"chat\", \"https:\n]\n}\nhtml_sidebars = {\n\"index\": [\"project.html\", \"localtoc.html\", \"searchbox.html\", \"ethicalads.html\"],\n\"**\": [\"localtoc.html\", \"relations.html\", \"searchbox.html\", \"ethicalads.html\"],\n}\nsinglehtml_sidebars = {\"index\": [\"project.html\", \"localtoc.html\", \"ethicalads.html\"]}\nhtml_static_path = [\"_static\"]\nhtml_favicon = \"_static/shortcut-icon.png\"\nhtml_logo = \"_static/flask-vertical.png\"\nhtml_title = f\"flask documentation ({version})\"\nhtml_show_sourcelink = false\ngettext_uuid = true\ngettext_compact = false\ndef github_link(name, rawtext, text, lineno, inliner, options=none, content=none):\napp = inliner.document.settings.env.app\nrelease = app.config.release\nbase_url = \"https:\nif text.endswith(\">\"):\nwords, text = text[:-1].rsplit(\"<\", 1)\nwords = words.strip()\nelse:\nwords = none", "html_show_sourcelink = false\ngettext_uuid = true\ngettext_compact = false\ndef github_link(name, rawtext, text, lineno, inliner, options=none, content=none):\napp = inliner.document.settings.env.app\nrelease = app.config.release\nbase_url = \"https:\nif text.endswith(\">\"):\nwords, text = text[:-1].rsplit(\"<\", 1)\nwords = words.strip()\nelse:\nwords = none\nif packaging.version.parse(release).is_devrelease:\nurl = f\"{base_url}main/{text}\"\nelse:\nurl = f\"{base_url}{release}/{text}\"\nif words is none:\nwords = url\nfrom docutils.nodes import reference\nfrom docutils.parsers.rst.roles import set_classes\noptions = options or {}\nset_classes(options)\nnode = reference(rawtext, words, refuri=url, **options)\nreturn [node], []\ndef setup(app):\napp.add_role(\"gh\", github_link)", "from hello import app", "import pytest\nfrom flask import g\nfrom flask import session\nfrom flaskr.db import get_db\ndef test_register(client, app):\nassert client.get(\"/auth/register\").status_code == 200\nresponse = client.post(\"/auth/register\", data={\"username\": \"a\", \"password\": \"a\"})\nassert response.headers[\"location\"] == \"/auth/login\"\nwith app.app_context():\nassert (\nget_db().execute(\"select * from user where username = 'a'\").fetchone()\nis not none\n)\n@pytest.mark.parametrize(\n(\"username\", \"password\", \"message\"),\n(\n(\"\", \"\", b\"username is required.\"),\n(\"a\", \"\", b\"password is required.\"),\n(\"test\", \"test\", b\"already registered\"),\n),\n)\ndef test_register_validate_input(client, username, password, message):\nresponse = client.post(\n\"/auth/register\", data={\"username\": username, \"password\": password}\n)\nassert message in response.data\ndef test_login(client, auth):\nassert client.get(\"/auth/login\").status_code == 200\nresponse = auth.login()\nassert response.headers[\"location\"] == \"/\"\nwith client:\nclient.get(\"/\")\nassert session[\"user_id\"] == 1\nassert g.user[\"username\"] == \"test\"\n@pytest.mark.parametrize(\n(\"username\", \"password\", \"message\"),\n((\"a\", \"test\", b\"incorrect username.\"), (\"test\", \"a\", b\"incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\nresponse = auth.login(username, password)\nassert message in response.data\ndef test_logout(client, auth):\nauth.login()\nwith client:\nauth.logout()\nassert \"user_id\" not in session", "from __future__ import annotations\nimport json as _json\nimport typing as t\nfrom ..globals import current_app\nfrom .provider import _default\nif t.type_checking:\nfrom ..wrappers import response\ndef dumps(obj: t.any, **kwargs: t.any) -> str:\nif current_app:\nreturn current_app.json.dumps(obj, **kwargs)\nkwargs.setdefault(\"default\", _default)\nreturn _json.dumps(obj, **kwargs)\ndef dump(obj: t.any, fp: t.io[str], **kwargs: t.any) -> none:\nif current_app:\ncurrent_app.json.dump(obj, fp, **kwargs)\nelse:\nkwargs.setdefault(\"default\", _default)\n_json.dump(obj, fp, **kwargs)\ndef loads(s: str | bytes, **kwargs: t.any) -> t.any:\nif current_app:\nreturn current_app.json.loads(s, **kwargs)\nreturn _json.loads(s, **kwargs)\ndef load(fp: t.io[t.anystr], **kwargs: t.any) -> t.any:\nif current_app:\nreturn current_app.json.load(fp, **kwargs)\nreturn _json.load(fp, **kwargs)\ndef jsonify(*args: t.any, **kwargs: t.any) -> response:\nreturn current_app.json.response(*args, **kwargs)", "from __future__ import annotations\nimport typing as t\nfrom contextvars import contextvar\nfrom werkzeug.local import localproxy\nif t.type_checking:\nfrom .app import flask\nfrom .ctx import _appctxglobals\nfrom .ctx import appcontext\nfrom .ctx import requestcontext\nfrom .sessions import sessionmixin\nfrom .wrappers import request\n_no_app_msg =\n_cv_app: contextvar[appcontext] = contextvar(\"flask.app_ctx\")\napp_ctx: appcontext = localproxy(\n_cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: flask = localproxy(\n_cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _appctxglobals = localproxy(\n_cv_app, \"g\", unbound_message=_no_app_msg\n)\n_no_req_msg =\n_cv_request: contextvar[requestcontext] = contextvar(\"flask.request_ctx\")\nrequest_ctx: requestcontext = localproxy(\n_cv_request, unbound_message=_no_req_msg\n)\nrequest: request = localproxy(\n_cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: sessionmixin = localproxy(\n_cv_request, \"session\", unbound_message=_no_req_msg\n)", "import sqlite3\nfrom datetime import datetime\nimport click\nfrom flask import current_app\nfrom flask import g\ndef get_db():\nif \"db\" not in g:\ng.db = sqlite3.connect(\ncurrent_app.config[\"database\"], detect_types=sqlite3.parse_decltypes\n)\ng.db.row_factory = sqlite3.row\nreturn g.db\ndef close_db(e=none):\ndb = g.pop(\"db\", none)\nif db is not none:\ndb.close()\ndef init_db():\ndb = get_db()\nwith current_app.open_resource(\"schema.sql\") as f:\ndb.executescript(f.read().decode(\"utf8\"))\n@click.command(\"init-db\")\ndef init_db_command():\ninit_db()\nclick.echo(\"initialized the database.\")\nsqlite3.register_converter(\"timestamp\", lambda v: datetime.fromisoformat(v.decode()))\ndef init_app(app):\napp.teardown_appcontext(close_db)\napp.cli.add_command(init_db_command)", "import asyncio\nimport pytest\nfrom flask import blueprint\nfrom flask import flask\nfrom flask import request\nfrom flask.views import methodview\nfrom flask.views import view\npytest.importorskip(\"asgiref\")\nclass apperror(exception):\npass\nclass blueprinterror(exception):\npass\nclass asyncview(view):\nmethods = [\"get\", \"post\"]\nasync def dispatch_request(self):\nawait asyncio.sleep(0)\nreturn request.method\nclass asyncmethodview(methodview):\nasync def get(self):\nawait asyncio.sleep(0)\nreturn \"get\"\nasync def post(self):\nawait asyncio.sleep(0)\nreturn \"post\"\n@pytest.fixture(name=\"async_app\")\ndef _async_app():\napp = flask(__name__)\n@app.route(\"/\", methods=[\"get\", \"post\"])\n@app.route(\"/home\", methods=[\"get\", \"post\"])\nasync def index():\nawait asyncio.sleep(0)\nreturn request.method\n@app.errorhandler(apperror)\nasync def handle(_):\nreturn \"\", 412\n@app.route(\"/error\")\nasync def error():\nraise apperror()\nblueprint = blueprint(\"bp\", __name__)\n@blueprint.route(\"/\", methods=[\"get\", \"post\"])\nasync def bp_index():\nawait asyncio.sleep(0)\nreturn request.method\n@blueprint.errorhandler(blueprinterror)\nasync def bp_handle(_):\nreturn \"\", 412\n@blueprint.route(\"/error\")\nasync def bp_error():\nraise blueprinterror()\napp.register_blueprint(blueprint, url_prefix=\"/bp\")\napp.add_url_rule(\"/view\", view_func=asyncview.as_view(\"view\"))\napp.add_url_rule(\"/methodview\", view_func=asyncmethodview.as_view(\"methodview\"))\nreturn app\n@pytest.mark.parametrize(\"path\", [\"/\", \"/home\", \"/bp/\", \"/view\", \"/methodview\"])\ndef test_async_route(path, async_app):\ntest_client = async_app.test_client()\nresponse = test_client.get(path)\nassert b\"get\" in response.get_data()\nresponse = test_client.post(path)\nassert b\"post\" in response.get_data()\n@pytest.mark.parametrize(\"path\", [\"/error\", \"/bp/error\"])\ndef test_async_error_handler(path, async_app):\ntest_client = async_app.test_client()\nresponse = test_client.get(path)\nassert response.status_code == 412\ndef test_async_before_after_request():\napp_before_called = false\napp_after_called = false\nbp_before_called = false\nbp_after_called = false\napp = flask(__name__)\n@app.route(\"/\")\ndef index():\nreturn \"\"\n@app.before_request\nasync def before():", "@pytest.mark.parametrize(\"path\", [\"/error\", \"/bp/error\"])\ndef test_async_error_handler(path, async_app):\ntest_client = async_app.test_client()\nresponse = test_client.get(path)\nassert response.status_code == 412\ndef test_async_before_after_request():\napp_before_called = false\napp_after_called = false\nbp_before_called = false\nbp_after_called = false\napp = flask(__name__)\n@app.route(\"/\")\ndef index():\nreturn \"\"\n@app.before_request\nasync def before():\nnonlocal app_before_called\napp_before_called = true\n@app.after_request\nasync def after(response):\nnonlocal app_after_called\napp_after_called = true\nreturn response\nblueprint = blueprint(\"bp\", __name__)\n@blueprint.route(\"/\")\ndef bp_index():\nreturn \"\"\n@blueprint.before_request\nasync def bp_before():\nnonlocal bp_before_called\nbp_before_called = true\n@blueprint.after_request\nasync def bp_after(response):\nnonlocal bp_after_called\nbp_after_called = true\nreturn response\napp.register_blueprint(blueprint, url_prefix=\"/bp\")\ntest_client = app.test_client()\ntest_client.get(\"/\")\nassert app_before_called\nassert app_after_called\ntest_client.get(\"/bp/\")\nassert bp_before_called\nassert bp_after_called", "from __future__ import annotations\nimport logging\nimport os\nimport sys\nimport typing as t\nfrom datetime import timedelta\nfrom itertools import chain\nfrom werkzeug.exceptions import aborter\nfrom werkzeug.exceptions import badrequest\nfrom werkzeug.exceptions import badrequestkeyerror\nfrom werkzeug.routing import builderror\nfrom werkzeug.routing import map\nfrom werkzeug.routing import rule\nfrom werkzeug.sansio.response import response\nfrom werkzeug.utils import cached_property\nfrom werkzeug.utils import redirect as _wz_redirect\nfrom .. import typing as ft\nfrom ..config import config\nfrom ..config import configattribute\nfrom ..ctx import _appctxglobals\nfrom ..helpers import _split_blueprint_path\nfrom ..helpers import get_debug_flag\nfrom ..json.provider import defaultjsonprovider\nfrom ..json.provider import jsonprovider\nfrom ..logging import create_logger\nfrom ..templating import dispatchingjinjaloader\nfrom ..templating import environment\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import find_package\nfrom .scaffold import scaffold\nfrom .scaffold import setupmethod\nif t.type_checking:\nfrom werkzeug.wrappers import response as baseresponse\nfrom ..testing import flaskclient\nfrom ..testing import flaskclirunner\nfrom .blueprints import blueprint\nt_shell_context_processor = t.typevar(\n\"t_shell_context_processor\", bound=ft.shellcontextprocessorcallable\n)\nt_teardown = t.typevar(\"t_teardown\", bound=ft.teardowncallable)\nt_template_filter = t.typevar(\"t_template_filter\", bound=ft.templatefiltercallable)\nt_template_global = t.typevar(\"t_template_global\", bound=ft.templateglobalcallable)\nt_template_test = t.typevar(\"t_template_test\", bound=ft.templatetestcallable)\ndef _make_timedelta(value: timedelta | int | none) -> timedelta | none:\nif value is none or isinstance(value, timedelta):\nreturn value\nreturn timedelta(seconds=value)\nclass app(scaffold):\naborter_class = aborter\njinja_environment = environment\napp_ctx_globals_class = _appctxglobals\nconfig_class = config\ntesting = configattribute[bool](\"testing\")\nsecret_key = configattribute[t.union[str, bytes, none]](\"secret_key\")\npermanent_session_lifetime = configattribute[timedelta](\n\"permanent_session_lifetime\",\nget_converter=_make_timedelta,\n)\njson_provider_class: type[jsonprovider] = defaultjsonprovider", "class app(scaffold):\naborter_class = aborter\njinja_environment = environment\napp_ctx_globals_class = _appctxglobals\nconfig_class = config\ntesting = configattribute[bool](\"testing\")\nsecret_key = configattribute[t.union[str, bytes, none]](\"secret_key\")\npermanent_session_lifetime = configattribute[timedelta](\n\"permanent_session_lifetime\",\nget_converter=_make_timedelta,\n)\njson_provider_class: type[jsonprovider] = defaultjsonprovider\njinja_options: dict[str, t.any] = {}\nurl_rule_class = rule\nurl_map_class = map\ntest_client_class: type[flaskclient] | none = none\ntest_cli_runner_class: type[flaskclirunner] | none = none\ndefault_config: dict[str, t.any]\nresponse_class: type[response]\ndef __init__(\nself,\nimport_name: str,\nstatic_url_path: str | none = none,\nstatic_folder: str | os.pathlike[str] | none = \"static\",\nstatic_host: str | none = none,\nhost_matching: bool = false,\nsubdomain_matching: bool = false,\ntemplate_folder: str | os.pathlike[str] | none = \"templates\",\ninstance_path: str | none = none,\ninstance_relative_config: bool = false,\nroot_path: str | none = none,\n) -> none:\nsuper().__init__(\nimport_name=import_name,\nstatic_folder=static_folder,\nstatic_url_path=static_url_path,\ntemplate_folder=template_folder,\nroot_path=root_path,\n)\nif instance_path is none:\ninstance_path = self.auto_find_instance_path()\nelif not os.path.isabs(instance_path):\nraise valueerror(\n\"if an instance path is provided it must be absolute.\"\n\" a relative path was given instead.\"\n)\nself.instance_path = instance_path\nself.config = self.make_config(instance_relative_config)\nself.aborter = self.make_aborter()\nself.json: jsonprovider = self.json_provider_class(self)\nself.url_build_error_handlers: list[\nt.callable[[exception, str, dict[str, t.any]], str]\n] = []\nself.teardown_appcontext_funcs: list[ft.teardowncallable] = []\nself.shell_context_processors: list[ft.shellcontextprocessorcallable] = []\nself.blueprints: dict[str, blueprint] = {}\nself.extensions: dict[str, t.any] = {}\nself.url_map = self.url_map_class(host_matching=host_matching)\nself.subdomain_matching = subdomain_matching\nself._got_first_request = false", "] = []\nself.teardown_appcontext_funcs: list[ft.teardowncallable] = []\nself.shell_context_processors: list[ft.shellcontextprocessorcallable] = []\nself.blueprints: dict[str, blueprint] = {}\nself.extensions: dict[str, t.any] = {}\nself.url_map = self.url_map_class(host_matching=host_matching)\nself.subdomain_matching = subdomain_matching\nself._got_first_request = false\ndef _check_setup_finished(self, f_name: str) -> none:\nif self._got_first_request:\nraise assertionerror(\nf\"the setup method '{f_name}' can no longer be called\"\n\" on the application. it has already handled its first\"\n\" request, any changes will not be applied\"\n\" consistently.\\n\"\n\"make sure all imports, decorators, functions, etc.\"\n\" needed to set up the application are done before\"\n\" running it.\"\n)\n@cached_property\ndef name(self) -> str:\nif self.import_name == \"__main__\":\nfn: str | none = getattr(sys.modules[\"__main__\"], \"__file__\", none)\nif fn is none:\nreturn \"__main__\"\nreturn os.path.splitext(os.path.basename(fn))[0]\nreturn self.import_name\n@cached_property\ndef logger(self) -> logging.logger:\nreturn create_logger(self)\n@cached_property\ndef jinja_env(self) -> environment:\nreturn self.create_jinja_environment()\ndef create_jinja_environment(self) -> environment:\nraise notimplementederror()\ndef make_config(self, instance_relative: bool = false) -> config:\nroot_path = self.root_path\nif instance_relative:\nroot_path = self.instance_path\ndefaults = dict(self.default_config)\ndefaults[\"debug\"] = get_debug_flag()\nreturn self.config_class(root_path, defaults)\ndef make_aborter(self) -> aborter:\nreturn self.aborter_class()\ndef auto_find_instance_path(self) -> str:\nprefix, package_path = find_package(self.import_name)\nif prefix is none:\nreturn os.path.join(package_path, \"instance\")\nreturn os.path.join(prefix, \"var\", f\"{self.name}-instance\")\ndef create_global_jinja_loader(self) -> dispatchingjinjaloader:\nreturn dispatchingjinjaloader(self)\ndef select_jinja_autoescape(self, filename: str) -> bool:\nif filename is none:\nreturn true\nreturn filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n@property\ndef debug(self) -> bool:\nreturn self.config[\"debug\"]", "return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\ndef create_global_jinja_loader(self) -> dispatchingjinjaloader:\nreturn dispatchingjinjaloader(self)\ndef select_jinja_autoescape(self, filename: str) -> bool:\nif filename is none:\nreturn true\nreturn filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n@property\ndef debug(self) -> bool:\nreturn self.config[\"debug\"]\n@debug.setter\ndef debug(self, value: bool) -> none:\nself.config[\"debug\"] = value\nif self.config[\"templates_auto_reload\"] is none:\nself.jinja_env.auto_reload = value\n@setupmethod\ndef register_blueprint(self, blueprint: blueprint, **options: t.any) -> none:\nblueprint.register(self, options)\ndef iter_blueprints(self) -> t.valuesview[blueprint]:\nreturn self.blueprints.values()\n@setupmethod\ndef add_url_rule(\nself,\nrule: str,\nendpoint: str | none = none,\nview_func: ft.routecallable | none = none,\nprovide_automatic_options: bool | none = none,\n**options: t.any,\n) -> none:\nif endpoint is none:\nendpoint = _endpoint_from_view_func(view_func)\noptions[\"endpoint\"] = endpoint\nmethods = options.pop(\"methods\", none)\nif methods is none:\nmethods = getattr(view_func, \"methods\", none) or (\"get\",)\nif isinstance(methods, str):\nraise typeerror(\n\"allowed methods must be a list of strings, for\"\n' example: @app.route(..., methods=[\"post\"])'\n)\nmethods = {item.upper() for item in methods}\nrequired_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\nif provide_automatic_options is none:\nprovide_automatic_options = getattr(\nview_func, \"provide_automatic_options\", none\n)\nif provide_automatic_options is none:\nif \"options\" not in methods and self.config[\"provide_automatic_options\"]:\nprovide_automatic_options = true\nrequired_methods.add(\"options\")\nelse:\nprovide_automatic_options = false\nmethods |= required_methods\nrule_obj = self.url_rule_class(rule, methods=methods, **options)\nrule_obj.provide_automatic_options = provide_automatic_options\nself.url_map.add(rule_obj)\nif view_func is not none:\nold_func = self.view_functions.get(endpoint)", "if \"options\" not in methods and self.config[\"provide_automatic_options\"]:\nprovide_automatic_options = true\nrequired_methods.add(\"options\")\nelse:\nprovide_automatic_options = false\nmethods |= required_methods\nrule_obj = self.url_rule_class(rule, methods=methods, **options)\nrule_obj.provide_automatic_options = provide_automatic_options\nself.url_map.add(rule_obj)\nif view_func is not none:\nold_func = self.view_functions.get(endpoint)\nif old_func is not none and old_func != view_func:\nraise assertionerror(\n\"view function mapping is overwriting an existing\"\nf\" endpoint function: {endpoint}\"\n)\nself.view_functions[endpoint] = view_func\n@setupmethod\ndef template_filter(\nself, name: str | none = none\n) -> t.callable[[t_template_filter], t_template_filter]:\ndef decorator(f: t_template_filter) -> t_template_filter:\nself.add_template_filter(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_template_filter(\nself, f: ft.templatefiltercallable, name: str | none = none\n) -> none:\nself.jinja_env.filters[name or f.__name__] = f\n@setupmethod\ndef template_test(\nself, name: str | none = none\n) -> t.callable[[t_template_test], t_template_test]:\ndef decorator(f: t_template_test) -> t_template_test:\nself.add_template_test(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_template_test(\nself, f: ft.templatetestcallable, name: str | none = none\n) -> none:\nself.jinja_env.tests[name or f.__name__] = f\n@setupmethod\ndef template_global(\nself, name: str | none = none\n) -> t.callable[[t_template_global], t_template_global]:\ndef decorator(f: t_template_global) -> t_template_global:\nself.add_template_global(f, name=name)\nreturn f\nreturn decorator\n@setupmethod\ndef add_template_global(\nself, f: ft.templateglobalcallable, name: str | none = none\n) -> none:\nself.jinja_env.globals[name or f.__name__] = f\n@setupmethod\ndef teardown_appcontext(self, f: t_teardown) -> t_teardown:\nself.teardown_appcontext_funcs.append(f)\nreturn f\n@setupmethod\ndef shell_context_processor(", "return f\nreturn decorator\n@setupmethod\ndef add_template_global(\nself, f: ft.templateglobalcallable, name: str | none = none\n) -> none:\nself.jinja_env.globals[name or f.__name__] = f\n@setupmethod\ndef teardown_appcontext(self, f: t_teardown) -> t_teardown:\nself.teardown_appcontext_funcs.append(f)\nreturn f\n@setupmethod\ndef shell_context_processor(\nself, f: t_shell_context_processor\n) -> t_shell_context_processor:\nself.shell_context_processors.append(f)\nreturn f\ndef _find_error_handler(\nself, e: exception, blueprints: list[str]\n) -> ft.errorhandlercallable | none:\nexc_class, code = self._get_exc_class_and_code(type(e))\nnames = (*blueprints, none)\nfor c in (code, none) if code is not none else (none,):\nfor name in names:\nhandler_map = self.error_handler_spec[name][c]\nif not handler_map:\ncontinue\nfor cls in exc_class.__mro__:\nhandler = handler_map.get(cls)\nif handler is not none:\nreturn handler\nreturn none\ndef trap_http_exception(self, e: exception) -> bool:\nif self.config[\"trap_http_exceptions\"]:\nreturn true\ntrap_bad_request = self.config[\"trap_bad_request_errors\"]\nif (\ntrap_bad_request is none\nand self.debug\nand isinstance(e, badrequestkeyerror)\n):\nreturn true\nif trap_bad_request:\nreturn isinstance(e, badrequest)\nreturn false\ndef should_ignore_error(self, error: baseexception | none) -> bool:\nreturn false\ndef redirect(self, location: str, code: int = 302) -> baseresponse:\nreturn _wz_redirect(\nlocation,\ncode=code,\nresponse=self.response_class,\n)\ndef inject_url_defaults(self, endpoint: str, values: dict[str, t.any]) -> none:\nnames: t.iterable[str | none] = (none,)\nif \".\" in endpoint:\nnames = chain(\nnames, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n)\nfor name in names:\nif name in self.url_default_functions:\nfor func in self.url_default_functions[name]:\nfunc(endpoint, values)\ndef handle_url_build_error(\nself, error: builderror, endpoint: str, values: dict[str, t.any]\n) -> str:\nfor handler in self.url_build_error_handlers:\ntry:\nrv = handler(error, endpoint, values)", "if \".\" in endpoint:\nnames = chain(\nnames, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n)\nfor name in names:\nif name in self.url_default_functions:\nfor func in self.url_default_functions[name]:\nfunc(endpoint, values)\ndef handle_url_build_error(\nself, error: builderror, endpoint: str, values: dict[str, t.any]\n) -> str:\nfor handler in self.url_build_error_handlers:\ntry:\nrv = handler(error, endpoint, values)\nexcept builderror as e:\nerror = e\nelse:\nif rv is not none:\nreturn rv\nif error is sys.exc_info()[1]:\nraise\nraise error", "from __future__ import annotations\nimport typing as t\nfrom werkzeug.exceptions import badrequest\nfrom werkzeug.exceptions import httpexception\nfrom werkzeug.wrappers import request as requestbase\nfrom werkzeug.wrappers import response as responsebase\nfrom . import json\nfrom .globals import current_app\nfrom .helpers import _split_blueprint_path\nif t.type_checking:\nfrom werkzeug.routing import rule\nclass request(requestbase):\njson_module: t.any = json\nurl_rule: rule | none = none\nview_args: dict[str, t.any] | none = none\nrouting_exception: httpexception | none = none\n_max_content_length: int | none = none\n_max_form_memory_size: int | none = none\n_max_form_parts: int | none = none\n@property\ndef max_content_length(self) -> int | none:\nif self._max_content_length is not none:\nreturn self._max_content_length\nif not current_app:\nreturn super().max_content_length\nreturn current_app.config[\"max_content_length\"]\n@max_content_length.setter\ndef max_content_length(self, value: int | none) -> none:\nself._max_content_length = value\n@property\ndef max_form_memory_size(self) -> int | none:\nif self._max_form_memory_size is not none:\nreturn self._max_form_memory_size\nif not current_app:\nreturn super().max_form_memory_size\nreturn current_app.config[\"max_form_memory_size\"]\n@max_form_memory_size.setter\ndef max_form_memory_size(self, value: int | none) -> none:\nself._max_form_memory_size = value\n@property\ndef max_form_parts(self) -> int | none:\nif self._max_form_parts is not none:\nreturn self._max_form_parts\nif not current_app:\nreturn super().max_form_parts\nreturn current_app.config[\"max_form_parts\"]\n@max_form_parts.setter\ndef max_form_parts(self, value: int | none) -> none:\nself._max_form_parts = value\n@property\ndef endpoint(self) -> str | none:\nif self.url_rule is not none:\nreturn self.url_rule.endpoint\nreturn none\n@property\ndef blueprint(self) -> str | none:\nendpoint = self.endpoint\nif endpoint is not none and \".\" in endpoint:\nreturn endpoint.rpartition(\".\")[0]\nreturn none\n@property\ndef blueprints(self) -> list[str]:\nname = self.blueprint\nif name is none:\nreturn []\nreturn _split_blueprint_path(name)", "@property\ndef endpoint(self) -> str | none:\nif self.url_rule is not none:\nreturn self.url_rule.endpoint\nreturn none\n@property\ndef blueprint(self) -> str | none:\nendpoint = self.endpoint\nif endpoint is not none and \".\" in endpoint:\nreturn endpoint.rpartition(\".\")[0]\nreturn none\n@property\ndef blueprints(self) -> list[str]:\nname = self.blueprint\nif name is none:\nreturn []\nreturn _split_blueprint_path(name)\ndef _load_form_data(self) -> none:\nsuper()._load_form_data()\nif (\ncurrent_app\nand current_app.debug\nand self.mimetype != \"multipart/form-data\"\nand not self.files\n):\nfrom .debughelpers import attach_enctype_error_multidict\nattach_enctype_error_multidict(self)\ndef on_json_loading_failed(self, e: valueerror | none) -> t.any:\ntry:\nreturn super().on_json_loading_failed(e)\nexcept badrequest as ebr:\nif current_app and current_app.debug:\nraise\nraise badrequest() from ebr\nclass response(responsebase):\ndefault_mimetype: str | none = \"text/html\"\njson_module = json\nautocorrect_location_header = false\n@property\ndef max_cookie_size(self) -> int:\nif current_app:\nreturn current_app.config[\"max_cookie_size\"]\nreturn super().max_cookie_size", "from flask import blueprint\nfrom flask import render_template\nadmin = blueprint(\n\"admin\",\n__name__,\nurl_prefix=\"/admin\",\ntemplate_folder=\"templates\",\nstatic_folder=\"static\",\n)\n@admin.route(\"/\")\ndef index():\nreturn render_template(\"admin/index.html\")\n@admin.route(\"/index2\")\ndef index2():\nreturn render_template(\"./admin/index.html\")", "from flask import flask\napp = flask(__name__)\napp.config[\"debug\"] = true\nfrom blueprintapp.apps.admin import admin\nfrom blueprintapp.apps.frontend import frontend\napp.register_blueprint(admin)\napp.register_blueprint(frontend)", "import pytest\nfrom werkzeug.http import parse_set_header\nimport flask.views\ndef common_test(app):\nc = app.test_client()\nassert c.get(\"/\").data == b\"get\"\nassert c.post(\"/\").data == b\"post\"\nassert c.put(\"/\").status_code == 405\nmeths = parse_set_header(c.open(\"/\", method=\"options\").headers[\"allow\"])\nassert sorted(meths) == [\"get\", \"head\", \"options\", \"post\"]\ndef test_basic_view(app):\nclass index(flask.views.view):\nmethods = [\"get\", \"post\"]\ndef dispatch_request(self):\nreturn flask.request.method\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\ncommon_test(app)\ndef test_method_based_view(app):\nclass index(flask.views.methodview):\ndef get(self):\nreturn \"get\"\ndef post(self):\nreturn \"post\"\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\ncommon_test(app)\ndef test_view_patching(app):\nclass index(flask.views.methodview):\ndef get(self):\nraise zerodivisionerror\ndef post(self):\nraise zerodivisionerror\nclass other(index):\ndef get(self):\nreturn \"get\"\ndef post(self):\nreturn \"post\"\nview = index.as_view(\"index\")\nview.view_class = other\napp.add_url_rule(\"/\", view_func=view)\ncommon_test(app)\ndef test_view_inheritance(app, client):\nclass index(flask.views.methodview):\ndef get(self):\nreturn \"get\"\ndef post(self):\nreturn \"post\"\nclass betterindex(index):\ndef delete(self):\nreturn \"delete\"\napp.add_url_rule(\"/\", view_func=betterindex.as_view(\"index\"))\nmeths = parse_set_header(client.open(\"/\", method=\"options\").headers[\"allow\"])\nassert sorted(meths) == [\"delete\", \"get\", \"head\", \"options\", \"post\"]\ndef test_view_decorators(app, client):\ndef add_x_parachute(f):\ndef new_function(*args, **kwargs):\nresp = flask.make_response(f(*args, **kwargs))\nresp.headers[\"x-parachute\"] = \"awesome\"\nreturn resp\nreturn new_function\nclass index(flask.views.view):\ndecorators = [add_x_parachute]\ndef dispatch_request(self):\nreturn \"awesome\"\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nrv = client.get(\"/\")\nassert rv.headers[\"x-parachute\"] == \"awesome\"\nassert rv.data == b\"awesome\"\ndef test_view_provide_automatic_options_attr():", "resp.headers[\"x-parachute\"] = \"awesome\"\nreturn resp\nreturn new_function\nclass index(flask.views.view):\ndecorators = [add_x_parachute]\ndef dispatch_request(self):\nreturn \"awesome\"\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nrv = client.get(\"/\")\nassert rv.headers[\"x-parachute\"] == \"awesome\"\nassert rv.data == b\"awesome\"\ndef test_view_provide_automatic_options_attr():\napp = flask.flask(__name__)\nclass index1(flask.views.view):\nprovide_automatic_options = false\ndef dispatch_request(self):\nreturn \"hello world!\"\napp.add_url_rule(\"/\", view_func=index1.as_view(\"index\"))\nc = app.test_client()\nrv = c.open(\"/\", method=\"options\")\nassert rv.status_code == 405\napp = flask.flask(__name__)\nclass index2(flask.views.view):\nmethods = [\"options\"]\nprovide_automatic_options = true\ndef dispatch_request(self):\nreturn \"hello world!\"\napp.add_url_rule(\"/\", view_func=index2.as_view(\"index\"))\nc = app.test_client()\nrv = c.open(\"/\", method=\"options\")\nassert sorted(rv.allow) == [\"options\"]\napp = flask.flask(__name__)\nclass index3(flask.views.view):\ndef dispatch_request(self):\nreturn \"hello world!\"\napp.add_url_rule(\"/\", view_func=index3.as_view(\"index\"))\nc = app.test_client()\nrv = c.open(\"/\", method=\"options\")\nassert \"options\" in rv.allow\ndef test_implicit_head(app, client):\nclass index(flask.views.methodview):\ndef get(self):\nreturn flask.response(\"blub\", headers={\"x-method\": flask.request.method})\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nrv = client.get(\"/\")\nassert rv.data == b\"blub\"\nassert rv.headers[\"x-method\"] == \"get\"\nrv = client.head(\"/\")\nassert rv.data == b\"\"\nassert rv.headers[\"x-method\"] == \"head\"\ndef test_explicit_head(app, client):\nclass index(flask.views.methodview):\ndef get(self):\nreturn \"get\"\ndef head(self):\nreturn flask.response(\"\", headers={\"x-method\": \"head\"})\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nrv = client.get(\"/\")\nassert rv.data == b\"get\"\nrv = client.head(\"/\")\nassert rv.data == b\"\"\nassert rv.headers[\"x-method\"] == \"head\"\ndef test_endpoint_override(app):\napp.debug = true\nclass index(flask.views.view):", "class index(flask.views.methodview):\ndef get(self):\nreturn \"get\"\ndef head(self):\nreturn flask.response(\"\", headers={\"x-method\": \"head\"})\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nrv = client.get(\"/\")\nassert rv.data == b\"get\"\nrv = client.head(\"/\")\nassert rv.data == b\"\"\nassert rv.headers[\"x-method\"] == \"head\"\ndef test_endpoint_override(app):\napp.debug = true\nclass index(flask.views.view):\nmethods = [\"get\", \"post\"]\ndef dispatch_request(self):\nreturn flask.request.method\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\nwith pytest.raises(assertionerror):\napp.add_url_rule(\"/\", view_func=index.as_view(\"index\"))\ncommon_test(app)\ndef test_methods_var_inheritance(app, client):\nclass baseview(flask.views.methodview):\nmethods = [\"get\", \"propfind\"]\nclass childview(baseview):\ndef get(self):\nreturn \"get\"\ndef propfind(self):\nreturn \"propfind\"\napp.add_url_rule(\"/\", view_func=childview.as_view(\"index\"))\nassert client.get(\"/\").data == b\"get\"\nassert client.open(\"/\", method=\"propfind\").data == b\"propfind\"\nassert childview.methods == {\"propfind\", \"get\"}\ndef test_multiple_inheritance(app, client):\nclass getview(flask.views.methodview):\ndef get(self):\nreturn \"get\"\nclass deleteview(flask.views.methodview):\ndef delete(self):\nreturn \"delete\"\nclass getdeleteview(getview, deleteview):\npass\napp.add_url_rule(\"/\", view_func=getdeleteview.as_view(\"index\"))\nassert client.get(\"/\").data == b\"get\"\nassert client.delete(\"/\").data == b\"delete\"\nassert sorted(getdeleteview.methods) == [\"delete\", \"get\"]\ndef test_remove_method_from_parent(app, client):\nclass getview(flask.views.methodview):\ndef get(self):\nreturn \"get\"\nclass otherview(flask.views.methodview):\ndef post(self):\nreturn \"post\"\nclass view(getview, otherview):\nmethods = [\"get\"]\napp.add_url_rule(\"/\", view_func=view.as_view(\"index\"))\nassert client.get(\"/\").data == b\"get\"\nassert client.post(\"/\").status_code == 405\nassert sorted(view.methods) == [\"get\"]\ndef test_init_once(app, client):\nn = 0\nclass countinit(flask.views.view):\ninit_every_request = false\ndef __init__(self):\nnonlocal n\nn += 1", "class view(getview, otherview):\nmethods = [\"get\"]\napp.add_url_rule(\"/\", view_func=view.as_view(\"index\"))\nassert client.get(\"/\").data == b\"get\"\nassert client.post(\"/\").status_code == 405\nassert sorted(view.methods) == [\"get\"]\ndef test_init_once(app, client):\nn = 0\nclass countinit(flask.views.view):\ninit_every_request = false\ndef __init__(self):\nnonlocal n\nn += 1\ndef dispatch_request(self):\nreturn str(n)\napp.add_url_rule(\"/\", view_func=countinit.as_view(\"index\"))\nassert client.get(\"/\").data == b\"1\"\nassert client.get(\"/\").data == b\"1\"", "import os\nimport sys\nimport pytest\nfrom _pytest import monkeypatch\nfrom flask import flask\nfrom flask.globals import request_ctx\n@pytest.fixture(scope=\"session\", autouse=true)\ndef _standard_os_environ():\nmp = monkeypatch.monkeypatch()\nout = (\n(os.environ, \"flask_env_file\", monkeypatch.notset),\n(os.environ, \"flask_app\", monkeypatch.notset),\n(os.environ, \"flask_debug\", monkeypatch.notset),\n(os.environ, \"flask_run_from_cli\", monkeypatch.notset),\n(os.environ, \"werkzeug_run_main\", monkeypatch.notset),\n)\nfor _, key, value in out:\nif value is monkeypatch.notset:\nmp.delenv(key, false)\nelse:\nmp.setenv(key, value)\nyield out\nmp.undo()\n@pytest.fixture(autouse=true)\ndef _reset_os_environ(monkeypatch, _standard_os_environ):\nmonkeypatch._setitem.extend(_standard_os_environ)\n@pytest.fixture\ndef app():\napp = flask(\"flask_test\", root_path=os.path.dirname(__file__))\napp.config.update(\ntesting=true,\nsecret_key=\"test key\",\n)\nreturn app\n@pytest.fixture\ndef app_ctx(app):\nwith app.app_context() as ctx:\nyield ctx\n@pytest.fixture\ndef req_ctx(app):\nwith app.test_request_context() as ctx:\nyield ctx\n@pytest.fixture\ndef client(app):\nreturn app.test_client()\n@pytest.fixture\ndef test_apps(monkeypatch):\nmonkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\noriginal_modules = set(sys.modules.keys())\nyield\nfor key in sys.modules.keys() - original_modules:\nsys.modules.pop(key)\n@pytest.fixture(autouse=true)\ndef leak_detector():\nyield\nleaks = []\nwhile request_ctx:\nleaks.append(request_ctx._get_current_object())\nrequest_ctx.pop()\nassert leaks == []\n@pytest.fixture\ndef modules_tmp_path(tmp_path, monkeypatch):\nrv = tmp_path / \"modules_tmp\"\nrv.mkdir()\nmonkeypatch.syspath_prepend(os.fspath(rv))\nreturn rv\n@pytest.fixture\ndef modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\nmonkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\nreturn modules_tmp_path\n@pytest.fixture\ndef site_packages(modules_tmp_path, monkeypatch):\npy_dir = f\"python{sys.version_info.major}.{sys.version_info.minor}\"\nrv = modules_tmp_path / \"lib\" / py_dir / \"site-packages\"", "return rv\n@pytest.fixture\ndef modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\nmonkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\nreturn modules_tmp_path\n@pytest.fixture\ndef site_packages(modules_tmp_path, monkeypatch):\npy_dir = f\"python{sys.version_info.major}.{sys.version_info.minor}\"\nrv = modules_tmp_path / \"lib\" / py_dir / \"site-packages\"\nrv.mkdir(parents=true)\nmonkeypatch.syspath_prepend(os.fspath(rv))\nreturn rv\n@pytest.fixture\ndef purge_module(request):\ndef inner(name):\nrequest.addfinalizer(lambda: sys.modules.pop(name, none))\nreturn inner", "from datetime import datetime\nfrom datetime import timezone\nfrom uuid import uuid4\nimport pytest\nfrom markupsafe import markup\nfrom flask.json.tag import jsontag\nfrom flask.json.tag import taggedjsonserializer\n@pytest.mark.parametrize(\n\"data\",\n(\n{\" t\": (1, 2, 3)},\n{\" t__\": b\"a\"},\n{\" di\": \" di\"},\n{\"x\": (1, 2, 3), \"y\": 4},\n(1, 2, 3),\n[(1, 2, 3)],\nb\"\\xff\",\nmarkup(\"<html>\"),\nuuid4(),\ndatetime.now(tz=timezone.utc).replace(microsecond=0),\n),\n)\ndef test_dump_load_unchanged(data):\ns = taggedjsonserializer()\nassert s.loads(s.dumps(data)) == data\ndef test_duplicate_tag():\nclass tagdict(jsontag):\nkey = \" d\"\ns = taggedjsonserializer()\npytest.raises(keyerror, s.register, tagdict)\ns.register(tagdict, force=true, index=0)\nassert isinstance(s.tags[\" d\"], tagdict)\nassert isinstance(s.order[0], tagdict)\ndef test_custom_tag():\nclass foo:\ndef __init__(self, data):\nself.data = data\nclass tagfoo(jsontag):\n__slots__ = ()\nkey = \" f\"\ndef check(self, value):\nreturn isinstance(value, foo)\ndef to_json(self, value):\nreturn self.serializer.tag(value.data)\ndef to_python(self, value):\nreturn foo(value)\ns = taggedjsonserializer()\ns.register(tagfoo)\nassert s.loads(s.dumps(foo(\"bar\"))).data == \"bar\"\ndef test_tag_interface():\nt = jsontag(none)\npytest.raises(notimplementederror, t.check, none)\npytest.raises(notimplementederror, t.to_json, none)\npytest.raises(notimplementederror, t.to_python, none)\ndef test_tag_order():\nclass tag1(jsontag):\nkey = \" 1\"\nclass tag2(jsontag):\nkey = \" 2\"\ns = taggedjsonserializer()\ns.register(tag1, index=-1)\nassert isinstance(s.order[-2], tag1)\ns.register(tag2, index=none)\nassert isinstance(s.order[-1], tag2)", "from __future__ import annotations\nimport os\nimport typing as t\nfrom datetime import timedelta\nfrom .cli import appgroup\nfrom .globals import current_app\nfrom .helpers import send_from_directory\nfrom .sansio.blueprints import blueprint as sansioblueprint\nfrom .sansio.blueprints import blueprintsetupstate as blueprintsetupstate\nfrom .sansio.scaffold import _sentinel\nif t.type_checking:\nfrom .wrappers import response\nclass blueprint(sansioblueprint):\ndef __init__(\nself,\nname: str,\nimport_name: str,\nstatic_folder: str | os.pathlike[str] | none = none,\nstatic_url_path: str | none = none,\ntemplate_folder: str | os.pathlike[str] | none = none,\nurl_prefix: str | none = none,\nsubdomain: str | none = none,\nurl_defaults: dict[str, t.any] | none = none,\nroot_path: str | none = none,\ncli_group: str | none = _sentinel,\n) -> none:\nsuper().__init__(\nname,\nimport_name,\nstatic_folder,\nstatic_url_path,\ntemplate_folder,\nurl_prefix,\nsubdomain,\nurl_defaults,\nroot_path,\ncli_group,\n)\nself.cli = appgroup()\nself.cli.name = self.name\ndef get_send_file_max_age(self, filename: str | none) -> int | none:\nvalue = current_app.config[\"send_file_max_age_default\"]\nif value is none:\nreturn none\nif isinstance(value, timedelta):\nreturn int(value.total_seconds())\nreturn value\ndef send_static_file(self, filename: str) -> response:\nif not self.has_static_folder:\nraise runtimeerror(\"'static_folder' must be set to serve static_files.\")\nmax_age = self.get_send_file_max_age(filename)\nreturn send_from_directory(\nt.cast(str, self.static_folder), filename, max_age=max_age\n)\ndef open_resource(\nself, resource: str, mode: str = \"rb\", encoding: str | none = \"utf-8\"\n) -> t.io[t.anystr]:\nif mode not in {\"r\", \"rt\", \"rb\"}:\nraise valueerror(\"resources can only be opened for reading.\")\npath = os.path.join(self.root_path, resource)\nif mode == \"rb\":\nreturn open(path, mode)\nreturn open(path, mode, encoding=encoding)", "from __future__ import annotations\nimport typing as t\nfrom http import httpstatus\nfrom flask import flask\nfrom flask import jsonify\nfrom flask import stream_template\nfrom flask.templating import render_template\nfrom flask.views import view\nfrom flask.wrappers import response\napp = flask(__name__)\n@app.route(\"/str\")\ndef hello_str() -> str:\nreturn \"<p>hello, world!</p>\"\n@app.route(\"/bytes\")\ndef hello_bytes() -> bytes:\nreturn b\"<p>hello, world!</p>\"\n@app.route(\"/json\")\ndef hello_json() -> response:\nreturn jsonify(\"hello, world!\")\n@app.route(\"/json/dict\")\ndef hello_json_dict() -> dict[str, t.any]:\nreturn {\"response\": \"hello, world!\"}\n@app.route(\"/json/dict\")\ndef hello_json_list() -> list[t.any]:\nreturn [{\"message\": \"hello\"}, {\"message\": \"world\"}]\nclass statusjson(t.typeddict):\nstatus: str\n@app.route(\"/typed-dict\")\ndef typed_dict() -> statusjson:\nreturn {\"status\": \"ok\"}\n@app.route(\"/generator\")\ndef hello_generator() -> t.generator[str, none, none]:\ndef show() -> t.generator[str, none, none]:\nfor x in range(100):\nyield f\"data:{x}\\n\\n\"\nreturn show()\n@app.route(\"/generator-expression\")\ndef hello_generator_expression() -> t.iterator[bytes]:\nreturn (f\"data:{x}\\n\\n\".encode() for x in range(100))\n@app.route(\"/iterator\")\ndef hello_iterator() -> t.iterator[str]:\nreturn iter([f\"data:{x}\\n\\n\" for x in range(100)])\n@app.route(\"/status\")\n@app.route(\"/status/<int:code>\")\ndef tuple_status(code: int = 200) -> tuple[str, int]:\nreturn \"hello\", code\n@app.route(\"/status-enum\")\ndef tuple_status_enum() -> tuple[str, int]:\nreturn \"hello\", httpstatus.ok\n@app.route(\"/headers\")\ndef tuple_headers() -> tuple[str, dict[str, str]]:\nreturn \"hello, world!\", {\"content-type\": \"text/plain\"}\n@app.route(\"/template\")\n@app.route(\"/template/<name>\")\ndef return_template(name: str | none = none) -> str:\nreturn render_template(\"index.html\", name=name)\n@app.route(\"/template\")\ndef return_template_stream() -> t.iterator[str]:\nreturn stream_template(\"index.html\", name=\"hello\")\n@app.route(\"/async\")\nasync def async_route() -> str:\nreturn \"hello\"", "return \"hello, world!\", {\"content-type\": \"text/plain\"}\n@app.route(\"/template\")\n@app.route(\"/template/<name>\")\ndef return_template(name: str | none = none) -> str:\nreturn render_template(\"index.html\", name=name)\n@app.route(\"/template\")\ndef return_template_stream() -> t.iterator[str]:\nreturn stream_template(\"index.html\", name=\"hello\")\n@app.route(\"/async\")\nasync def async_route() -> str:\nreturn \"hello\"\nclass rendertemplateview(view):\ndef __init__(self: rendertemplateview, template_name: str) -> none:\nself.template_name = template_name\ndef dispatch_request(self: rendertemplateview) -> str:\nreturn render_template(self.template_name)\napp.add_url_rule(\n\"/about\",\nview_func=rendertemplateview.as_view(\"about_page\", template_name=\"about.html\"),\n)", "from __future__ import annotations\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import tracebacktype\nfrom werkzeug.exceptions import httpexception\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\nif t.type_checking:\nfrom _typeshed.wsgi import wsgienvironment\nfrom .app import flask\nfrom .sessions import sessionmixin\nfrom .wrappers import request\n_sentinel = object()\nclass _appctxglobals:\ndef __getattr__(self, name: str) -> t.any:\ntry:\nreturn self.__dict__[name]\nexcept keyerror:\nraise attributeerror(name) from none\ndef __setattr__(self, name: str, value: t.any) -> none:\nself.__dict__[name] = value\ndef __delattr__(self, name: str) -> none:\ntry:\ndel self.__dict__[name]\nexcept keyerror:\nraise attributeerror(name) from none\ndef get(self, name: str, default: t.any | none = none) -> t.any:\nreturn self.__dict__.get(name, default)\ndef pop(self, name: str, default: t.any = _sentinel) -> t.any:\nif default is _sentinel:\nreturn self.__dict__.pop(name)\nelse:\nreturn self.__dict__.pop(name, default)\ndef setdefault(self, name: str, default: t.any = none) -> t.any:\nreturn self.__dict__.setdefault(name, default)\ndef __contains__(self, item: str) -> bool:\nreturn item in self.__dict__\ndef __iter__(self) -> t.iterator[str]:\nreturn iter(self.__dict__)\ndef __repr__(self) -> str:\nctx = _cv_app.get(none)\nif ctx is not none:\nreturn f\"<flask.g of '{ctx.app.name}'>\"\nreturn object.__repr__(self)\ndef after_this_request(\nf: ft.afterrequestcallable[t.any],\n) -> ft.afterrequestcallable[t.any]:\nctx = _cv_request.get(none)\nif ctx is none:\nraise runtimeerror(\n\"'after_this_request' can only be used when a request\"\n\" context is active, such as in a view function.\"\n)\nctx._after_request_functions.append(f)\nreturn f", "return f\"<flask.g of '{ctx.app.name}'>\"\nreturn object.__repr__(self)\ndef after_this_request(\nf: ft.afterrequestcallable[t.any],\n) -> ft.afterrequestcallable[t.any]:\nctx = _cv_request.get(none)\nif ctx is none:\nraise runtimeerror(\n\"'after_this_request' can only be used when a request\"\n\" context is active, such as in a view function.\"\n)\nctx._after_request_functions.append(f)\nreturn f\nf = t.typevar(\"f\", bound=t.callable[..., t.any])\ndef copy_current_request_context(f: f) -> f:\nctx = _cv_request.get(none)\nif ctx is none:\nraise runtimeerror(\n\"'copy_current_request_context' can only be used when a\"\n\" request context is active, such as in a view function.\"\n)\nctx = ctx.copy()\ndef wrapper(*args: t.any, **kwargs: t.any) -> t.any:\nwith ctx:\nreturn ctx.app.ensure_sync(f)(*args, **kwargs)\nreturn update_wrapper(wrapper, f)\ndef has_request_context() -> bool:\nreturn _cv_request.get(none) is not none\ndef has_app_context() -> bool:\nreturn _cv_app.get(none) is not none\nclass appcontext:\ndef __init__(self, app: flask) -> none:\nself.app = app\nself.url_adapter = app.create_url_adapter(none)\nself.g: _appctxglobals = app.app_ctx_globals_class()\nself._cv_tokens: list[contextvars.token[appcontext]] = []\ndef push(self) -> none:\nself._cv_tokens.append(_cv_app.set(self))\nappcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\ndef pop(self, exc: baseexception | none = _sentinel) -> none:\ntry:\nif len(self._cv_tokens) == 1:\nif exc is _sentinel:\nexc = sys.exc_info()[1]\nself.app.do_teardown_appcontext(exc)\nfinally:\nctx = _cv_app.get()\n_cv_app.reset(self._cv_tokens.pop())\nif ctx is not self:\nraise assertionerror(\nf\"popped wrong app context. ({ctx!r} instead of {self!r})\"\n)\nappcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\ndef __enter__(self) -> appcontext:\nself.push()\nreturn self\ndef __exit__(\nself,\nexc_type: type | none,", "finally:\nctx = _cv_app.get()\n_cv_app.reset(self._cv_tokens.pop())\nif ctx is not self:\nraise assertionerror(\nf\"popped wrong app context. ({ctx!r} instead of {self!r})\"\n)\nappcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\ndef __enter__(self) -> appcontext:\nself.push()\nreturn self\ndef __exit__(\nself,\nexc_type: type | none,\nexc_value: baseexception | none,\ntb: tracebacktype | none,\n) -> none:\nself.pop(exc_value)\nclass requestcontext:\ndef __init__(\nself,\napp: flask,\nenviron: wsgienvironment,\nrequest: request | none = none,\nsession: sessionmixin | none = none,\n) -> none:\nself.app = app\nif request is none:\nrequest = app.request_class(environ)\nrequest.json_module = app.json\nself.request: request = request\nself.url_adapter = none\ntry:\nself.url_adapter = app.create_url_adapter(self.request)\nexcept httpexception as e:\nself.request.routing_exception = e\nself.flashes: list[tuple[str, str]] | none = none\nself.session: sessionmixin | none = session\nself._after_request_functions: list[ft.afterrequestcallable[t.any]] = []\nself._cv_tokens: list[\ntuple[contextvars.token[requestcontext], appcontext | none]\n] = []\ndef copy(self) -> requestcontext:\nreturn self.__class__(\nself.app,\nenviron=self.request.environ,\nrequest=self.request,\nsession=self.session,\n)\ndef match_request(self) -> none:\ntry:\nresult = self.url_adapter.match(return_rule=true)\nself.request.url_rule, self.request.view_args = result\nexcept httpexception as e:\nself.request.routing_exception = e\ndef push(self) -> none:\napp_ctx = _cv_app.get(none)\nif app_ctx is none or app_ctx.app is not self.app:\napp_ctx = self.app.app_context()\napp_ctx.push()\nelse:\napp_ctx = none\nself._cv_tokens.append((_cv_request.set(self), app_ctx))\nif self.session is none:\nsession_interface = self.app.session_interface\nself.session = session_interface.open_session(self.app, self.request)\nif self.session is none:\nself.session = session_interface.make_null_session(self.app)\nif self.url_adapter is not none:\nself.match_request()\ndef pop(self, exc: baseexception | none = _sentinel) -> none:", "app_ctx.push()\nelse:\napp_ctx = none\nself._cv_tokens.append((_cv_request.set(self), app_ctx))\nif self.session is none:\nsession_interface = self.app.session_interface\nself.session = session_interface.open_session(self.app, self.request)\nif self.session is none:\nself.session = session_interface.make_null_session(self.app)\nif self.url_adapter is not none:\nself.match_request()\ndef pop(self, exc: baseexception | none = _sentinel) -> none:\nclear_request = len(self._cv_tokens) == 1\ntry:\nif clear_request:\nif exc is _sentinel:\nexc = sys.exc_info()[1]\nself.app.do_teardown_request(exc)\nrequest_close = getattr(self.request, \"close\", none)\nif request_close is not none:\nrequest_close()\nfinally:\nctx = _cv_request.get()\ntoken, app_ctx = self._cv_tokens.pop()\n_cv_request.reset(token)\nif clear_request:\nctx.request.environ[\"werkzeug.request\"] = none\nif app_ctx is not none:\napp_ctx.pop(exc)\nif ctx is not self:\nraise assertionerror(\nf\"popped wrong request context. ({ctx!r} instead of {self!r})\"\n)\ndef __enter__(self) -> requestcontext:\nself.push()\nreturn self\ndef __exit__(\nself,\nexc_type: type | none,\nexc_value: baseexception | none,\ntb: tracebacktype | none,\n) -> none:\nself.pop(exc_value)\ndef __repr__(self) -> str:\nreturn (\nf\"<{type(self).__name__} {self.request.url!r}\"\nf\" [{self.request.method}] of {self.app.name}>\"\n)", "html {\nfont-family: sans-serif;\nbackground:\npadding: 1rem;\n}\nbody {\nmax-width: 960px;\nmargin: 0 auto;\nbackground: white;\n}\nh1, h2, h3, h4, h5, h6 {\nfont-family: serif;\ncolor:\nmargin: 1rem 0;\n}\na {\ncolor:\n}\nhr {\nborder: none;\nborder-top: 1px solid lightgray;\n}\nnav {\nbackground: lightgray;\ndisplay: flex;\nalign-items: center;\npadding: 0 0.5rem;\n}\nnav h1 {\nflex: auto;\nmargin: 0;\n}\nnav h1 a {\ntext-decoration: none;\npadding: 0.25rem 0.5rem;\n}\nnav ul  {\ndisplay: flex;\nlist-style: none;\nmargin: 0;\npadding: 0;\n}\nnav ul li a, nav ul li span, header .action {\ndisplay: block;\npadding: 0.5rem;\n}\n.content {\npadding: 0 1rem 1rem;\n}\n.content > header {\nborder-bottom: 1px solid lightgray;\ndisplay: flex;\nalign-items: flex-end;\n}\n.content > header h1 {\nflex: auto;\nmargin: 1rem 0 0.25rem 0;\n}\n.flash {\nmargin: 1em 0;\npadding: 1em;\nbackground:\nborder: 1px solid\n}\n.post > header {\ndisplay: flex;\nalign-items: flex-end;\nfont-size: 0.85em;\n}\n.post > header > div:first-of-type {\nflex: auto;\n}\n.post > header h1 {\nfont-size: 1.5em;\nmargin-bottom: 0;\n}\n.post .about {\ncolor: slategray;\nfont-style: italic;\n}\n.post .body {\nwhite-space: pre-line;\n}\n.content:last-child {\nmargin-bottom: 0;\n}\n.content form {\nmargin: 1em 0;\ndisplay: flex;\nflex-direction: column;\n}\n.content label {\nfont-weight: bold;\nmargin-bottom: 0.5em;\n}\n.content input, .content textarea {\nmargin-bottom: 1em;\n}\n.content textarea {\nmin-height: 12em;\nresize: vertical;\n}\ninput.danger {\ncolor:\n}\ninput[type=submit] {\nalign-self: start;\nmin-width: 10em;\n}", "import java.util.scanner;\npublic class t2 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter the radius and length of a cylinder: \");\ndouble radius = input.nextdouble();\ndouble length = input.nextdouble();\ndouble area = radius * radius * 3.14159;\ndouble volume = area * length;\nsystem.out.println(\"the area is \" + area);\nsystem.out.println(\"the volume of the cylinder is \" + volume);\n}\n}", "import java.util.scanner;\npublic class t3 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter weight in pounds: \");\ndouble weight = input.nextdouble();\nsystem.out.print(\"enter feet: \");\ndouble feet = input.nextdouble();\nsystem.out.print(\"enter inches: \");\ndouble inches = input.nextdouble();\ndouble height = feet * 12 + inches;\ndouble bmi = weight * 0.45359237 / ((height * 0.0254) * (height * 0.0254));\nsystem.out.println(\"bmi is \" + bmi);\nif (bmi < 18.5)\nsystem.out.println(\"underweight\");\nelse if (bmi < 25)\nsystem.out.println(\"normal\");\nelse if (bmi < 30)\nsystem.out.println(\"overweight\");\nelse\nsystem.out.println(\"obese\");\n}\n}", "public class t4 {\npublic static void main(string[] args) {\nsystem.out.println(\"miles\\t\\tkilometers\");\nsystem.out.println(\"-------------------------------\");\nint miles = 1;\nwhile (miles <= 10) {\nsystem.out.println(miles + \"\\t\\t\" + miles * 1.609);\nmiles++;\n}\n}\n}", "public class t5 {\npublic static void main(string[] args) {\nsystem.out.print(\"enter an integer: \");\njava.util.scanner input = new java.util.scanner(system.in);\nint number = input.nextint();\nreverse(number);\n}\npublic static void reverse(int number) {\nwhile (number != 0) {\nint remainder = number % 10;\nsystem.out.print(remainder);\nnumber = number / 10;\n}\nsystem.out.println();\n}\n}", "public class t6 {\npublic static void main(string[] args) {\njava.util.scanner input = new java.util.scanner(system.in);\nint[] num = new int[10];\nfor (int i = 0; i < 10; i++) {\nsystem.out.print(\"read a number: \");\nnum[i] = input.nextint();\n}\nfor (int i = 9; i >= 0; i--) {\nsystem.out.println(num[i]);\n}\n}\n}", "import java.util.scanner;\npublic class t7 {\npublic static void main(string[] args) {\nscanner input = new scanner(system.in);\nsystem.out.print(\"enter a 4 by 4 matrix row by row: \");\ndouble[][] m = new double[4][4];\nfor (int i = 0; i < 4; i++)\nfor (int j = 0; j < 4; j++)\nm[i][j] = input.nextdouble();\nsystem.out.print(\"sum of the elements in the major diagonal is \" + summajordiagonal(m));\n}\npublic static double summajordiagonal(double[][] m) {\ndouble sum = 0;\nfor (int i = 0; i < m.length; i++)\nsum += m[i][i];\nreturn sum;\n}\n}", "public class t1 {\npublic static void main(string[] args) {\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\nsystem.out.println(\"welcome to java\");\n}\n}", "{{ value|super_reverse }}", "{% extends 'base.html' %}\n{% block header %}\n<h1>{% block title %}log in{% endblock %}</h1>\n{% endblock %}\n{% block content %}\n<form method=\"post\">\n<label for=\"username\">username</label>\n<input name=\"username\" id=\"username\" required>\n<label for=\"password\">password</label>\n<input type=\"password\" name=\"password\" id=\"password\" required>\n<input type=\"submit\" value=\"log in\">\n</form>\n{% endblock %}", "hello from the admin", "<!doctype html>\n<title>{% block title %}{% endblock %} - flaskr</title>\n<link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\">\n<nav>\n<h1><a href=\"{{ url_for('index') }}\">flaskr</a></h1>\n<ul>\n{% if g.user %}\n<li><span>{{ g.user['username'] }}</span>\n<li><a href=\"{{ url_for('auth.logout') }}\">log out</a>\n{% else %}\n<li><a href=\"{{ url_for('auth.register') }}\">register</a>\n<li><a href=\"{{ url_for('auth.login') }}\">log in</a>\n{% endif %}\n</ul>\n</nav>\n<section class=\"content\">\n<header>\n{% block header %}{% endblock %}\n</header>\n{% for message in get_flashed_messages() %}\n<div class=\"flash\">{{ message }}</div>\n{% endfor %}\n{% block content %}{% endblock %}\n</section>", "{% macro hello(name) %}hello {{ name }}!{% endmacro %}", "<h1>{{ whiskey }}</h1>", "{% extends 'base.html' %}\n{% block header %}\n<h1>{% block title %}register{% endblock %}</h1>\n{% endblock %}\n{% block content %}\n<form method=\"post\">\n<label for=\"username\">username</label>\n<input name=\"username\" id=\"username\" required>\n<label for=\"password\">password</label>\n<input type=\"password\" name=\"password\" id=\"password\" required>\n<input type=\"submit\" value=\"register\">\n</form>\n{% endblock %}", "<p>{{ value }}|{{ injected_value }}", "{{ text }}\n{{ html }}\n{% autoescape false %}{{ text }}\n{{ html }}{% endautoescape %}\n{% autoescape true %}{{ text }}\n{{ html }}{% endautoescape %}", "{% extends 'base.html' %}\n{% block intro %}\n<a href=\"https:\nis the original javascript way to make requests. it's natively supported\nby all browsers, but has been superseded by\n<a href=\"{{ url_for(\"index\", js=\"fetch\") }}\"><code>fetch</code></a>.\n{% endblock %}\n{% block script %}\n<script>\nfunction addsubmit(ev) {\nev.preventdefault();\nvar request = new xmlhttprequest();\nrequest.addeventlistener('load', addshow);\nrequest.open('post', {{ url_for('add')|tojson }});\nrequest.send(new formdata(this));\n}\nfunction addshow() {\nvar data = json.parse(this.responsetext);\nvar span = document.getelementbyid('result');\nspan.innertext = data.result;\n}\nvar form = document.getelementbyid('calc');\nform.addeventlistener('submit', addsubmit);\n</script>\n{% endblock %}", "hello from the frontend", "<h1>hello world!</h1>", "<!doctype html>\n<html>\n<head>\n<meta charset=utf-8>\n<title>celery example</title>\n</head>\n<body>\n<h2>celery example</h2>\nexecute background tasks with celery. submits tasks and shows results using javascript.\n<hr>\n<h4>add</h4>\n<p>start a task to add two numbers, then poll for the result.\n<form id=add method=post action=\"{{ url_for(\"tasks.add\") }}\">\n<label>a <input type=number name=a value=4></label><br>\n<label>b <input type=number name=b value=2></label><br>\n<input type=submit>\n</form>\n<p>result: <span id=add-result></span></p>\n<hr>\n<h4>block</h4>\n<p>start a task that takes 5 seconds. however, the response will return immediately.\n<form id=block method=post action=\"{{ url_for(\"tasks.block\") }}\">\n<input type=submit>\n</form>\n<p id=block-result></p>\n<hr>\n<h4>process</h4>\n<p>start a task that counts, waiting one second each time, showing progress.\n<form id=process method=post action=\"{{ url_for(\"tasks.process\") }}\">\n<label>total <input type=number name=total value=\"10\"></label><br>\n<input type=submit>\n</form>\n<p id=process-result></p>\n<script>\nconst taskform = (formname, dopoll, report) => {\ndocument.forms[formname].addeventlistener(\"submit\", (event) => {\nevent.preventdefault()\nfetch(event.target.action, {\nmethod: \"post\",\nbody: new formdata(event.target)\n})\n.then(response => response.json())\n.then(data => {\nreport(null)\nconst poll = () => {\nfetch(`/tasks/result/${data[\"result_id\"]}`)\n.then(response => response.json())\n.then(data => {\nreport(data)\nif (!data[\"ready\"]) {\nsettimeout(poll, 500)\n} else if (!data[\"successful\"]) {\nconsole.error(formname, data)\n}\n})\n}\nif (dopoll) {\npoll()\n}\n})\n})\n}\ntaskform(\"add\", true, data => {\nconst el = document.getelementbyid(\"add-result\")\nif (data === null) {\nel.innertext = \"submitted\"\n} else if (!data[\"ready\"]) {\nel.innertext = \"waiting\"\n} else if (!data[\"successful\"]) {\nel.innertext = \"error, check console\"\n} else {", "console.error(formname, data)\n}\n})\n}\nif (dopoll) {\npoll()\n}\n})\n})\n}\ntaskform(\"add\", true, data => {\nconst el = document.getelementbyid(\"add-result\")\nif (data === null) {\nel.innertext = \"submitted\"\n} else if (!data[\"ready\"]) {\nel.innertext = \"waiting\"\n} else if (!data[\"successful\"]) {\nel.innertext = \"error, check console\"\n} else {\nel.innertext = data[\"value\"]\n}\n})\ntaskform(\"block\", false, data => {\ndocument.getelementbyid(\"block-result\").innertext = (\n\"request finished, check celery log to see task finish in 5 seconds\"\n)\n})\ntaskform(\"process\", true, data => {\nconst el = document.getelementbyid(\"process-result\")\nif (data === null) {\nel.innertext = \"submitted\"\n} else if (!data[\"ready\"]) {\nel.innertext = `${data[\"value\"][\"current\"]} / ${data[\"value\"][\"total\"]}`\n} else if (!data[\"successful\"]) {\nel.innertext = \"error, check console\"\n} else {\nel.innertext = \"\u2705 done\"\n}\nconsole.log(data)\n})\n</script>\n</body>\n</html>", "{% extends 'base.html' %}\n{% block header %}\n<h1>{% block title %}posts{% endblock %}</h1>\n{% if g.user %}\n<a class=\"action\" href=\"{{ url_for('blog.create') }}\">new</a>\n{% endif %}\n{% endblock %}\n{% block content %}\n{% for post in posts %}\n<article class=\"post\">\n<header>\n<div>\n<h1>{{ post['title'] }}</h1>\n<div class=\"about\">by {{ post['username'] }} on {{ post['created'].strftime('%y-%m-%d') }}</div>\n</div>\n{% if g.user['id'] == post['author_id'] %}\n<a class=\"action\" href=\"{{ url_for('blog.update', id=post['id']) }}\">edit</a>\n{% endif %}\n</header>\n<p class=\"body\">{{ post['body'] }}</p>\n</article>\n{% if not loop.last %}\n<hr>\n{% endif %}\n{% endfor %}\n{% endblock %}", "{% extends 'base.html' %}\n{% block header %}\n<h1>{% block title %}new post{% endblock %}</h1>\n{% endblock %}\n{% block content %}\n<form method=\"post\">\n<label for=\"title\">title</label>\n<input name=\"title\" id=\"title\" value=\"{{ request.form['title'] }}\" required>\n<label for=\"body\">body</label>\n<textarea name=\"body\" id=\"body\">{{ request.form['body'] }}</textarea>\n<input type=\"submit\" value=\"save\">\n</form>\n{% endblock %}", "{% if value is boolean %}\nsuccess!\n{% endif %}", "{% extends 'base.html' %}\n{% block header %}\n<h1>{% block title %}edit \"{{ post['title'] }}\"{% endblock %}</h1>\n{% endblock %}\n{% block content %}\n<form method=\"post\">\n<label for=\"title\">title</label>\n<input name=\"title\" id=\"title\" value=\"{{ request.form['title'] or post['title'] }}\" required>\n<label for=\"body\">body</label>\n<textarea name=\"body\" id=\"body\">{{ request.form['body'] or post['body'] }}</textarea>\n<input type=\"submit\" value=\"save\">\n</form>\n<hr>\n<form action=\"{{ url_for('blog.delete', id=post['id']) }}\" method=\"post\">\n<input class=\"danger\" type=\"submit\" value=\"delete\" onclick=\"return confirm('are you sure?');\">\n</form>\n{% endblock %}", "{% extends 'base.html' %}\n{% block intro %}\n<a href=\"https:\nadds cross browser apis for common tasks. however, it requires loading\nan extra library.\n{% endblock %}\n{% block script %}\n<script src=\"https:\n<script>\nfunction addsubmit(ev) {\nev.preventdefault();\n$.ajax({\nmethod: 'post',\nurl: {{ url_for('add')|tojson }},\ndata: $(this).serialize()\n}).done(addshow);\n}\nfunction addshow(data) {\n$('\n}\n$('\n</script>\n{% endblock %}", "{% extends 'base.html' %}\n{% block intro %}\n<a href=\"https:\nis the <em>modern</em> plain javascript way to make requests. it's\nsupported in all modern browsers.\n{% endblock %}\n{% block script %}\n<script>\nfunction addsubmit(ev) {\nev.preventdefault();\nfetch({{ url_for('add')|tojson }}, {\nmethod: 'post',\nbody: new formdata(this)\n})\n.then(parsejson)\n.then(addshow);\n}\nfunction parsejson(response) {\nreturn response.json();\n}\nfunction addshow(data) {\nvar span = document.getelementbyid('result');\nspan.innertext = data.result;\n}\nvar form = document.getelementbyid('calc');\nform.addeventlistener('submit', addsubmit);\n</script>\n{% endblock %}", "<!doctype html>\n<title>javascript example</title>\n<link rel=\"stylesheet\" href=\"https:\n<link rel=\"stylesheet\" href=\"https:\n<style>\nul { margin: 0; padding: 0; display: flex; list-style-type: none; }\nli > * { padding: 1em; }\nli.active > a { color:\nform { display: flex; }\nlabel > input { width: 3em; }\nform > * { padding-right: 1em; }\n</style>\n<ul>\n<li><span>type:</span>\n<li class=\"{% if js == 'fetch' %}active{% endif %}\">\n<a href=\"{{ url_for('index', js='fetch') }}\">fetch</a>\n<li class=\"{% if js == 'xhr' %}active{% endif %}\">\n<a href=\"{{ url_for('index', js='xhr') }}\">xhr</a>\n<li class=\"{% if js == 'jquery' %}active{% endif %}\">\n<a href=\"{{ url_for('index', js='jquery') }}\">jquery</a>\n</ul>\n<hr>\n<p>{% block intro %}{% endblock %}</p>\n<hr>\n<form id=\"calc\">\n<label>a <input name=\"a\"></label>\n<span>+</span>\n<label>b <input name=\"b\"></label>\n<input type=\"submit\" value=\"calculate\">\n</form>\n<span>= <span id=\"result\"></span></span>\n{% block script %}{% endblock %}", "{\n\"test_key\": \"foo\",\n\"secret_key\": \"config\"\n}", "flask is a lightweight [wsgi] web application framework. it is designed\nto make getting started quick and easy, with the ability to scale up to\ncomplex applications. it began as a simple wrapper around [werkzeug]\nand [jinja], and has become one of the most popular python web\napplication frameworks.\nflask offers suggestions, but doesn't enforce any dependencies or\nproject layout. it is up to the developer to choose the tools and\nlibraries they want to use. there are many extensions provided by the\ncommunity that make adding new functionality easy.\n[wsgi]: https:\n[werkzeug]: https:\n[jinja]: https:\n```python\nfrom flask import flask\napp = flask(__name__)\n@app.route(\"/\")\ndef hello():\nreturn \"hello, world!\"\n```\n```\n$ flask run\n* running on http:\n```\nthe pallets organization develops and supports flask and the libraries\nit uses. in order to grow the community of contributors and users, and\nallow the maintainers to devote more time to the projects, [please\ndonate today].\n[please donate today]: https:\nsee our [detailed contributing documentation][contrib] for many ways to\ncontribute, including reporting issues, requesting features, asking or answering\nquestions, and making prs.\n[contrib]: https:", "background tasks with celery\n============================\nthis example shows how to configure celery with flask, how to set up an api for\nsubmitting tasks and polling results, and how to use that api with javascript. see\n[flask's documentation about celery](https:\nfrom this directory, create a virtualenv and install the application into it. then run a\ncelery worker.\n```shell\n$ python3 -m venv .venv\n$ . ./.venv/bin/activate\n$ pip install -r requirements.txt && pip install -e .\n$ celery -a make_celery worker --loglevel info\n```\nin a separate terminal, activate the virtualenv and run the flask development server.\n```shell\n$ . ./.venv/bin/activate\n$ flask -a task_app run --debug\n```\ngo to http:\nrequests in the browser dev tools and the flask logs. you can see the tasks submitting\nand completing in the celery logs.", "this folder contains code that can be used by alternative flask\nimplementations, for example quart. the code therefore cannot do any\nio, nor be part of a likely io path. finally this code cannot use the\nflask globals.", "version: 2\nbuild:\nos: ubuntu-22.04\ntools:\npython: '3.12'\npython:\ninstall:\n- requirements: requirements/docs.txt\n- method: pip\npath: .\nsphinx:\nconfiguration: docs/conf.py\nbuilder: dirhtml\nfail_on_warning: true", "repos:\n- repo: https:\nrev: v0.11.2\nhooks:\n- id: ruff\n- id: ruff-format\n- repo: https:\nrev: v5.0.0\nhooks:\n- id: check-merge-conflict\n- id: debug-statements\n- id: fix-byte-order-marker\n- id: trailing-whitespace\n- id: end-of-file-fixer", "insert into user (username, password)\nvalues\n('test', 'pbkdf2:sha256:50000$tci4gzcx$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n('other', 'pbkdf2:sha256:50000$kjpksz6n$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\ninsert into post (title, body, author_id, created)\nvalues\n('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');", "-- initialize the database.\n-- drop any existing data and create empty tables.\ndrop table if exists user;\ndrop table if exists post;\ncreate table user (\nid integer primary key autoincrement,\nusername text unique not null,\npassword text not null\n);\ncreate table post (\nid integer primary key autoincrement,\nauthor_id integer not null,\ncreated timestamp not null default current_timestamp,\ntitle text not null,\nbody text not null,\nforeign key (author_id) references user (id)\n);"]